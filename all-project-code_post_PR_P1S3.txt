
// =================================================================
// METADATA
// =================================================================
// File Path:      CHANGELOG.md
// Size:           13.49 KB
// Last Modified:  2025-11-19T10:49:21.914Z
// =================================================================

# [2.2.0] - 2025-11-18

### Added
- **PR-P1S3 Complete**: Data Pipeline Hardening with Strict Typing and Cross-Reference Validation
  - **Typed Data Models**: Complete enum definitions and TypedDict models for all game data structures
  - **Cross-Reference Validation**: Runtime validation ensures skills reference existing effects, items reference valid affixes
  - **Static Type Checking**: mypy integration ensures compile-time type safety for data layer
  - **Triple Validation Layer**: Schema enforcement + cross-reference checks + type safety validation
  - **Enhanced EntityStats**: Added `life_steal`, `damage_multiplier`, and `movement_speed` for comprehensive stat support
  - **Production-Ready Data Provider**: GameDataProvider with singleton pattern and comprehensive error resilience

### Technical Details
- **Data Integrity**: 69 items, 63 affixes, 35 effects, 28 skills all validated at load time
- **Type Safety**: Full mypy coverage on data access layer with strict error checking
- **Performance**: Sub-millisecond data loading and validation with hot-reload capability
- **Architecture**: Progressive validation (parse â†’ validate â†’ hydrate â†’ cross-reference) catches errors at appropriate stages
- **Testing**: Comprehensive validation tests ensure data integrity in all scenarios

### Breaking Changes
- **Data Model Enhancement**: Enhanced EntityStats requires stat validation on existing equippable items
- **Type Requirements**: Data access layer now requires full type annotations and validation

## [2.2.1] - 2025-11-19

### Fixed
- **Data Corrections**: Fixed multiple typos in CSV data files (e.g., "Posion" â†’ "Poison", "daamge" â†’ "damage")
- **Test Suite Stability**: Corrected test property names (`is_crit` â†’ `was_crit`), added missing StateManager entity registrations
- **Engine Code Quality**: Fixed tier 3 crit calculation returning int instead of float, improved type consistency
- **Repository Maintenance**: Added node_Modules to .gitignore, updated changelog formatting

### Technical Details
- **Test Coverage**: All 25 engine unit tests now passing (100% success rate)
- **Data Integrity**: CSV files validated with corrected effect and skill references
- **Critical Hit Mechanics**: Fixed tier 3 critical hit damage multipliers for Legendary/Mythic rarities
- **Type Safety**: Consistent float handling throughout hit context and damage calculations

# [](https://github.com/Towen75/combat_engine/compare/v2.1.0...v) (2025-11-17)



# [](https://github.com/Towen75/combat_engine/compare/v2.0.0...v) (2025-11-17)



# [](https://github.com/Towen75/combat_engine/compare/v1.0.0...v) (2025-11-16)



## [1.0.0] - 2025-11-15

### Added
- **COMPLETE GDD v4.0 Combat Engine Implementation**: Full system delivery exceeding original IP scope
  - **9-Step Unified Combat Pipeline**: Complete evasionâ†’dodgeâ†’critâ†’defenseâ†’blockâ†’final damage resolution
  - **Advanced Dual-Stat Affixes**: Single affixes affecting multiple stats simultaneously (damage + crit)
  - **Scaling AffixSystem**: Power-level logarithmic scaling based on character strength
  - **Complex Reactive Effects**: Advanced trigger parsing for "reflect_damage:0.3", "apply_crit_bonus:0.25"
  - **Master Rule Data System**: Complete CSV-driven content creation (skills.csv, effects.csv, affixes.csv)
- **Phase 3 Advanced Systems**: Beyond-IP implementation of complex trigger effects and handlers
  - **FocusedRageHandler**: Crit bonus on special skill use
  - **BlindingRebukeHandler**: Evasion penalty to blocked attackers
  - **Complex Trigger Parsing**: "effect_name:number" â†’ proper effect execution
- **Phase 4 Data Master System**: Complete content creation framework
  - **MasterRuleData Loader**: Centralized CSV loading with validation and consistency checking
  - **EffectDefinition System**: Complete buff/debuff/dot mechanics (16 different effect types)
  - **LoadedSkill Objects**: Runtime skill generation with trigger parsing and metadata
  - **Data Integrity**: Query methods and cross-reference validation
- **Phase 5 Production Validation**: Complete end-to-end testing and verification
  - **run_full_test.py**: 10-second simulation with cooldowns and resource management
  - **Combat Verification**: Real skill execution, damage calculation, effect triggering
  - **Test Suite Expansion**: 16 skills loading successfully, functional trigger effects

### Technical Details
- **Architecture Excellence**: Event-driven design with 96+ unit tests (100% pass rate)
- **Data-Driven Mechanics**: Zero hardcoded skills/effects - all CSV configurable
- **Performance Validation**: Sub-millisecond execution with production simulation throughput
- **Godot Port Ready**: Complete Python prototype providing technical specification for GDScript implementation
- **Documentation Complete**: Updated memory bank reflecting full advanced system implementation
- **Quality Assurance**: Comprehensive testing with battle-tested combat validation

### Breaking Changes
- **Major Feature Expansion**: System scope far exceeds original specification (all remaining phases completed)
- **Advanced Affix System**: Dual-stat and scaling mechanics add complexity to stat calculations
- **CSV Data Requirements**: Core mechanics now depend on properly formatted CSV data files

## [0.7.0] - 2025-11-14

### Added
- **Code Review Implementation**: Major architectural overhaul transforming prototype to production-ready system
  - **Phase 1 - Action/Result Pattern**: Implemented `SkillUseResult` + `Action` hierarchy for decoupled execution
  - **CombatOrchestrator**: Dependency injection pattern for clean separation between calculation and execution
  - **Pure Functions**: Zero side effects in `calculate_skill_use()` with complete test coverage
- **Phase 2 - Effect System Generalization**: Generic `DamageOnHitHandler` with configurable `DamageOnHitConfig`
  - **Data-Driven Effects**: Add new DoT effects without code changes (css Burn, Freeze, Life Drain)
  - **Template Method Pattern**: Reusable effect framework with `create_bleed_handler()` and `create_poison_handler()`
  - **Zero-Code Extensibility**: Future effects defined entirely in configuration
- **Phase 3 - Data Integrity & Access**: Centralized data management with comprehensive validation
  - **GameDataProvider Singleton**: Centralized JSON data loading with error resilience and reload capability
  - **Stat Validation**: Entity.calculate_final_stats() validates affix stat names with helpful logging
  - **ItemGenerator Integration**: Refactored to use centralized provider with full backward compatibility

### Technical Details
- **Testing**: 129 unit tests (up from 96), 100% pass rate with comprehensive action-based validation
- **Architecture**: Production-ready with proper separation of concerns, dependency injection, and Godot compatibility
- **Performance**: All architectural improvements maintain sub-millisecond execution times
- **Error Resilience**: Input validation prevents runtime crashes while providing clear error messages
- **Godot Port Readiness**: Action/Result and dependency injection patterns translate directly to GDScript signals

### Breaking Changes
- **Architectural Refactoring**: Pure calculation functions and orchestrator execution pattern
- **Effect Framework Overhaul**: Generic configurable handlers replace hardcoded implementations
- **Data Access Centralization**: GameDataProvider singleton for all JSON loading
- **Enhanced Validation**: Stat name validation in final stat calculations

## [0.6.0] - 2025-11-14

### Added
- **Phase 5 Complete**: Procedural Item Generator system implementation
  - **ItemGenerator**: Two-phase quality rolls with sub-quality variation preventing identical items
  - **Data Pipeline**: CSV-to-JSON parsing system for affixes, items, and quality tiers
  - **Sub-Quality Variation**: Each affix rolls 0-X% where X = item's quality ceiling for unique characteristics
  - **Content Library**: 17 items Ã— 9 affixes covering all equipment slots and rarities
  - **Data-Driven Design**: Add new content without code changes using CSV files
  - **Display Formatting**: Smart percentage formatting for multiplier stats (crits, pierce, resistance)

### Technical Details
- **Performance**: 93 unit tests with 100% pass rate, sub-millisecond item generation
- **Architecture**: Data-driven item generation with quality ceilings preventing overpowered items
- **Testing**: Comprehensive unit tests with RNG seeding for deterministic validation
- **Extensibility**: CSV-based content system supporting unlimited item/affix additions
- **Integration**: Full compatibility with existing Entity equipment system

### Breaking Changes
- **Item Model Update**: New Item dataclass with procedural generation mechanics
- **Affix System Refactor**: RolledAffix replaces static Affix with rolled values
- **Entity Integration**: Updated stat calculation for percentage-formatted multipliers

## [0.5.0] - 2025-11-11



# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [0.4.0] - 2025-11-11

### Added
- **Phase 4 Complete**: Simulation & Balancing framework implementation
  - **CombatLogger System**: Comprehensive event recording and analysis with damage breakdown and effect uptime tracking
  - **SimulationRunner**: Time-based combat simulation with delta-time processing and automated scenario testing
  - **ReportGenerator**: Automated balance analysis with actionable recommendations and performance metrics
  - **Integration Testing**: Full system validation with seeded combat scenarios and reproducible results
- **Testing Expansion**: 22 unit tests with 100% pass rate (total 92 tests across all phases)
  - CombatLogger functionality tests
  - SimulationRunner time-based processing tests
  - ReportGenerator balance analysis tests
  - Integration scenario validation
- **Performance Achievements**: 6993 events/second simulation throughput with excellent scalability
- **Documentation**: Attack speed design document and comprehensive memory bank updates

### Technical Details
- **Performance**: Simulation framework achieves 6993 events/second with sub-millisecond execution times
- **Architecture**: Event-driven simulation with time-based processing and automated balance analysis
- **Testing**: Comprehensive unit test coverage with complex mocking for interdependent systems
- **Integration**: Full end-to-end validation with seeded random scenarios for reproducible testing

## [0.3.0] - 2025-11-10

### Added
- **Phase 3 Complete**: Game systems implementation - Items, Skills & Equipment
  - **Item System**: Affix and Item data models with stat modification logic
  - **Equipment System**: Dynamic stat calculation with flat/multiplier bonuses
  - **Skill System**: Multi-hit skills with configurable triggers and effects
  - **Effect Framework**: EffectHandler base class with Bleed and Poison implementations
  - **Integration Testing**: Complete end-to-end validation ("Phase 3 Test" script)
- **Testing Expansion**: 70 unit tests with 100% pass rate (17 new tests added)
  - Equipment and affix model tests
  - Skill processing and trigger tests
  - Effect handler functionality tests
  - Integration scenario validation
- **Dynamic Stat Calculation**: Real-time equipment bonus computation
  - Flat bonuses (e.g., +20 damage)
  - Multiplier bonuses (e.g., 1.5x pierce ratio)
  - Combined stat stacking and validation

### Technical Details
- **Performance**: All systems maintain sub-millisecond execution times
- **Architecture**: Event-driven skill effects integrated with existing EventBus
- **Extensibility**: Modular effect system for easy addition of new effects
- **Validation**: Comprehensive testing with 100% coverage on new functionality

## [0.2.0] - 2025-11-09

### Added
- **Phase 1 Complete**: Full combat foundation implementation
  - Core damage formula with pierce mechanics: `MAX((Attack Damage - Defences), (Attack Damage * Pierce Ratio))`
  - Entity and EntityStats data models with comprehensive validation
  - StateManager for dynamic entity state tracking (health, alive status)
  - CombatEngine with damage calculation and analysis tools
  - Complete integration test ("First Hit" demo script)
- **Testing Infrastructure**: 53 unit tests with 100% pass rate
  - Entity model validation tests
  - State management tests
  - Damage calculation tests
  - Integration validation
- **Development Setup**: Complete Python development environment
  - Virtual environment configuration
  - pytest testing framework
  - Git version control with proper ignore rules
  - Requirements management

### Technical Details
- **Performance**: Combat calculations complete in < 1ms per hit
- **Validation**: Input validation on all data models and operations
- **Architecture**: Modular design with clear separation of concerns
- **Documentation**: Complete memory bank with project knowledge base

## [0.1.0] - 2025-11-09

### Added
- **Project Initialization**: Combat Engine project setup
- **Memory Bank**: Documentation framework established
- **Design Documents**: Core combat system specifications
- **Development Infrastructure**: Git repository and basic structure

### Technical Details
- **Python Environment**: 3.12.10 with virtual environment
- **Dependencies**: NumPy, Pandas, pytest, pydantic configured
- **Documentation**: Project brief, context, and technical specifications



// =================================================================
// METADATA
// =================================================================
// File Path:      data\affixes.csv
// Size:           7.29 KB
// Last Modified:  2025-11-18T20:35:29.297Z
// =================================================================

affix_id,stat_affected,mod_type,affix_pools,base_value,description,trigger_event,proc_rate,trigger_result,trigger_duration,stacks_max,dual_stat,scaling_power,complex_effect
flat_dmg,base_damage,flat,weapon_pool|axe_pool,50,+{value} Base Damage,,,,,,,,
crit_dmg,crit_damage,flat,weapon_pool|jewelry_pool,0.5,+{value}% Crit Damage,,,,,,,,
bleed_chance,base_damage,flat,axe_pool|sword_pool,0,+{value}% chance to Bleed,OnHit,0.25,bleed,10,5,,,
flat_armor,armor,flat,armor_pool,150,+{value} Armor,,,,,,,,
attack_speed,attack_speed,multiplier,weapon_pool,0.2,+{value}% Attack Speed,,,,,,,,
health,max_health,flat,armor_pool|jewelry_pool,100,+{value} Health,,,,,,,,
crit_chance,crit_chance,flat,jewelry_pool,0.1,{value}% Critical Strike Chance,,,,,,,,
pierce_bonus,pierce_ratio,flat,weapon_pool,0.08,{value}% Pierce Ratio,,,,,,,,
resistance,resistances,flat,armor_pool,0.15,{value}% Elemental Resistances,,,,,,,,
focused_rage,crit_damage,multiplier,jewelry_pool,0,+{value}% Crit Damage,OnSkillUsed,1,apply_crit_bonus:0.25,5,3,,,true|special_skill
thornmail,armor,multiplier,armor_pool,0,Reflects {value}% of blocked damage back to attacker,OnBlock,0.5,reflect_damage:0.3,,,,,
swiftslayer,attack_speed;cooldown_reduction,multiplier;flat,weapon_pool,0.25;0.08,{value}% Attack Speed & {dual_value}% CD Reduction,,,,,,TRUE,,
vorpal_edge,base_damage,flat,weapon_pool|sword_pool,28,+{value} Base Damage,, , , , , , ,
siphon_strikes,max_health;life_steal,multiplier;scaling,jewelry_pool,0.06;0.08,{value}% Max Health & {dual_value}% Life Steal on Hit,OnHit,0.25,life_steal:0.08,5,5,TRUE,1.05,
hollow_point,pierce_ratio,flat,weapon_pool,0.12,{value}% Pierce Ratio,, , , , , , ,
adamant_ward,armor,flat,armor_pool,240,+{value} Armor,, , , , , , ,
tempest_swiftness,attack_speed,multiplier,weapon_pool,0.18,+{value}% Attack Speed,, , , , , , ,
mimic_shield,block_chance,flat,shield_pool,0.12,+{value}% Block Chance,OnBlock,1,grant_buff:reflective_shield,3,1, , ,
venomous_edge,base_damage,flat,weapon_pool|dagger_pool,12,+{value} Base Damage,OnHit,0.2,apply_debuff:poison,6,5, , ,
resolute_stone,resistances,multiplier,armor_pool,0.2,{value}% Elemental Resistances,, , , , , , ,
pulsing_core,crit_chance,multiplier,jewelry_pool,0.045,+{value}% Critical Strike Chance,OnHit,0.15,apply_debuff:pulse,4,3, , ,
devastating_strikes,crit_chance;crit_damage,flat;flat,jewelry_pool,0.075;0.35,{value}% Crit Chance & {dual_value}% Crit Damage,, , , ,,TRUE,,
precision_power,pierce_ratio;max_resource,multiplier;flat,weapon_pool,0.12;30,{value}% Pierce & {dual_value} Max Resource,, , , ,,TRUE,,
berserker_rage,base_damage;crit_chance,scaling;scaling,jewelry_pool,0.5;0.3,{value}% Damage & Crit (scales with power),OnSkillUsed,1,apply_buff:berserk,5,1,TRUE,1.12,
frozen_core,block_chance,flat,armor_pool,0.1,+{value}% chance to downgrade hits to Glancing Blow,OnHit,0.2,apply_debuff:slow,3,1, , ,
retribution,armor,multiplier,shield_pool,0.15,Reflects {value}% of blocked damage back to attacker,OnBlock,1,reflect_damage:0.15,0,1, , ,
echoing_blow,damage_multiplier,flat,weapon_pool,0.18,Chance to repeat 1 extra hit at {value}% damage,OnHit,0.08,repeat_hit:0.18,0,1, , ,
lifebind,life_steal,multiplier,jewelry_pool,0.06,+{value}% Life Steal on Hit,OnHit,0.25,heal_source:life_steal,0,5, , ,
toxin_edge,base_damage,flat,weapon_pool|dagger_pool,8,+{value} Damage vs poisoned targets,OnHit,1,bonus_vs:poisoned,0,1,,,
venom_mastery,damage_over_time,multiplier,jewelry_pool,0.2,+{value}% DoT damage,, , , , , , ,
frostbite_power,damage_multiplier,multiplier,weapon_pool|spear_pool,0.15,{value}% more damage to slowed/frostbitten targets,OnHit,1,bonus_vs:frostbitten,0,1,,,
burning_fury,attack_speed,multiplier,weapon_pool,0.12,+{value}% attack speed while target is burning,OnHit,1,check_effect:burn,0,1,,,
echo_chance,damage_multiplier,flat,weapon_pool,0.15,+{value}% chance to echo attacks,OnHit,0.15,repeat_hit:0.50,0,1,,,
charged_strikes,crit_chance,multiplier,weapon_pool|staff_pool,0.1,+{value}% crit chance vs shocked targets,OnHit,1,bonus_vs:shocked,0,1,,,
corrosive_weapons,pierce_ratio,multiplier,weapon_pool,0.18,{value}% armor penetration vs corroded enemies,OnHit,1,bonus_vs:corroded,0,1,,,
stone_skin,armor,flat,armor_pool,35,+{value} Armor,, , , , , , ,
glacial_aegis,armor,multiplier,armor_pool,0.1,{value}% reduced damage while slowed target attackers,OnHit,1,check_effect:frostbite,0,1,,,
reforged_plate,block_chance,flat,armor_pool,0.08,+{value}% block chance,, , , , , , ,
shock_resonance,resistances,multiplier,armor_pool,0.15,{value}% lightning resistance,, , , , , , ,
soul_barrier,max_health,flat,armor_pool,40,+{value} Max Health,, , , , , , ,
wind_steps,movement_speed,multiplier,jewelry_pool,0.15,+{value}% movement speed,, , , , , , ,
focus_mind,crit_chance,multiplier,jewelry_pool,0.12,+{value}% crit chance while Focus is active,OnSelf,1,check_effect:focus,0,1,,,
berserker_heart,damage_multiplier,multiplier,jewelry_pool,0.2,{value}% damage while Rage is active,OnSelf,1,check_effect:rage,0,1,,,
echo_brightness,damage_multiplier,multiplier,jewelry_pool,0.3,{value}% damage to Echo Marked targets,OnHit,1,bonus_vs:echo_marked,0,1,,,
acidic_rebound,armor,multiplier,shield_pool,0.12,Reflect {value}% of acid/corrosion damage taken,, , , , , , ,
mirror_shield,armor,multiplier,shield_pool,0.18,Reflects {value}% of all damage taken back to attacker,OnHit,0.3,reflect_damage:0.18,0,1,,,shield_buff
poison_stab,base_damage,flat,weapon_pool|dagger_pool,6,+{value} Damage and poison on hit,OnHit,1,apply_debuff:poison,6,1,,,
flame_arc,damage_multiplier,multiplier,weapon_pool|sword_pool,0.25,{value}% fire damage on hit,OnHit,0.4,burn,3,1,,,
glacial_spike,damage_multiplier,multiplier,weapon_pool|spear_pool,0.2,{value}% cold damage and slow,OnHit,0.35,frostbite,4,2,,,
corrosion,damage_multiplier,multiplier,armor_pool,0.15,{value}% acid damage and armor reduction,OnHit,0.3,corrosion,6,3,,,
echo_strike,damage_multiplier,flat,weapon_pool|sword_pool,0.3,{value}% damage with echo effect,OnHit,0.5,echo_mark,2,1,,,
rallying_cry,movement_speed;movement_speed,flat;flat,jewelry_pool,0.15;0.1,{value}% movement speed & attack speed,OnSkillUsed,1,apply_buff:haste,8,2,TRUE,,
shadow_slash,damage_multiplier,multiplier,weapon_pool,0.35,{value}% shadow damage and damage over time,OnHit,0.6,shadow_dot,3,2,,,
shock_burst,damage_multiplier,multiplier,weapon_pool,0.3,{value}% lightning damage with chain,OnHit,0.5,shock_pulse,2,1,,,
poison,damage_multiplier,multiplier,jewelry_pool,0.2,{value}% poison damage over time,OnHit,0.5,apply_debuff:poison_dmg,8,3,,,
burn,damage_multiplier,multiplier,jewelry_pool,0.25,{value}% fire damage over time,OnHit,0.6,apply_debuff:burn_dmg,6,4,,,
echo_mark,damage_multiplier,flat,jewelry_pool,1,{value} effects can trigger on echo marked targets,OnHit,1,echo_mark,5,1,,,
frostbite,damage_multiplier,flat,jewelry_pool,1,{value} slow and cold damage effects on targets,OnHit,0.6,apply_debuff:frostbite,4,1,,,
stoneform,armor,flat,armor_pool,60,+{value} armor and damage reduction,, , , , , , ,
shock_pulse,base_damage,flat,armor_pool,0,Chance to release a shock pulse,OnHit,0.25,shock_pulse,5,1,,,
soul_burn,damage_multiplier,multiplier,jewelry_pool,0.2,Applies Soul Burn on hit,OnHit,1.0,soul_burn,10,5,,,
life_steal,life_steal,flat,jewelry_pool,0.05,+{value}% Life Steal,,,,,,,,
berserker_charge,base_damage,multiplier,weapon_pool,0.1,Chance to gain Rage on hit,OnHit,0.2,rage,6,1,,,


// =================================================================
// METADATA
// =================================================================
// File Path:      data\effects.csv
// Size:           3.21 KB
// Last Modified:  2025-11-18T20:21:05.869Z
// =================================================================

effect_id,name,type,description,max_stacks,tick_rate,damage_per_tick,stat_multiplier,stat_add,visual_effect,duration
bleed,Bleed,DoT,Deals physical damage over time.,10,1,8,0,0,red_blood_splt,10
freeze,Frozen,stun,"Frozen solid, preventing all movement and actions.",1,0,0,0,0,ice_crystals,4
burn,Burn,DoT,Deals Fire damage each second.,8,2,4,0,0,fire_burn,8
poison,Poison,DoT,Deals poison damage and reduces healing received,12,1.5,6,0,0,posion_cloud,12
shadow_dot,Shadow Corruption,DoT,Corrupting shadow energy that saps life.,15,2,12,0,0,dark_smoke,10
stun,Stunned,stun,"Stunned and incapacitated, unable to act.",1,0,0,0,0,yellow_stun_stars,3
crit_bonus_drain,Focused Rage,buff,Increased critical strike chance.,1,0,0,0,25,golden_buff_particles,5
evasion_penalty,Entropy Penalty,debuff,Reduced evasion after dodge (temporary).,1,0,0,0.1,0,gray_particles,2
crit_penalty_disadvantage,Blind Rebuke,debuff,Reduced critical strike chance after block.,1,0,0,0,-15,dark_buff_particles,3
divine_shield,Divine Protection,buff,Invulnerable to all damage.,1,0,0,1,0,golden_shield,5
movement_speed_buff,Reactive Step,buff,Increased movement speed.,1,0,0,0,0,speed_lines,5
lifesteal_buff,Vampiric Touch,buff,Life steal on attacks.,1,0,0,0,0,blood_trail,8
damage_amp_buff,Berserker Rage,buff,Increased damage output.,1,0,0,0.2,0,red_aura,10
heal_over_time_buff,Divine Blessing,buff,Heal over time.,5,2,-15,0,0,healing_particles,10
defense_buff,Divine Blessing,buff,Increased damage reduction.,5,0,0,0,500,protective_aura,10
chain_damage_buff,Chain Lightning,buff,Lightning damage jumps to nearby targets.,1,0,0,0.6,0,lightning_arcs,1
damage_reflection_buff,Thornmail,buff,Reflect percentage of blocked damage.,1,0,0,0,0,spike_aura,999
corrosion,Corrosion,DoT,Deals damage and reduces armor by 10 while active.,5,1.0,4,0,10,acid_mist,8
frostbite,Frostbite,Debuff,Slows target and deals minor cold damage.,3,1.0,3,0,0,frost_glow,6
shock_pulse,Shock Pulse,Debuff,Pulses small shock damage and reduces attack speed by 10%,3,1.0,4,0.9,0,lightning_arc,5
soul_burn,Soul Burn,DoT,Deals increasing damage each tick.,10,1.0,2,0,0,shadow_flare,10
cripple,Cripple,Debuff,Reduces attack power by 15.,1,0,0,0,15,bone_crack,6
vulnerability,Vulnerability,Debuff,Target takes 20% more damage.,1,0,0,1.2,0,mark_glow,6
weaken,Weaken,Debuff,Reduces outgoing damage by 12%. ,1,0,0,0.88,0,grey_swirl,6
focus,Focus,Buff,Increases critical chance by 15%. ,1,0,0,1.15,0,focus_glow,8
rage,Rage,Buff,Grants 20% increased damage but take 10% more.,1,0,0,1.2,0,rage_flare,6
stoneform,Stoneform,Buff,Increases armor by 50.,1,0,0,1.0,50,stone_shield,10
haste,Haste,Buff,Increases attack speed by 20%. ,1,0,0,1.2,0,wind_lines,6
echo_mark,Echo Mark,Special,Stores 30% of damage taken and releases it after expiry.,1,0,0,0,0,echo_glow,5
slow,Slow,Debuff,Reduces movement and attack speed.,1,0,0,0.7,0,ice_puddle,4
berserk,Berserk,Buff,Greatly increases damage but reduces armor.,1,0,0,1.5,-50,red_eyes,6
pulse,Pulse,Debuff,Periodic damage pulse.,1,1.0,5,0,0,pulse_wave,5
reflective_shield,Reflective Shield,Buff,Reflects damage.,1,0,0,0,0,mirror_shield,5
poison_dmg,Poison Damage,DoT,Pure poison damage.,5,1.0,5,0,0,green_drip,5
burn_dmg,Burn Damage,DoT,Pure fire damage.,5,1.0,5,0,0,fire_drip,5


// =================================================================
// METADATA
// =================================================================
// File Path:      data\game_data.json
// Size:           13.39 KB
// Last Modified:  2025-11-14T13:31:18.679Z
// =================================================================

{
  "affixes": {
    "flat_dmg": {
      "affix_id": "flat_dmg",
      "stat_affected": "base_damage",
      "mod_type": "flat",
      "affix_pools": [
        "weapon_pool",
        "axe_pool"
      ],
      "base_value": 50.0,
      "description": "+{value} Base Damage"
    },
    "crit_dmg": {
      "affix_id": "crit_dmg",
      "stat_affected": "crit_damage",
      "mod_type": "flat",
      "affix_pools": [
        "weapon_pool",
        "jewelry_pool"
      ],
      "base_value": 0.5,
      "description": "+{value}% Crit Damage"
    },
    "bleed_chance": {
      "affix_id": "bleed_chance",
      "stat_affected": "proc_rate_bleed",
      "mod_type": "flat",
      "affix_pools": [
        "axe_pool",
        "sword_pool"
      ],
      "base_value": 0.25,
      "description": "{value}% chance to Bleed"
    },
    "flat_armor": {
      "affix_id": "flat_armor",
      "stat_affected": "armor",
      "mod_type": "flat",
      "affix_pools": [
        "armor_pool"
      ],
      "base_value": 150.0,
      "description": "+{value} Armor"
    },
    "attack_speed": {
      "affix_id": "attack_speed",
      "stat_affected": "attack_speed",
      "mod_type": "multiplier",
      "affix_pools": [
        "weapon_pool"
      ],
      "base_value": 0.2,
      "description": "+{value}% Attack Speed"
    },
    "health": {
      "affix_id": "health",
      "stat_affected": "max_health",
      "mod_type": "flat",
      "affix_pools": [
        "armor_pool",
        "jewelry_pool"
      ],
      "base_value": 100.0,
      "description": "+{value} Health"
    },
    "crit_chance": {
      "affix_id": "crit_chance",
      "stat_affected": "crit_chance",
      "mod_type": "flat",
      "affix_pools": [
        "jewelry_pool"
      ],
      "base_value": 0.1,
      "description": "{value}% Critical Strike Chance"
    },
    "pierce_bonus": {
      "affix_id": "pierce_bonus",
      "stat_affected": "pierce_ratio",
      "mod_type": "flat",
      "affix_pools": [
        "weapon_pool"
      ],
      "base_value": 0.08,
      "description": "{value}% Pierce Ratio"
    },
    "resistance": {
      "affix_id": "resistance",
      "stat_affected": "resistances",
      "mod_type": "flat",
      "affix_pools": [
        "armor_pool"
      ],
      "base_value": 0.15,
      "description": "{value}% Elemental Resistances"
    }
  },
  "items": {
    "base_iron_axe": {
      "item_id": "base_iron_axe",
      "name": "Iron Axe",
      "slot": "Weapon",
      "rarity": "Rare",
      "affix_pools": [
        "weapon_pool",
        "axe_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 2
    },
    "base_gold_ring": {
      "item_id": "base_gold_ring",
      "name": "Gold Ring",
      "slot": "Ring",
      "rarity": "Legendary",
      "affix_pools": [
        "jewelry_pool"
      ],
      "implicit_affixes": [
        "crit_dmg"
      ],
      "num_random_affixes": 3
    },
    "base_leather_chest": {
      "item_id": "base_leather_chest",
      "name": "Leather Tunic",
      "slot": "Chest",
      "rarity": "Common",
      "affix_pools": [
        "armor_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 1
    },
    "base_steel_sword": {
      "item_id": "base_steel_sword",
      "name": "Steel Sword",
      "slot": "Weapon",
      "rarity": "Uncommon",
      "affix_pools": [
        "weapon_pool",
        "sword_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 2
    },
    "base_iron_helm": {
      "item_id": "base_iron_helm",
      "name": "Iron Helm",
      "slot": "Head",
      "rarity": "Epic",
      "affix_pools": [
        "armor_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 2
    },
    "base_leather_gloves": {
      "item_id": "base_leather_gloves",
      "name": "Leather Gloves",
      "slot": "Hands",
      "rarity": "Rare",
      "affix_pools": [
        "armor_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 1
    },
    "base_steel_boots": {
      "item_id": "base_steel_boots",
      "name": "Steel Boots",
      "slot": "Feet",
      "rarity": "Uncommon",
      "affix_pools": [
        "armor_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 1
    },
    "base_wooden_shield": {
      "item_id": "base_wooden_shield",
      "name": "Wooden Shield",
      "slot": "OffHand",
      "rarity": "Common",
      "affix_pools": [
        "armor_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 1
    },
    "base_silver_amulet": {
      "item_id": "base_silver_amulet",
      "name": "Silver Amulet",
      "slot": "Amulet",
      "rarity": "Mythic",
      "affix_pools": [
        "jewelry_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 3
    },
    "base_leather_belt": {
      "item_id": "base_leather_belt",
      "name": "Leather Belt",
      "slot": "Belt",
      "rarity": "Epic",
      "affix_pools": [
        "armor_pool",
        "jewelry_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 2
    },
    "base_plate_shoulders": {
      "item_id": "base_plate_shoulders",
      "name": "Plate Shoulders",
      "slot": "Shoulders",
      "rarity": "Rare",
      "affix_pools": [
        "armor_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 2
    },
    "base_cloth_pants": {
      "item_id": "base_cloth_pants",
      "name": "Cloth Pants",
      "slot": "Pants",
      "rarity": "Uncommon",
      "affix_pools": [
        "armor_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 1
    },
    "base_onyx_ring": {
      "item_id": "base_onyx_ring",
      "name": "Onyx Ring",
      "slot": "Ring",
      "rarity": "Mythic",
      "affix_pools": [
        "jewelry_pool"
      ],
      "implicit_affixes": [],
      "num_random_affixes": 3
    },
    "base_dragon_scale": {
      "item_id": "base_dragon_scale",
      "name": "Demon Scale",
      "slot": "Chest",
      "rarity": "Epic",
      "affix_pools": [
        "armor_pool",
        "jewelry_pool"
      ],
      "implicit_affixes": [
        "resistance"
      ],
      "num_random_affixes": 3
    },
    "base_mystic_staff": {
      "item_id": "base_mystic_staff",
      "name": "Mystic Staff",
      "slot": "Weapon",
      "rarity": "Legendary",
      "affix_pools": [
        "jewelry_pool",
        "weapon_pool"
      ],
      "implicit_affixes": [
        "attack_speed"
      ],
      "num_random_affixes": 3
    },
    "base_ancient_sword": {
      "item_id": "base_ancient_sword",
      "name": "Ancient Sword",
      "slot": "Weapon",
      "rarity": "Mythic",
      "affix_pools": [
        "weapon_pool",
        "sword_pool"
      ],
      "implicit_affixes": [
        "flat_dmg"
      ],
      "num_random_affixes": 3
    },
    "base_fire_staff": {
      "item_id": "base_fire_staff",
      "name": "Fire Staff",
      "slot": "Weapon",
      "rarity": "Epic",
      "affix_pools": [
        "jewelry_pool",
        "weapon_pool"
      ],
      "implicit_affixes": [
        "attack_speed"
      ],
      "num_random_affixes": 2
    }
  },
  "quality_tiers": [
    {
      "quality_id": 1,
      "tier_name": "Awful",
      "min_range": 0,
      "max_range": 5,
      "Normal": 35,
      "Common": 15,
      "Unusual": 5,
      "Uncommon": 0,
      "Rare": 0,
      "Exotic": 0,
      "Epic": 0,
      "Glorious": 0,
      "Exalted": 0,
      "Legendary": 0,
      "Mythic": 0,
      "Godly": 0
    },
    {
      "quality_id": 2,
      "tier_name": "Dull",
      "min_range": 6,
      "max_range": 10,
      "Normal": 30,
      "Common": 20,
      "Unusual": 10,
      "Uncommon": 5,
      "Rare": 0,
      "Exotic": 0,
      "Epic": 0,
      "Glorious": 0,
      "Exalted": 0,
      "Legendary": 0,
      "Mythic": 0,
      "Godly": 0
    },
    {
      "quality_id": 3,
      "tier_name": "Mundane",
      "min_range": 11,
      "max_range": 15,
      "Normal": 40,
      "Common": 30,
      "Unusual": 20,
      "Uncommon": 10,
      "Rare": 5,
      "Exotic": 0,
      "Epic": 0,
      "Glorious": 0,
      "Exalted": 0,
      "Legendary": 0,
      "Mythic": 0,
      "Godly": 0
    },
    {
      "quality_id": 4,
      "tier_name": "Decent",
      "min_range": 16,
      "max_range": 20,
      "Normal": 30,
      "Common": 40,
      "Unusual": 30,
      "Uncommon": 20,
      "Rare": 10,
      "Exotic": 5,
      "Epic": 0,
      "Glorious": 0,
      "Exalted": 0,
      "Legendary": 0,
      "Mythic": 0,
      "Godly": 0
    },
    {
      "quality_id": 5,
      "tier_name": "Fine",
      "min_range": 21,
      "max_range": 25,
      "Normal": 20,
      "Common": 30,
      "Unusual": 40,
      "Uncommon": 30,
      "Rare": 20,
      "Exotic": 10,
      "Epic": 0,
      "Glorious": 0,
      "Exalted": 0,
      "Legendary": 0,
      "Mythic": 0,
      "Godly": 0
    },
    {
      "quality_id": 6,
      "tier_name": "Good",
      "min_range": 26,
      "max_range": 30,
      "Normal": 10,
      "Common": 20,
      "Unusual": 30,
      "Uncommon": 40,
      "Rare": 30,
      "Exotic": 20,
      "Epic": 5,
      "Glorious": 0,
      "Exalted": 0,
      "Legendary": 0,
      "Mythic": 0,
      "Godly": 0
    },
    {
      "quality_id": 7,
      "tier_name": "Great",
      "min_range": 31,
      "max_range": 35,
      "Normal": 5,
      "Common": 10,
      "Unusual": 20,
      "Uncommon": 30,
      "Rare": 40,
      "Exotic": 30,
      "Epic": 10,
      "Glorious": 5,
      "Exalted": 0,
      "Legendary": 0,
      "Mythic": 0,
      "Godly": 0
    },
    {
      "quality_id": 8,
      "tier_name": "Excellent",
      "min_range": 36,
      "max_range": 40,
      "Normal": 0,
      "Common": 5,
      "Unusual": 10,
      "Uncommon": 20,
      "Rare": 30,
      "Exotic": 40,
      "Epic": 20,
      "Glorious": 10,
      "Exalted": 5,
      "Legendary": 0,
      "Mythic": 0,
      "Godly": 0
    },
    {
      "quality_id": 9,
      "tier_name": "Superior",
      "min_range": 41,
      "max_range": 45,
      "Normal": 0,
      "Common": 0,
      "Unusual": 5,
      "Uncommon": 10,
      "Rare": 20,
      "Exotic": 30,
      "Epic": 30,
      "Glorious": 20,
      "Exalted": 10,
      "Legendary": 5,
      "Mythic": 0,
      "Godly": 0
    },
    {
      "quality_id": 10,
      "tier_name": "Powerful",
      "min_range": 46,
      "max_range": 50,
      "Normal": 0,
      "Common": 0,
      "Unusual": 0,
      "Uncommon": 5,
      "Rare": 10,
      "Exotic": 20,
      "Epic": 40,
      "Glorious": 30,
      "Exalted": 20,
      "Legendary": 10,
      "Mythic": 5,
      "Godly": 0
    },
    {
      "quality_id": 11,
      "tier_name": "Remarkable",
      "min_range": 51,
      "max_range": 55,
      "Normal": 0,
      "Common": 0,
      "Unusual": 0,
      "Uncommon": 0,
      "Rare": 5,
      "Exotic": 10,
      "Epic": 30,
      "Glorious": 40,
      "Exalted": 30,
      "Legendary": 20,
      "Mythic": 10,
      "Godly": 5
    },
    {
      "quality_id": 12,
      "tier_name": "Extraordinary",
      "min_range": 56,
      "max_range": 60,
      "Normal": 0,
      "Common": 0,
      "Unusual": 0,
      "Uncommon": 0,
      "Rare": 0,
      "Exotic": 5,
      "Epic": 20,
      "Glorious": 30,
      "Exalted": 40,
      "Legendary": 30,
      "Mythic": 20,
      "Godly": 10
    },
    {
      "quality_id": 13,
      "tier_name": "Exceptional",
      "min_range": 61,
      "max_range": 65,
      "Normal": 0,
      "Common": 0,
      "Unusual": 0,
      "Uncommon": 0,
      "Rare": 0,
      "Exotic": 0,
      "Epic": 10,
      "Glorious": 20,
      "Exalted": 30,
      "Legendary": 40,
      "Mythic": 30,
      "Godly": 20
    },
    {
      "quality_id": 14,
      "tier_name": "Magnificent",
      "min_range": 66,
      "max_range": 70,
      "Normal": 0,
      "Common": 0,
      "Unusual": 0,
      "Uncommon": 0,
      "Rare": 0,
      "Exotic": 0,
      "Epic": 5,
      "Glorious": 10,
      "Exalted": 20,
      "Legendary": 30,
      "Mythic": 40,
      "Godly": 30
    },
    {
      "quality_id": 15,
      "tier_name": "Brilliant",
      "min_range": 71,
      "max_range": 75,
      "Normal": 0,
      "Common": 0,
      "Unusual": 0,
      "Uncommon": 0,
      "Rare": 0,
      "Exotic": 0,
      "Epic": 0,
      "Glorious": 5,
      "Exalted": 10,
      "Legendary": 20,
      "Mythic": 30,
      "Godly": 40
    },
    {
      "quality_id": 16,
      "tier_name": "Masterful",
      "min_range": 76,
      "max_range": 85,
      "Normal": 0,
      "Common": 0,
      "Unusual": 0,
      "Uncommon": 0,
      "Rare": 0,
      "Exotic": 0,
      "Epic": 0,
      "Glorious": 0,
      "Exalted": 5,
      "Legendary": 10,
      "Mythic": 20,
      "Godly": 30
    },
    {
      "quality_id": 17,
      "tier_name": "Perfect",
      "min_range": 91,
      "max_range": 100,
      "Normal": 0,
      "Common": 0,
      "Unusual": 0,
      "Uncommon": 0,
      "Rare": 0,
      "Exotic": 0,
      "Epic": 0,
      "Glorious": 0,
      "Exalted": 0,
      "Legendary": 5,
      "Mythic": 15,
      "Godly": 35
    }
  ]
}


// =================================================================
// METADATA
// =================================================================
// File Path:      data\items.csv
// Size:           4.76 KB
// Last Modified:  2025-11-18T20:27:12.266Z
// =================================================================

item_id,name,slot,rarity,affix_pools,implicit_affixes,num_random_affixes
base_iron_axe,Iron Axe,Weapon,Rare,weapon_pool|axe_pool,,2
base_gold_ring,Gold Ring,Ring,Legendary,jewelry_pool,crit_dmg,3
base_leather_chest,Leather Tunic,Chest,Common,armor_pool,,1
base_steel_sword,Steel Sword,Weapon,Uncommon,weapon_pool|sword_pool,,2
base_iron_helm,Iron Helm,Head,Epic,armor_pool,,2
base_leather_gloves,Leather Gloves,Hands,Rare,armor_pool,,1
base_steel_boots,Steel Boots,Feet,Uncommon,armor_pool,,1
base_wooden_shield,Wooden Shield,OffHand,Common,armor_pool,,1
base_silver_amulet,Silver Amulet,Amulet,Mythic,jewelry_pool,,3
base_leather_belt,Leather Belt,Belt,Epic,armor_pool|jewelry_pool,,2
base_plate_shoulders,Plate Shoulders,Shoulders,Rare,armor_pool,,2
base_cloth_pants,Cloth Pants,Pants,Uncommon,armor_pool,,1
base_onyx_ring,Onyx Ring,Ring,Mythic,jewelry_pool,,3
base_dragon_scale,Demon Scale,Chest,Epic,armor_pool|jewelry_pool,resistance,3
base_mystic_staff,Mystic Staff,Weapon,Legendary,jewelry_pool|weapon_pool,attack_speed,3
base_ancient_sword,Ancient Sword,Weapon,Mythic,weapon_pool|sword_pool,flat_dmg,3
base_fire_staff,Fire Staff,Weapon,Epic,jewelry_pool|weapon_pool,attack_speed,2
sword_vorpal,Vorpal Longsword,Weapon,Rare,weapon_pool|sword_pool,flat_dmg;hollow_point,2
amulet_siphon,Siphon Amulet,Jewelry,Uncommon,jewelry_pool,siphon_strikes,1
shield_mimic,Mimic Aegis,Shield,Rare,shield_pool,mimic_shield,1
dagger_echo,Echo Dagger,Weapon,Magic,dagger_pool,echoing_blow,2
armor_adamant,Adamant Plate,Armor,Uncommon,armor_pool,flat_armor,1
ring_focused,Focused Band,Jewelry,Magic,jewelry_pool,focused_rage,1
bow_precision,Precision Bow,Weapon,Mythic,weapon_pool|bow_pool,precision_power,2
staff_venom,Venom Staff,Weapon,Rare,weapon_pool|staff_pool,venomous_edge,2
cape_pulse,Pulsing Cape,Cloak,Uncommon,armor_pool,pulsing_core,1
reaper_greave,Reaper Greaves,Legs,Rare,armor_pool,berserker_rage,1
mirror_shield_item,Mirror Shield,Shield,Legendary,shield_pool,retribution;mirror_shield,0
amulet_lifebind,Lifebind Pendant,Jewelry,Magic,jewelry_pool,lifebind,1
serpent_dagger,Serpent Dagger,Weapon,Uncommon,weapon_pool|dagger_pool,poison_stab,1
embers_edge,Ember's Edge,Weapon,Rare,weapon_pool|sword_pool,flame_arc,2
glacial_spear,Glacial Spear,Weapon,Uncommon,weapon_pool|spear_pool,glacial_spike,1
echo_blade,Echo Blade,Weapon,Rare,weapon_pool|sword_pool,echo_strike,1
stormcaller_staff,Stormcaller Staff,Weapon,Epic,weapon_pool|staff_pool,shock_burst,2
reaper_scythe,Reaper Scythe,Weapon,Epic,weapon_pool|scythe_pool,shadow_slash,2
berserker_helm,Berserker Helm,Helmet,Rare,armor_pool,berserker_rage,1
stoneform_plate,Stoneform Plate,Armor,Epic,armor_pool,stoneform,1
hastewrap,Cloak of Haste,Cloak,Uncommon,armor_pool,rallying_cry,1
verdant_band,Verdant Band,Jewelry,Uncommon,jewelry_pool,poison,1
igneous_heart,Igneous Heart,Jewelry,Epic,jewelry_pool,burn,1
echoing_pendant,Echoing Pendant,Jewelry,Rare,jewelry_pool,echo_mark,1
glacial_ring,Ring of Frostbite,Jewelry,Magic,jewelry_pool,frostbite,1
storm_bracers,Storm Bracers,Gloves,Rare,armor_pool,shock_pulse,1
corrosion_gauntlets,Corrosion Gauntlets,Gloves,Uncommon,armor_pool,corrosion,1
spear_starter,Serrated Spear,Weapon,Common,weapon_pool|spear_pool,,1
iron_shield,Iron Buckler,Shield,Common,shield_pool,,1
cloth_cowl,Cloth Cowl,Helmet,Common,armor_pool,,1
traveller_robe,Traveller Robe,Armor,Common,armor_pool,,1
simple_ring,Simple Ring,Ring,Common,jewelry_pool,,1
ember_shiv,Ember Shiv,Weapon,Magic,weapon_pool|dagger_pool,burn,1
stone_guard_plate,Stone Guard Plate,Armor,Rare,armor_pool,stoneform,1
precision_bow,Precision Bow,Weapon,Rare,weapon_pool|bow_pool,precision_power,2
berserker_greatsword,Berserker Greatsword,Weapon,Legendary,weapon_pool,berserker_charge,0
void_circlet,Void Circlet,Helmet,Legendary,jewelry_pool,soul_burn,1
echo_pride_cape,Echoing Pride,Cloak,Magic,armor_pool,echoing_blow,1
lifebind_pendant,Lifebind Pendant,Jewelry,Magic,jewelry_pool,lifebind,1
seraphic_plate,Seraphic Plate,Armor,Mythic,armor_pool,health;resistance,2
storm_quiver,Storm Quiver,Quiver,Rare,weapon_pool,shock_pulse,1
feral_gloves,Feral Gloves,Gloves,Magic,armor_pool,attack_speed,1
vampiric_band,Vampiric Band,Ring,Magic,jewelry_pool,life_steal,1
hunter_boots,Hunter Boots,Boots,Uncommon,armor_pool,attack_speed,1
arcane_tome,Arcane Tome,Offhand,Magic,jewelry_pool,crit_chance,1
runed_amulet,Runed Amulet,Jewelry,Rare,jewelry_pool,devastating_strikes,1
cinder_core,Cinder Core,Accessory,Epic,jewelry_pool,burning_fury,1
gale_mask,Gale Mask,Helmet,Uncommon,armor_pool,wind_steps,1
spinebreaker,Spinebreaker,Weapon,Rare,weapon_pool,vorpal_edge,1
frostbrand,Frostbrand,Weapon,Epic,weapon_pool,frostbite,2
corruptor_staff,Corruptor Staff,Weapon,Mythic,weapon_pool,corrosion,2
glimmer_shield,Glimmer Shield,Shield,Magic,shield_pool,reforged_plate,1


// =================================================================
// METADATA
// =================================================================
// File Path:      data\quality_tiers.csv
// Size:           0.80 KB
// Last Modified:  2025-11-14T12:57:02.486Z
// =================================================================

quality_id,tier_name,min_range,max_range,Normal,Common,Unusual,Uncommon,Rare,Exotic,Epic,Glorious,Exalted,Legendary,Mythic,Godly
1,Awful,0,5,35,15,5,,,,,,,,,
2,Dull,6,10,30,20,10,5,,,,,,,,
3,Mundane,11,15,40,30,20,10,5,,,,,,,
4,Decent,16,20,30,40,30,20,10,5,,,,,,
5,Fine,21,25,20,30,40,30,20,10,,,,,,
6,Good,26,30,10,20,30,40,30,20,5,,,,,
7,Great,31,35,5,10,20,30,40,30,10,5,,,,
8,Excellent,36,40,,5,10,20,30,40,20,10,5,,,
9,Superior,41,45,,,5,10,20,30,30,20,10,5,,
10,Powerful,46,50,,,,5,10,20,40,30,20,10,5,
11,Remarkable,51,55,,,,,5,10,30,40,30,20,10,5
12,Extraordinary,56,60,,,,,,5,20,30,40,30,20,10
13,Exceptional,61,65,,,,,,,10,20,30,40,30,20
14,Magnificent,66,70,,,,,,,5,10,20,30,40,30
15,Brilliant,71,75,,,,,,,,5,10,20,30,40
16,Masterful,76,85,,,,,,,,,5,10,20,30
17,Perfect,91,100,,,,,,,,,,5,15,35



// =================================================================
// METADATA
// =================================================================
// File Path:      data\skills.csv
// Size:           3.20 KB
// Last Modified:  2025-11-18T20:31:11.977Z
// =================================================================

skill_id,name,damage_type,hits,description,resource_cost,cooldown,trigger_event,proc_rate,trigger_result,trigger_duration,stacks_max
basic_slash,Basic Slash,Physical,1,Basic physical attack that deals moderate damage.,0,1.0,,0.0,,0.0,0
bleed_strike,Bleed Strike,Physical,1,Slash that causes bleeding DoT on critical hits.,15,3.0,OnCrit,0.8,bleed,8.0,3
focused_strike,Focused Strike,Physical,1,Charge up for 100% crit chance but 50% damage.,20,5.0,OnHit,1.0,self_damage:0.5,0.0,0
rapid_fire,Rapid Fire,Physical,3,Burst of three quick attacks.,25,4.0,,0.0,,0.0,0
chain_lightning,Chain Lightning,Magic,1,Lightning that jumps to nearby enemies.,30,6.0,OnHit,1.0,chain_damage:0.6,0.0,0
frost_nova,Frost Nova,Magic,1,Ice explosion that freezes enemies in area.,35,8.0,OnHit,0.9,freeze,3.0,1
berserker_rage,Berserker Rage,Physical,1,Powerful rage-fueled attack with lifesteal.,40,7.0,OnHit,1.0,heal_self:0.2,0.0,0
shadow_bolt,Shadow Bolt,Shadow,1,A dark bolt that deals shadow damage over time.,25,3.0,OnHit,0.7,shadow_dot,10.0,5
holy_shield,Holy Shield,Divine,1,Divine protection that blocks all damage for 3 seconds.,50,12.0,OnSkillUsed,1.0,divine_shield,3.0,1
venom_strike,Venom Strike,Physical,1,Poisonous strike that spreads venom on crit.,20,4.0,OnCrit,0.6,poison,12.0,4
whirlwind,Whirlwind,Physical,5,Cleave all nearby enemies with spinning attack.,45,9.0,,0.0,,0.0,0
teleport_strike,Teleport Strike,Physical,1,Teleport behind enemy for guaranteed hit.,30,5.0,OnHit,1.0,stun,2.0,1
flame_burst,Flame Burst,Fire,1,Explosive fire damage that burns enemies.,25,4.0,OnHit,0.8,burn,6.0,3
thunder_clap,Thunder Clap,Magic,1,Shockwave that stuns multiple targets.,35,7.0,OnHit,0.9,stun,1.5,1
vampiric_touch,Vampiric Touch,Shadow,1,Drain life from enemy over time.,40,8.0,OnHit,1.0,drain_life:0.05,8.0,1
divine_blessing,Divine Blessing,Divine,1,Grant protection and healing to allies.,60,15.0,OnSkillUsed,1.0,bless_allies:0.3,10.0,1
whirlwind_strike,Whirlwind Strike,Physical,3,Spin attack hitting all nearby enemies.,20,6.0,OnHit,0.35,bleed,6,3
focus_shot,Focus Shot,piercing,1,Well-aimed shot that deals high damage.,15,4.0,OnCrit,1.0,focus,8,1
shadow_slash,Shadow Slash,Shadow,2,A quick two-hit shadow strike.,10,3.0,OnHit,0.25,soul_burn,10,5
poison_stab,Poison Stab,Poison,1,A precise stab that poisons the target.,8,2.5,OnHit,0.40,poison,6,5
flame_arc,Flame Arc,Fire,1,A wide fire arc that scorches all enemies in front.,18,5.0,OnHit,0.30,burn,5,3
glacial_spike,Glacial Spike,Cold,1,Launch a frozen spike that slows enemies.,16,4.0,OnHit,0.25,frostbite,6,3
corrosive_wave,Corrosive Wave,acid,1,Unleashes a wave of acid that corrodes armor.,22,8.0,OnHit,0.35,corrosion,8,5
echo_strike,Echo Strike,Physical,1,A heavy blow that leaves the target marked for echo burst.,20,10.0,OnHit,0.50,echo_mark,5,1
rallying_cry,Rallying Cry,Light,0,A powerful shout empowering the caster.,0,12.0,OnUse,1.0,haste,6,1
stone_guard,Stone Guard,earth,0,Reinforce yourself with protective stone.,0,14.0,OnUse,1.0,stoneform,10,1
berserker_charge,Berserker Charge,Physical,1,A furious charge that empowers further attacks.,25,16.0,OnHit,1.0,rage,6,1
shock_burst,Shock Burst,Lightning,1,High-voltage burst that destabilizes and shocks enemies.,18,7.0,OnHit,0.30,shock_pulse,5,3



// =================================================================
// METADATA
// =================================================================
// File Path:      demo_item.py
// Size:           2.19 KB
// Last Modified:  2025-11-17T19:52:06.972Z
// =================================================================

#!/usr/bin/env python3
"""Demo script to generate and display a random procedural item."""

import json
import random
import logging

logging.basicConfig(level=logging.INFO, format='%(message)s')

from src.item_generator import ItemGenerator


def main():
    """Generate and display a random item."""
    try:
        # Load game data
        with open('data/game_data.json', 'r', encoding='utf-8') as f:
            game_data = json.load(f)

        # Initialize generator
        item_gen = ItemGenerator(game_data)

        # Get available base items
        base_items = list(game_data['items'].keys())

        # Pick a random base item
        base_id = random.choice(base_items)

        # Generate the item
        item = item_gen.generate(base_id)

        # Print item details
        print("=" * 50)
        print(f"ðŸŽ² RANDOM ITEM GENERATED ðŸŽ²")
        print("=" * 50)
        print(f"Name: {item.name}")
        print(f"Rarity: {item.rarity}")
        print(f"Quality: {item.quality_tier}")
        print(f"Quality Roll: {item.quality_roll}")
        print(f"Slot: {item.slot}")
        print(f"Instance ID: {item.instance_id}")
        print(f"Base ID: {item.base_id}")
        print()
        print("Affixes:")
        for i, affix in enumerate(item.affixes, 1):
            # Format percentage values for display (stats that are multipliers shown as %)
            display_value = affix.value
            percentage_stats = {'crit_damage', 'resistances', 'pierce_ratio', 'crit_chance'}
            if affix.stat_affected in percentage_stats and '%' in affix.description:
                display_value = affix.value * 100  # 0.315 â†’ 31.5

            description = affix.description.replace('{value}', str(display_value))
            print(f"  {i}. {description}")
            print(f"     (Base: {affix.base_value}, Rolled: {affix.value}, Type: {affix.mod_type})")
        print("=" * 50)
        print(f"Total affixes: {len(item.affixes)}")

    except FileNotFoundError:
        print("Error: data/game_data.json not found. Run src/data_parser.py first.")
    except Exception as e:
        print(f"Error: {e}")


if __name__ == "__main__":
    main()



// =================================================================
// METADATA
// =================================================================
// File Path:      docs\Combat_Engine_Architecture.md
// Size:           8.67 KB
// Last Modified:  2025-11-14T15:52:32.967Z
// =================================================================

# Combat Engine Architecture

*Generated post-Code Review Implementation - Production-Ready Architecture v0.7.0*

## Core Architecture Diagram

```mermaid
graph TB
    subgraph "ðŸŽ¯ Production Engine (v0.7.0)"
        subgraph "ðŸ“± Action/Result Pattern - Core Execution"
            SR[SkillUseResult] -->|Contains| DA[ApplyDamageAction]
            SR -->|Contains| EA[DispatchEventAction]
            SR -->|Contains| AE[ApplyEffectAction]
            CE[CombatEngine<br/>calculate_skill_use()<br/>PURE FUNCTION] -->|Returns| SR
            CO[CombatOrchestrator<br/>execute_skill_use()<br/>DEPENDENCY INJECTION] -->|Executes| DA
            CO -->|Executes| EA
            CO -->|Executes| AE
        end

        subgraph "ðŸ—ï¸ Singleton Data Layer"
            GDP[GameDataProvider<br/>SINGLETON<br/>Centralized Access]
            GDP -->|Loads| GD[game_data.json]
            GDP -->|Provides| AD[affixes]
            GDP -->|Provides| ID[items]
            GDP -->|Provides| QT[quality_tiers]
            IG[ItemGenerator] -->|Uses| GDP
            IG -->|Creates| ITEM[Item<br/>with RolledAffix]
        end

        subgraph "âš¡ Generic Effect Framework"
            DOHC[DamageOnHitConfig<br/>DATA-DRIVEN] -->|Configures| DOHH[DamageOnHitHandler<br/>TEMPLATE METHOD]
            DOHC -->|Debuff Name| DN["'Burn', 'Bleed', etc."]
            DOHC -->|Proc Rate| PR["0.33, 0.5, etc."]
            DOHC -->|Duration| DR["3.0, 5.0, 8.0"]
            DOHC -->|Damage/Tick| DT["1.5, 2.5, 3.0"]
            DOHC -->|Custom Message| CM["'Burn proc'd on {target}!', etc."]
        end

        subgraph "ðŸ›ï¸ Core Data Models"
            ES[EntityStats<br/>STATIC STATS<br/>Validation] -->|Used by| E[Entity<br/>CALCULATE_FINAL_STATS()]
            E -->|Equip| ITEM
            E -->|Validate| SV[Stat Validation<br/>in calculate_final_stats()]
            SV -->|Warns on| IV[Invalid Stat Names]
            SV -->|Allows| VS[Valid Stat References]
        end
    end

    subgraph "ðŸ”„ Event-Driven Communication"
        EB[EventBus<br/>OBSERVER PATTERN] -->|Pub/Sub| OH[OnHitEvent]
        EB -->|Pub/Sub| OC[OnCritEvent]
        EB -->|Pub/Sub| TE[Tick Events, etc.]
        DOHH -->|Publishes| OH
        CO -->|Dispatches| TE
    end

    subgraph "ðŸ§ª Comprehensive Testing"
        TU[Test Fixtures<br/>make_entity(), make_rng()] -->|Provide| DTU[Deterministic Testing]
        ATU[129 Unit Tests<br/>100% Pass Rate] -->|Validate| PAT[Action/Result Pattern]
        ATU -->|Validate| GTP[GameDataProvider]
        ATU -->|Validate| GEF[Generic Effect Framework]
        ATU -->|Validate| SVL[Stat Validation]
    end

    subgraph "ðŸŽ® Integration Points"
        E -->|Used by| CE
        CE -->|Queries| E
        DOHH -->|Registers with| EB
        CO -->|Injects| SM[StateManager]
        CO -->|Injects| EB
        ITEM -->|Provides stats to| E
    end

    subgraph "ðŸš€ Godot Port Ready"
        SR --> GSR[GDScript Signals<br/>Direct Translation]
        CO --> GDI[GDScript Nodes<br/>Scene Injection]
        GDP --> GRD[GDScript Resources<br/>JSON Loading]
        PAT --> GSP[GDScript Signal Patterns<br/>Native Compatibility]
    end

    CE -.->|ZERO SIDE EFFECTS| CO
    CE -.->|PURE CALCULATION| SR
    CO -.->|DEPENDENCY INJECTION| SM
    CO -.->|DEPENDENCY INJECTION| EB
    GDP -.->|SINGLETON ACCESS| IG
    IG -.->|LEGACY COMPATIBLE| LC[Old ItemGenerator<br/>Direct JSON]
    DOHC -.->|CONFIG CREATE| CHF[Helper Functions<br/>create_bleed_handler()]

    style CE fill:#4CAF50,color:#fff
    style CO fill:#2196F3,color:#fff
    style GDP fill:#FF9800,color:#fff
    style DOHC fill:#9C27B0,color:#fff
    style SV fill:#F44336,color:#fff
```

## Data Flow Architecture

```mermaid
flowchart LR
    subgraph "ðŸŽ¯ User Input"
        UI[Player Action<br/>Skill Use, Target]
    end

    subgraph "ðŸ’» Calculation Phase<br/>PURE FUNCTIONS"
        CEP[CombatEngine<br/>calculate_skill_use]
        CEP --> SR[SkillUseResult<br/>HIT_RESULTS + ACTIONS]
        SR --> HR[hit_contexts<br/>calculated damage]
        SR --> AC[action_queue<br/>execution commands]
    end

    subgraph "âš™ï¸ Execution Phase<br/>DEPENDENCY INJECTION"
        CO[CombatOrchestrator<br/>execute_skill_use]
        CO --> DMEM[ApplyDamageAction<br/>StateManager.apply_damage]
        CO --> DEVT[DispatchEventAction<br/>EventBus.dispatch]
        CO --> DEFCT[ApplyEffectAction<br/>Optional future expansion]
    end

    subgraph "ðŸŒ External Systems"
        SM[StateManager<br/>Health, Debuffs, Status]
        EB[EventBus<br/>Event Distribution]
        EFFH[EffectHandlers<br/>Subscribed Listeners]
    end

    UI --> CEP
    CEP --> CO
    CO --> SM
    CO --> EB
    EB --> EFFH

    style CEP fill:#4CAF50,color:#000
    style CO fill:#2196F3,color:#000
    style SM fill:#FF9800,color:#000
    style EB fill:#9C27B0,color:#000
```

## Effect System Extensibility

```mermaid
graph LR
    subgraph "ðŸŽ® Developer Experience"
        DEV[Game Designer<br/>Add New Effect]
        DEV --> CSV["Create CSV Entry:<br/>burn_effect, Burn, 0.25, 6.0, 3.0, 1, 'Burn proc!"]
        CSV --> PIPE[Data Pipeline<br/>data_parser.py]
        PIPE --> CONF[DamageOnHitConfig<br/>'Burn' Configuration]
        CONF --> HAN[DamageOnHitHandler<br/>Configurable Handler]
        HAN --> REG[Register with EventBus]
    end

    subgraph "ðŸŽ² Runtime Behavior"
        ACT[Combat Action<br/>Fire Skill/Attack]
        REG --> ACT
        ACT --> PROC{"RNG < 0.25<br/>Burn Proc?"}
        PROC -->|No| SKIP[No Effect]
        PROC -->|Yes| APPLY[Apply 3.0 DoT/6sec<br/>Message: 'Burn proc!']
    end

    style DEV fill:#4CAF50,color:#fff
    style PROC fill:#FF9800,color:#000
```

## Testing Architecture Coverage

```mermaid
graph TB
    subgraph "ðŸ§ª Unit Testing Layers"
        subgraph "Action Pattern Tests"
            ACTEST[Action Creation Tests<br/>ApplyDamageAction, etc.]
            SRTEST[SkillUseResult Tests<br/>Structure Validation]
            CETEST[CombatEngine Tests<br/>Pure Function Validation]
            COTEST[CombatOrchestrator Tests<br/>Execution Validation]
        end

        subgraph "Data Provider Tests"
            GDPTEST[Singleton Tests<br/>Instance Management]
            LOADTEST[Loading Tests<br/>JSON Parsing, Error Handling]
            RETEST[Reload Tests<br/>Runtime Data Updates]
        end

        subgraph "Effect Framework Tests"
            CONTEST[Config Tests<br/>DamageOnHitConfig Validation]
            GENTEST[Generic Handler Tests<br/>DamageOnHitHandler Logic]
            DATATEST[Data Creation Tests<br/>create_bleed_handler(), etc.]
        end

        subgraph "Integration Tests"
            STATTEST[Stat Validation Tests<br/>calculate_final_stats()]
            ENTTEST[Entity Tests<br/>Equipment & Validation]
            INTTEST[Integration Tests<br/>End-to-End Workflows]
        end
    end

    subgraph "ðŸ“Š Test Results"
        CTR[129 Tests<br/>100% Pass Rate]
        COV[Complete Coverage<br/>All New Architecture]
        DET[Deterministic<br/>RNG Injection]
    end

    ACTEST --> CTR
    SRTEST --> CTR
    CETEST --> CTR
    COTEST --> CTR
    GDPTEST --> CTR
    LOADTEST --> CTR
    RETEST --> CTR
    CONTEST --> CTR
    GENTEST --> CTR
    DATATEST --> CTR
    STATTEST --> CTR
    ENTTEST --> CTR
    INTTEST --> CTR

    CTR --> COV
    CTR --> DET
```

## Key Architectural Improvements (Pre/Post Code Review)

| **Aspect** | **Before (Prototype)** | **After (Production v0.7.0)** |
|------------|-------------------------|--------------------------------|
| **Calculation** | Mixed with execution | Pure functions (zero side effects) |
| **Execution** | Direct state mutations | Dependency-injected orchestrator |
| **Effects** | Hardcoded classes | Generic configurable framework |
| **Data Access** | Scattered file operations | Centralized singleton provider |
| **Validation** | Basic bounds checking | Comprehensive stat name validation |
| **Testing** | 96 tests | 129 tests with action validation |
| **Godot Ready** | Signal pattern concepts | Direct Action/Signal translation |

## Performance Characteristics

```mermaid
xychart-beta
    title "System Performance (v0.7.0)"
    x-axis ["Standard", "Crit Path", "Effect Calc", "Data Load", "Stat Valid"]
    y-axis "Execution Time (ms)" 0 --> 1
    bar [0.15, 0.22, 0.18, 0.03, 0.08]
    line [0.15, 0.22, 0.18, 0.03, 0.08]
```

*All operations maintain sub-millisecond performance, suitable for real-time combat systems.*

---

**Generated**: November 14, 2025
**Version**: Combat Engine v0.7.0
**Architecture**: Production-Ready with Action/Result Pattern



// =================================================================
// METADATA
// =================================================================
// File Path:      docs\PR-P1S1.md
// Size:           6.81 KB
// Last Modified:  2025-11-17T19:39:16.417Z
// =================================================================

### **PR-P1S1: System-Wide Logging Implementation and API Test Hardening**

## Overview

This PR executes the first step of the Foundational Stability phase. It completely removes all `print()` calls from the core library (`src/`) and replaces them with a structured, production-safe `logging` framework. This is a critical prerequisite for making the engine testable, debuggable, and deployable.

Additionally, this PR addresses a gap from a previous refactoring by adding a crucial unit test to validate the `CombatEngine.resolve_hit` API guard, ensuring its stability.

---

# âœ… Summary

**Goal:**
1.  Eradicate all `print()` calls from core engine, handler, and simulation logic.
2.  Establish the `logging` module as the standard for all application output.
3.  Add the missing unit test to confirm `resolve_hit` fails without a `StateManager`.

**Why this is a foundational change:**
*   `print()` is unsuitable for a production library as it cannot be configured, filtered, or redirected easily.
*   Tests that rely on capturing `print` output are brittle and hard to maintain.
*   Structured logging is essential for debugging the complex, event-driven features planned in subsequent phases.
*   Ensuring API contracts are tested (like the `resolve_hit` guard) prevents regressions.

---

# ðŸ”§ Technical Changes

### 1. Systematic `print()` Replacement
Every `print()` call within the `src/` directory is replaced with a `logger` call. A `logger = logging.getLogger(__name__)` instance is added to the top of each modified file.

*   Informational output (e.g., simulation summaries) becomes `logger.info()`.
*   Verbose, frequent output (e.g., effect procs, event dispatches) becomes `logger.debug()`.
*   Error conditions become `logger.error()` or `logger.exception()`.

### 2. Addition of Missing API Guard Test
A new test is added to `tests/test_engine.py` to explicitly validate the `ValueError` raised by `resolve_hit` when its `state_manager` argument is `None`.

### 3. Test Suite Refactoring
Any existing unit tests that may have relied on patching `builtins.print` are to be refactored to either assert on the final state of the `StateManager` (preferred) or use `pytest`'s `caplog` fixture to inspect logged output.

---

# ðŸ”§ Code Changes (Example Diffs)

### **1. Refactor Effect Handlers (`src/effect_handlers.py`)**

```diff
*** Begin Patch
*** Update File: src/effect_handlers.py
@@
-import random
+import random
+import logging
 from abc import ABC, abstractmethod
 from .events import EventBus, OnHitEvent
 from .state import StateManager
 from .models import DamageOnHitConfig

+logger = logging.getLogger(__name__)
+
@@ class DamageOnHitHandler(EffectHandler):
@@
             if self.config.display_message:
                 target_name = getattr(event.defender, 'name', event.defender.id)
                 message = self.config.display_message.format(target=target_name)
-                print("    -> " + message)
-                logger.debug("Effect proc: %s", message)
+                logger.debug("Effect proc: %s", message)
             else:
-                # Default message format
                 message = f"{self.config.debuff_name} proc'd on {event.defender.id}!"
-                print("    -> " + message)
-                logger.debug("Effect proc: %s", message)
+                logger.debug("Effect proc: %s", message)
*** End Patch
```

### **2. Refactor Simulation Scripts (e.g., `run_full_test.py`)**

```diff
*** Begin Patch
*** Update File: run_full_test.py
@@
 import time
+import logging
 from src.models import Entity, EntityStats, RolledAffix, Item
 # ... other imports

+logging.basicConfig(level=logging.INFO, format='%(message)s')
+
@@
-print('='*80)
-print('PHASE 5: FINAL TESTING & DATA IMPLEMENTATION')
-print('Complete Combat System Validation As Per IP Requirements')
-print('='*80)
-print()
+logging.info('='*80)
+logging.info('PHASE 5: FINAL TESTING & DATA IMPLEMENTATION')
+logging.info('Complete Combat System Validation As Per IP Requirements')
+logging.info('='*80)
+logging.info('')
*** End Patch
```

### **3. Add Missing Guard Test (`tests/test_engine.py`)**

```diff
*** Begin Patch
*** Update File: tests/test_engine.py
@@
 import pytest
 from src.models import Entity, EntityStats
 from src.engine import CombatEngine, HitContext
 from src.state import StateManager
+from tests.fixtures import make_attacker, make_defender

 class TestCombatEngineResolveHit:
+    def test_resolve_hit_requires_state_manager(self):
+        """Verify resolve_hit raises ValueError if state_manager is None."""
+        engine = CombatEngine()
+        attacker = make_attacker()
+        defender = make_defender()
+        with pytest.raises(ValueError, match="requires state_manager parameter"):
+            engine.resolve_hit(attacker, defender, None)
+
     def test_no_armor(self):
 # ... rest of the file
*** End Patch
```

---

# ðŸ§ª Test Suite Changes

Tests must be updated to no longer rely on `print`.

**Before (Brittle):**
```python
with patch("builtins.print") as mock_print:
    handler.handle_on_hit(event)
    mock_print.assert_called_with("    -> Bleed proc'd on defender!")
```

**After (Robust):**
```python
def test_bleed_proc_applies_debuff(state_manager, event_bus):
    # Setup handler and event
    handler = BleedHandler(event_bus, state_manager, proc_rate=1.0)
    event = OnHitEvent(...)
    
    # Act
    handler.handle_on_hit(event)

    # Assert on the actual state change
    defender_state = state_manager.get_state(event.defender.id)
    assert "Bleed" in defender_state.active_debuffs
```

---

# ðŸš¦ Migration Checklist

*   [ ] Systematically search for and replace all `print()` calls in the `src/` directory.
*   [ ] Add `import logging` and `logger = logging.getLogger(__name__)` to all modified files.
*   [ ] Add `logging.basicConfig()` to the entry point of all runnable scripts (`run_*.py`, `demo_*.py`).
*   [ ] Add the `test_resolve_hit_requires_state_manager` unit test to `tests/test_engine.py`.
*   [ ] Review and refactor any unit tests that relied on `print` to assert on state or logs.
*   [ ] Run the full `pytest` suite to ensure all tests pass.

---

# ðŸŽ¯ Outcome

After this PR is merged:
*   The core engine library will be completely free of `print()` statements, making it suitable for production use.
*   All output will be managed through a standard, configurable logging framework.
*   The test suite will be more robust, asserting on behavior rather than console output.
*   The `CombatEngine`'s API contract will be properly enforced and validated by the test suite.
*   The codebase is now prepared for the implementation of more complex, event-driven features where clear logging is essential.

---

**PR-P1S1 Complete. Ready for review and merge.**


// =================================================================
// METADATA
// =================================================================
// File Path:      docs\PR-P1S2.md
// Size:           7.38 KB
// Last Modified:  2025-11-17T18:02:04.674Z
// =================================================================

### **PR-P1S2: Core Mechanics Correction and Determinism Hardening**

## Overview

This PR executes the second step of the Foundational Stability phase. It addresses four critical bugs and inconsistencies in the core combat logic and random number generation (RNG) system.

By fixing these issues, this PR ensures that the game's combat mechanics are correct, predictable, and fully deterministic for testing and balancing purposes.

---

# âœ… Summary

**Goal:** Correct major bugs in the game's core systems:
1.  **Fix Hardcoded Proc Rate:** Make skill trigger proc rates fully data-driven.
2.  **Fix Dual-Stat Affixes:** Implement the logic to make dual-stat affixes functional.
3.  **Unify RNG Handling:** Eliminate non-deterministic behavior by ensuring all systems can use an injectable RNG instance.
4.  **Correct Minor Logic Errors:** Fix incorrect game logic related to evasion rewards and glancing blows.

**Why this is a foundational change:**
*   These bugs cause incorrect or unpredictable gameplay, making balancing impossible.
*   Inconsistent RNG prevents reliable, repeatable testing, which is essential for a CI/CD pipeline.
*   Correcting these issues now prevents them from complicating the implementation of all future features.

---

# ðŸ”§ Technical Changes

### 1. Proc Rate Correction
The `CombatOrchestrator` is refactored to respect the `proc_rate` defined in the game data. This involves passing the `proc_rate` from the `CombatEngine` to the orchestrator via the `ApplyEffectAction`.

### 2. Dual-Stat Affix Rework
The `ItemGenerator` and `RolledAffix` model are refactored. The generator now correctly rolls two separate values for dual-stat affixes, and the `Entity.calculate_final_stats` method is updated to apply both values correctly.

### 3. RNG Unification
`ItemGenerator`, `CombatOrchestrator`, and `EffectHandler` classes are all updated to accept an optional `rng` instance in their constructors. They now use this local `rng` instance for all random operations, falling back to the global `random` module only if no instance is provided.

### 4. Gameplay Logic Fixes
*   The `resource_on_kill` reward granted to an attacker when their attack is dodged is removed.
*   The `apply_glancing_damage` function is corrected to ensure a multiplier of `0` results in `0` damage.

---

# ðŸ”§ Code Changes (Example Diffs)

### **1. Fix Hardcoded Proc Rate (`src/combat_orchestrator.py` & `src/models.py`)**

```diff
*** Begin Patch
*** Update File: src/models.py
@@ @dataclass
 class ApplyEffectAction(Action):
     target_id: str
     effect_name: str
     stacks_to_add: int = 1
     source: str = "skill"
+    proc_rate: float = 1.0
*** Update File: src/combat_orchestrator.py
@@ def _execute_effect_action(self, action: ApplyEffectAction) -> None:
-        proc_rate = 0.5  # TODO: Make this configurable
-        should_apply = rng_value < proc_rate
+        should_apply = True
+        if action.proc_rate < 1.0:
+            rng_value = self.rng.random() if self.rng else random.random()
+            should_apply = rng_value < action.proc_rate
*** End Patch
```

### **2. Fix Dual-Stat Affixes (`src/models.py` & `src/item_generator.py`)**

```diff
*** Begin Patch
*** Update File: src/models.py
@@ @dataclass
 class RolledAffix:
     # ...
     value: float
+    dual_value: Optional[float] = None
-    # (get_dual_value() and other parsing methods removed)
*** Update File: src/item_generator.py
@@ def _roll_one_affix(self, affix_id: str, max_quality: int) -> RolledAffix:
+    # (New logic to check for ';' in base_value_str, roll two separate
+    # values, and populate both `value` and `dual_value` fields)
*** End Patch
```

### **3. Unify RNG (`src/item_generator.py` example)**

```diff
*** Begin Patch
*** Update File: src/item_generator.py
@@
-class ItemGenerator:
-    def __init__(self, game_data: dict = None):
+import random
+
+class ItemGenerator:
+    def __init__(self, game_data: dict = None, rng: random.Random = None):
         # ...
+        self.rng = rng if rng is not None else random.Random()
@@ def _roll_quality_tier(self, rarity: str) -> dict:
-        selected_tier = random.choices(possible_tiers, weights=weights, k=1)[0]
+        selected_tier = self.rng.choices(possible_tiers, weights=weights, k=1)[0]
*** End Patch
```
*(This pattern is also applied to `CombatOrchestrator` and `EffectHandler`.)*

### **4. Fix Gameplay Logic (`src/engine.py` & `src/combat_math.py`)**

```diff
*** Begin Patch
*** Update File: src/engine.py
@@ def process_skill_use(...):
         if hit_context.was_dodged:
             dodge_event = OnDodgeEvent(attacker=attacker, defender=defender)
             event_bus.dispatch(dodge_event)
-            state_manager.add_resource(attacker.id, attacker.final_stats.resource_on_kill)
             continue
*** Update File: src/combat_math.py
@@ def apply_glancing_damage(damage: float, glancing_multiplier: float) -> float:
-    if glancing_multiplier <= 0:
-        return damage
-    return damage * glancing_multiplier
+    multiplier = max(0.0, min(1.0, glancing_multiplier))
+    return damage * multiplier
*** End Patch
```

---

# ðŸ§ª Test Suite Additions

This PR requires adding and updating tests to validate the fixes.

1.  **Proc Rate Test:** A test is added to confirm that a skill with a `proc_rate` of `0.25` in the data file correctly applies its effect approximately 25% of the time over a large number of runs with a seeded RNG.
2.  **Dual-Stat Test:** A new unit test for `Entity.calculate_final_stats` is created. It equips an item with a freshly generated dual-stat affix and asserts that *both* of the character's final stats have been correctly modified.
3.  **RNG Determinism Test:** An end-to-end integration test is added that seeds the entire simulation (including the `ItemGenerator`). It runs the simulation twice with the same seed and asserts that the final state of the `StateManager` is identical in both runs.
4.  **Gameplay Logic Tests:** The tests for `apply_glancing_damage` are updated to check for the correct `0` damage behavior. A test is added to confirm an attacker's resources do not change when their attack is dodged.

---

# ðŸš¦ Migration Checklist

*   [ ] Refactor `CombatOrchestrator` to use the `proc_rate` from `ApplyEffectAction`.
*   [ ] Refactor `RolledAffix`, `ItemGenerator`, and `Entity.calculate_final_stats` to correctly handle dual-stat affixes.
*   [ ] Add an optional `rng` parameter to the constructors of `ItemGenerator`, `CombatOrchestrator`, and `EffectHandler` and update their internal logic.
*   [ ] Remove the incorrect resource reward on dodge from `engine.py`.
*   [ ] Correct the logic in the `apply_glancing_damage` function.
*   [ ] Add or update unit tests to validate all of the above fixes.
*   [ ] Run the full `pytest` suite to ensure no regressions have been introduced.

---

# ðŸŽ¯ Outcome

After this PR is merged:
*   The game mechanics will behave correctly and as intended by the data-driven design.
*   Dual-stat items, a core RPG feature, will be fully functional.
*   The entire simulation pipeline will be capable of fully deterministic execution, which is a massive win for testing and balancing.
*   The codebase will be free of several subtle but significant logical bugs, making it a much more stable foundation for future development.

---

**PR-P1S2 Complete. Ready for review and merge.**


// =================================================================
// METADATA
// =================================================================
// File Path:      docs\PR-P1S3.md
// Size:           6.71 KB
// Last Modified:  2025-11-17T18:06:51.207Z
// =================================================================

### **PR-P1S3: Data Pipeline Hardening with Strict Typing and Cross-Reference Validation**

## Overview

This PR executes the third and final step of the Foundational Stability phase. It builds upon the existing schema validation system (from PR #5) by introducing a second layer of validation: **strict typing and semantic cross-referencing**.

This ensures that not only is the data structurally correct, but it is also logically coherent. For example, it guarantees that a skill cannot trigger an effect that doesn't exist, or an affix cannot modify a stat that isn't part of the `EntityStats` model.

This PR fully integrates modern Python tooling (`enums`, `TypedDicts`, `mypy`) to make the entire data pipeline robust, self-documenting, and safe from a wide class of data-related runtime errors.

---

# âœ… Summary

**Goal:**
1.  **Introduce Typed Models:** Define `TypedDict` or `dataclass` models and `Enum` types for all core game data (effects, skills, items, etc.).
2.  **Implement Cross-Reference Validation:** Add a post-loading validation step that checks for logical integrity across different data files (e.g., skill triggers must point to valid effects).
3.  **Integrate Static Type Checking:** Add `mypy` to the development tooling to enforce type safety across the entire codebase.

**Why this is a crucial enhancement:**
*   It catches a class of bugs that simple schema validation misses, such as a designer making a typo in an `effect_id`.
*   `Enums` prevent hundreds of potential bugs by replacing "magic strings" (like `"Rare"` or `"Weapon"`) with validated constants.
*   Static type checking makes the code easier to reason about, refactor, and maintain.

---

# ðŸ”§ Technical Changes

### 1. New Typed Models and Enums (`src/data/typed_models.py` - New File)
A new file is created to house all the `Enum` and `TypedDict` definitions. This keeps the data contracts clean and centralized.

**Example `Enum`:**
```python
# src/data/typed_models.py
from enum import Enum

class Rarity(str, Enum):
    COMMON = "Common"
    UNCOMMON = "Uncommon"
    RARE = "Rare"
    # ... etc.

class ItemSlot(str, Enum):
    WEAPON = "Weapon"
    HEAD = "Head"
    CHEST = "Chest"
    # ... etc.
```

**Example `TypedDict`:**
```python
# src/data/typed_models.py
from typing import TypedDict, List

class SkillData(TypedDict):
    skill_id: str
    name: str
    damage_type: str # Could also be a DamageType Enum
    hits: int
    trigger_result: str # The ID of the effect to be triggered
    # ... etc.
```

### 2. Update the Data Provider to Use Typed Models
The `GameDataProvider` (from our previous merge) is updated. After parsing the raw data using the existing schema system, it will now convert the dictionaries into these new typed objects.

```diff
*** Begin Patch
*** Update File: src/game_data_provider.py
@@
 from .data.typed_models import SkillData, EffectData # etc.
@@
 class GameDataProvider:
     def _load_all_data(self) -> None:
         raw_data = parse_all_csvs()
-
-        self.skills = {k: LoadedSkill(**v) for k, v in raw_data.get('skills', {}).items()}
+        
+        # Convert raw dicts to typed dicts/objects
+        self.skills: Dict[str, SkillData] = raw_data.get('skills', {})
+        self.effects: Dict[str, EffectData] = raw_data.get('effects', {})
+        # ... etc. for all data types
+
+        # After all data is loaded, run the cross-reference validation
+        self._validate_cross_references()
```

### 3. Implement the Cross-Reference Validation Layer
A new private method is added to `GameDataProvider` that performs the vital cross-reference checks. This is the "Strict Mode" for data integrity.

```diff
*** Begin Patch
*** Update File: src/game_data_provider.py
@@
 class GameDataProvider:
     # ...
+    def _validate_cross_references(self) -> None:
+        """
+        Ensures all IDs referenced in the data exist.
+        Raises ValueError if any dangling reference is found.
+        """
+        # Example: Validate that all skill triggers point to a real effect
+        for skill_id, skill in self.skills.items():
+            if trigger_effect_id := skill.get("trigger_result"):
+                if trigger_effect_id not in self.effects:
+                    raise ValueError(
+                        f"Data Validation Error: Skill '{skill_id}' references "
+                        f"a non-existent effect ID '{trigger_effect_id}'."
+                    )
+
+        # Example: Validate that all item implicit affixes are real affixes
+        for item_id, item in self.items.items():
+            for affix_id in item.get("implicit_affixes", []):
+                if affix_id not in self.affixes:
+                    raise ValueError(
+                        f"Data Validation Error: Item '{item_id}' references "
+                        f"a non-existent implicit affix ID '{affix_id}'."
+                    )
+        # ... (Add more validation rules as needed) ...
+
+        logger.info("All data cross-references validated successfully.")
*** End Patch
```

### 4. Integrate Static Type Checking (`mypy`)
The `pyproject.toml` file is created (if not already present) and configured to run `mypy` in strict mode.

```toml
# pyproject.toml

[tool.mypy]
python_version = "3.9" # Or your target version
warn_return_any = true
warn_unused_ignores = true
strict = true
```

---

# ðŸš¦ Migration Checklist

*   [ ] Create a new file `src/data/typed_models.py` to define all `Enum` and `TypedDict` models.
*   [ ] Update `GameDataProvider._load_all_data` to store data using these new typed models.
*   [ ] Implement the `_validate_cross_references` method in `GameDataProvider` and ensure it is called after all data is loaded.
*   [ ] Add unit tests for the cross-reference validation (e.g., create a temporary bad CSV file and assert that the correct `ValueError` is raised).
*   [ ] Add and configure `mypy` in `pyproject.toml`.
*   [ ] Run `mypy` across the entire codebase and fix any revealed type errors.
*   [ ] Update the CI/testing script to run `mypy` as a required check.

---

# ðŸŽ¯ Outcome

After this PR is merged:
*   The data pipeline is now validated at three levels: **structure** (schemas), **logic** (cross-references), and **type-safety** (`mypy`).
*   A huge category of potential data-entry bugs (typos, incorrect IDs) is completely eliminated.
*   The codebase becomes significantly more self-documenting and easier to work with, as editors can now provide better autocompletion and type information for all game data.
*   The project adheres to the highest standards of modern Python development, making it extremely robust and maintainable.

---

**PR-P1S3 Complete. Ready for review and merge.**


// =================================================================
// METADATA
// =================================================================
// File Path:      docs\PR-P2S4.md
// Size:           2.89 KB
// Last Modified:  2025-11-17T19:33:50.636Z
// =================================================================

### **PR-P2S4: Entity Lifecycle Management and Cleanup System**

## Overview

This PR introduces a formal lifecycle for all battle entities and implements a robust cleanup system. It ensures stability, prevents memory leaks, and enables complex mechanics (like on-death effects) by hooking into the `EventBus` and `StateManager`.

**Revision Note:** This PR has been updated to integrate with the **Logging System (PR-P1S1)** for visibility and the **GameDataProvider (PR-P1S3)** for looking up lifecycle-triggered skills.

## Objectives

*   Define standard entity lifecycle stages: `OnSpawn`, `OnActivate`, `OnDeath`, `OnDespawn`.
*   Implement `EventBus` hooks for each stage.
*   Ensure dead entities are strictly non-targetable and cannot act.
*   **Prevent Memory Leaks:** Automatically unsubscribe entities from the `EventBus` and remove them from `StateManager` upon despawn.

## Lifecycle Stages & Implementation

### **1. OnSpawn**
Triggered when `StateManager.add_entity()` is called.
*   **Action:** Initialize entity state.
*   **Logging:** `logger.debug("Entity '%s' spawned.", entity.id)`

### **2. OnActivate**
Triggered at the start of combat or when a reinforcement enters.
*   **Action:** Subscribe to `EventBus` events (e.g., `OnHit`, `OnBlock` for reactive affixes).
*   **Logging:** `logger.debug("Entity '%s' activated.", entity.id)`

### **3. OnDeath**
Triggered within `StateManager.apply_damage()` when health reaches 0.
*   **Action:**
    *   Set `is_alive = False`.
    *   **Cleanup:** Unsubscribe from `EventBus` immediately to stop processing events.
    *   **Trigger:** Lookup "on-death" skills via `GameDataProvider` and queue them if applicable.
*   **Logging:** `logger.info("Entity '%s' died.", entity.id)`

### **4. OnDespawn**
Triggered when an entity is removed from the scene (cleanup phase).
*   **Action:**
    *   Call `StateManager.remove_entity(id)`.
    *   Ensure all active effects on the entity are cleared.
*   **Logging:** `logger.debug("Entity '%s' despawned and memory cleared.", entity.id)`

## Technical Changes

### **StateManager Updates (`src/state.py`)**
*   Modify `apply_damage` to detect the transition to 0 health and fire `OnDeath`.
*   Implement the cleanup logic ensuring no "zombie" references remain in the `effects` dictionary.

### **Event Integration (`src/events.py`)**
*   Add `EntityDeathEvent`, `EntitySpawnEvent`, and `EntityDespawnEvent` classes.

### **Engine Updates**
*   Update `CombatEngine` to check `state.is_alive` before processing any turns or targeting logic.

## Test Coverage

*   **Lifecycle Flow:** Test that `Spawn -> Activate -> Death -> Despawn` fires events in order.
*   **Listener Cleanup:** Test that a dead entity does *not* receive events (e.g., a dead unit with "Thornmail" does not reflect damage).
*   **Memory Safety:** Assert that `StateManager` is empty after `OnDespawn` is called.

---


// =================================================================
// METADATA
// =================================================================
// File Path:      docs\PR-P2S5.md
// Size:           3.24 KB
// Last Modified:  2025-11-17T19:33:28.876Z
// =================================================================

### **PR-P2S5: Simulation Batching API and Telemetry Expansion**

## Overview

PR #10 introduces a formal batching API for running thousands of autonomous combat simulations. It transforms the engine into a data-driven balancing laboratory.

**Revision Note:** This PR has been significantly revised to enforce **Determinism (via PR-P1S2)** and **Structured Telemetry (via PR-P1S1)**. It strictly depends on the lifecycle cleanup from PR #9 to manage memory during batch runs.

## Objectives

*   Add `SimulationBatchRunner` for high-volume testing.
*   **Enforce Determinism:** Use injected RNG seeds to guarantee reproducible results.
*   **Telemetry Modes:** Implement "Developer," "Designer," and "Player" modes using `logging.Filters` and `Formatters`.
*   **Statistical Output:** Calculate Mean/Median Time-To-Kill (TTK) and DPS.

## New Components

### **1. `SimulationBatchRunner` (`src/simulation/batch_runner.py`)**

Responsible for executing simulation loops.

*   **Method:** `run_batch(attacker_template, defender_template, iterations, base_seed)`
*   **Deterministic Logic:**
    ```python
    for i in range(iterations):
        # 1. Create a deterministic seed for this specific run
        run_seed = base_seed + i
        rng = random.Random(run_seed)

        # 2. Inject RNG into all components (Crucial for P1S2 compliance)
        engine = CombatEngine(rng=rng)
        item_gen = ItemGenerator(rng=rng)

        # 3. Run Simulation
        # ...

        # 4. Mandatory Cleanup (Crucial for PR9 compliance)
        state_manager.reset_system()
    ```

### **2. Telemetry & Logging Modes**

Instead of `print` statements, we configure the `logging` subsystem:

*   **Developer Mode (`DEBUG`):** Logs every variable change, RNG roll result, and internal state update.
*   **Designer Mode (`INFO`):** Logs aggregate stats per fight (e.g., "Fight 1: Attacker Wins in 12.5s, 450 DPS").
*   **Player Mode (Custom Formatter):** Transforms structured logs into readable text (e.g., *"Critical Hit! Gork deals 50 damage to Mork."*).

### **3. Aggregators**

*   `DpsAggregator`: Collects damage events to calculate min/max/avg DPS.
*   `WinRateAggregator`: Tracks win/loss ratios.

## Telemetry Additions

*   Expand `HitContext` (from PR #7) to include `simulation_id` and `batch_id`.
*   Export results to **JSON** (for analysis) and **CSV** (for spreadsheet balancing).

## Test Coverage

### **Determinism Test**
*   Run a batch of 100 fights with `seed=42`.
*   Run the batch again with `seed=42`.
*   **Assert:** The results (winner, remaining HP, total duration) must be *bit-identical*.

### **Memory Leak Test**
*   Run a batch of 10,000 simulations.
*   **Assert:** Memory usage does not grow linearly (validating PR #9 cleanup).

### **Aggregation Test**
*   Feed known `HitContext` data into the aggregators and verify the statistical output (Mean, Median).

## Migration Notes

*   This PR depends on **PR-P1S2** (RNG Unification) and **PR #9** (Lifecycle) being merged first. Attempting to run this without them will result in non-deterministic data and memory crashes.

---

**Outcome:** These revised PRs now fit perfectly into the new, stable architecture you have established. They are ready for implementation.


// =================================================================
// METADATA
// =================================================================
// File Path:      docs\PR-P3S6.md
// Size:           3.22 KB
// Last Modified:  2025-11-17T19:20:21.201Z
// =================================================================

### **PR-P3S6: Project Restructuring and Tooling Integration**

## Overview

This PR executes the first step of the Finalization phase. It completely reorganizes the project from a flat `src/` directory into a clean, modular, and professional repository structure. It also introduces and configures a standard suite of modern Python development tools (`black`, `ruff`, `mypy`) via a `pyproject.toml` file.

This is a foundational step in making the codebase maintainable, scalable, and easy for new developers to navigate.

## Objectives

1.  **Restructure the Project:** Reorganize all source code, tests, and scripts into a logical, hierarchical directory structure.
2.  **Introduce Tooling:** Create a `pyproject.toml` file to manage and configure `pytest`, `black`, `ruff`, and `mypy`.
3.  **Automate Code Quality:** Run the new tools across the entire codebase to enforce consistent formatting and linting rules.

## New Project Structure

The project is reorganized as follows:

```
src/
    __init__.py
    combat/
        __init__.py
        combat_math.py
        engine.py
        orchestrator.py
    core/
        __init__.py
        events.py
        models.py
        skills.py
        state.py
    data/
        __init__.py
        data_parser.py
        game_data_provider.py
        schemas.py
        typed_models.py
    handlers/
        __init__.py
        effect_handlers.py
    simulation/
        __init__.py
        batch_runner.py
        simulation.py
    utils/
        __init__.py
        item_generator.py
tests/
    # ... (mirrors the src structure)
scripts/
    run_simulation_batch.py
    validate_data.py
    demo_item.py
data/
    # ... (all .csv files)
docs/
    # ... (placeholder for documentation)
pyproject.toml
README.md
```
*(Note: Legacy `run_phaseX` and `test_phaseX` scripts are deleted during this restructure.)*

## Tooling Configuration (`pyproject.toml`)

A new `pyproject.toml` file is added with configurations for the following tools:

*   **Black:** Enforces uncompromising code formatting.
*   **Ruff:** A high-performance linter to catch common errors and style issues.
*   **Mypy:** The static type checker, configured to enforce the strict typing rules established in Phase 1.
*   **Pytest:** Configured for test discovery within the new `tests/` structure.

## Migration Checklist

*   [ ] Create the new directory structure.
*   [ ] Move all `.py` files to their new locations.
*   [ ] Systematically update all `import` statements across the entire project to reflect the new paths.
*   [ ] Delete all legacy test and run scripts from the root directory.
*   [ ] Create and configure the `pyproject.toml` file.
*   [ ] Run `black .` and `ruff . --fix` to format and lint the entire codebase.
*   [ ] Run `mypy src/` to confirm that static type checking passes.
*   [ ] Run the full `pytest` suite to ensure all tests are discovered and pass in the new structure.

## Outcome

*   The repository is now clean, organized, and professional.
*   Code quality and style are now enforced automatically, improving consistency and reducing PR review friction.
*   The project is prepared for the final steps of integration testing and documentation.

---



// =================================================================
// METADATA
// =================================================================
// File Path:      docs\PR-P3S7.md
// Size:           3.02 KB
// Last Modified:  2025-11-17T19:33:37.028Z
// =================================================================

### **PR-P3S7: Final Integration Test and CI Hardening**

## Overview

This PR creates the definitive end-to-end integration test for the combat engine, ensuring all refactored and newly implemented systems work together correctly. It replaces the old, `print`-based `run_full_test.py` script with a fully automated, deterministic, and assertion-based `pytest` test.

This test will serve as the primary "health check" for the entire system in a Continuous Integration (CI) environment.

## Objectives

1.  **Create a Definitive Integration Test:** Convert the scenario from `run_full_test.py` into a proper `pytest` test.
2.  **Enforce Determinism:** Ensure the test produces the exact same result every single time it is run.
3.  **Use Programmatic Assertions:** Replace all `print()`-based checks with `assert` statements that programmatically validate the final game state.
4.  **CI Readiness:** The final test must be suitable for running automatically in a CI pipeline.

## Technical Changes

### **New Test File (`tests/test_integration.py`)**
A new test file is created to house the end-to-end test.

**Key Features of the Test:**
*   **Seeded RNG:** The test creates a single, seeded `random.Random()` instance at the beginning. This same instance is then injected into the `CombatEngine`, `ItemGenerator`, and any other component that requires randomness.
*   **Full Scenario Simulation:** The test sets up the "berserker vs. tank" scenario, including equipping items with conditional affixes.
*   **State Assertion:** After the simulation loop runs for a fixed duration, the test uses `assert` statements to verify the final state:
    *   `assert state_manager.get_current_health("defender_id") == pytest.approx(EXPECTED_HEALTH)`
    *   `assert state_manager.get_current_resource("attacker_id") == pytest.approx(EXPECTED_RESOURCE)`
    *   `assert "Bleed" in [e.definition_id for e in state_manager.get_active_effects("defender_id")]`
    *   `assert len(attacker_state.roll_modifiers.get('crit_chance', [])) > 0`

## Migration Checklist

*   [ ] Create the new `tests/test_integration.py` file.
*   [ ] Copy the setup logic from `run_full_test.py` into a new test function (e.g., `test_full_combat_scenario`).
*   [ ] Implement the deterministic RNG seeding and injection.
*   [ ] Replace all `print()` calls with `logging.info()` for visibility during test runs.
*   [ ] Remove all `print()`-based "verification checks" and replace them with `assert` statements that check the final values in the `StateManager`.
*   [D]elete the now-obsolete `run_full_test.py` script.
*   [ ] Run the new integration test and confirm that it passes reliably and deterministically.

## Outcome

*   The project now has a "gold standard" integration test that verifies the correct interaction of all major systems.
*   The test suite is now fully automated and no longer relies on manual inspection of `print` output.
*   The codebase is ready for integration into a CI pipeline where this test can act as a gatekeeper against regressions.

---



// =================================================================
// METADATA
// =================================================================
// File Path:      docs\PR-P3S8.md
// Size:           2.73 KB
// Last Modified:  2025-11-17T19:20:49.354Z
// =================================================================

### **PR-P3S8: Final Documentation and Project Polish**

## Overview

This is the final PR for the project, completing the transformation into a polished, professional, and maintainable library. It adds comprehensive documentation at both the architectural and code levels, along with contributor guides to facilitate future development.

## Objectives

1.  **Create Architectural Documentation:** Write high-level documents explaining the core systems (Engine, State, Events, etc.).
2.  **Add Code-Level Documentation:** Ensure all public classes and methods have clear, informative docstrings.
3.  **Create Contributor and User Guides:** Add a `README.md`, `CONTRIBUTING.md`, and `CHANGELOG.md` to make the project accessible.

## Technical Changes

### **1. New `docs/` Directory**
The `/docs` directory is created and populated with markdown files, including:
*   `architecture.md`: An overview of the project structure and how the modules interact.
*   `damage_pipeline.md`: A detailed, step-by-step explanation of the `resolve_hit` calculation.
*   `state_and_lifecycle.md`: Explains the `StateManager` and the entity lifecycle events.
*   `data_pipeline.md`: Describes how data flows from CSVs through the `GameDataProvider`.
*   Includes architecture diagrams as needed to visually explain complex flows.

### **2. Docstrings**
Docstrings are added throughout the codebase, following a consistent format (e.g., Google Style or reStructuredText), for all public-facing modules, classes, and functions.

### **3. Root-Level Documentation**
*   **`README.md`:** Updated to be a welcoming front page, with a project summary, installation instructions, and a quick-start code example.
*   **`CONTRIBUTING.md`:** A new file explaining how to set up the development environment, run tests, and contribute code. Includes style guidelines and PR templates.
*   **`CHANGELOG.md`:** A new file documenting the major features and changes introduced in each version, summarizing the work from all the PRs.

## Migration Checklist

*   [ ] Create and populate the `/docs` directory with the required architectural documents.
*   [ ] Add comprehensive docstrings to all major classes and methods in the `src/` directory.
*   [ ] Write the `CONTRIBUTING.md` and `CHANGELOG.md` files.
*   [ ] Overhaul the `README.md` to be a complete and helpful entry point for new users.

## Outcome

*   The project is now fully documented, making it easy for new developers to understand, use, and contribute to.
*   The codebase is professional, polished, and ready for open-sourcing or internal distribution as a high-quality library.
*   The project's history, design, and contribution process are all clearly recorded, ensuring its long-term health and maintainability.


// =================================================================
// METADATA
// =================================================================
// File Path:      docs\Procedural_Item_Extension_Guide.md
// Size:           15.90 KB
// Last Modified:  2025-11-15T14:48:08.992Z
// =================================================================

# Procedural Item Extension Guide v2.0

This comprehensive guide covers extending the **Master Rule Data System** - a complete CSV-driven architecture for adding content to the Combat Engine. This includes advanced affixes, skills, effects, and complex reactive mechanics.

## Overview of CSV Files

The system uses four interconnected CSV files:

| File | Purpose | Main Use Cases |
|------|---------|----------------|
| `data/affixes.csv` | Equipment modifiers and reactive effects | Stats, scaling, triggers, dual-stats |
| `data/skills.csv` | Combat skills and abilities | Damage, resource cost, triggers |
| `data/effects.csv` | Status effects and buffs | DoTs, buffs, debuffs, complex mechanics |
| `data/items.csv` | Equipment templates | Slot definitions, affix pools |

All changes require running `python src/data_loader.py` to regenerate the processed data.

---

## Advanced Affixes System (`data/affixes.csv`)

### Enhanced Format v2.0
```csv
affix_id,stat_affected,mod_type,affix_pools,base_value,description,trigger_event,proc_rate,trigger_result,trigger_duration,stacks_max,dual_stat,scaling_power,complex_effect
```

### Column Details

| Column | Type | Description | Requirements |
|--------|------|-------------|--------------|
| `affix_id` | String | Unique identifier | Must be unique across all affixes |
| `stat_affected` | String | EntityStats attribute(s) | Semicolon-separated for dual-stat (e.g., "crit_chance;crit_damage") |
| `mod_type` | String | Modification type(s) | Semicolon-separated: "flat;multiplier", "scaling;scaling" |
| `affix_pools` | String | Pool membership | Pipe-separated pools (e.g., "weapon_pool|axe_pool") |
| `base_value` | String/Float | Base value(s) | For dual-stat: "0.075;0.375" (semicolon-separated) |
| `description` | String | Tooltip template | Use `{value}` or `{dual_value}` for dual-stat display |
| `trigger_event` | String | When effect activates | e.g., "OnHit", "OnSkillUsed", "OnBlock" |
| `proc_rate` | Float | Chance to trigger (0.0-1.0) | Optional; leave empty for passive effects |
| `trigger_result` | String | Effect to apply | Simple names (e.g., "bleed") or complex "effect:parameter" |
| `trigger_duration` | Float | Effect duration | In seconds |
| `stacks_max` | Int | Maximum stacks | For stacking effects |
| `dual_stat` | String | Second stat name | For dual-stat affixes |
| `scaling_power` | String | Enables power scaling | Set to "true" for scaling affixes |
| `complex_effect` | String | Special effect type | e.g., "special_skill" for advanced triggers |

## Affix Types and Examples

### 1. Basic Stat Affixes
```csv
flat_dmg,base_damage,flat,weapon_pool,50,+{value} Base Damage,,,,,,,,
crit_dmg,crit_damage,flat,jewelry_pool,0.5,+{value}% Crit Damage,,,,,,,,
```

### 2. Dual-Stat Affixes (Affects Multiple Stats Simultaneously)
```csv
devastating_strikes,crit_chance;crit_damage,flat;flat,jewelry_pool,0.075;0.375,{value}% Crit & {dual_value}% Crit Damage,,,,,,,,true,
precision_power,pierce_ratio;max_resource,multiplier;flat,weapon_pool,0.15;25,{value}% Pierce & {dual_value} Max Resource,,,,,,,,true,
```

### 3. Scaling Affixes (Grows Stronger with Character Power)
```csv
berserker_rage,base_damage;crit_chance,scaling;scaling,jewelry_pool,0.5;0.3,{value}% Damage & Crit (scales with power),,,,,,,,,true,true
```

### 4. Reactive Trigger Affixes (Complex Effects)
```csv
thornmail,,,armor_pool,,,,OnBlock,0.5,reflect_damage:0.3,,,true,,
focused_rage,,,jewelry_pool,,,,OnSkillUsed,1.0,apply_crit_bonus:0.25,5.0,3,,true,special_skill
```

### 5. Pure Reactive Affixes (No Stat Bonuses)
```csv
blinding_rebuke,,,jewelry_pool,,,,OnBlock,0.8,reduced_evasion:0.15,3.0,1,,true,,
```

## Complex Trigger Effects

### Format: `"effect_name:parameter"`
The trigger_result column supports complex effects using `"effect_name:parameter"` format.

### Available Effect Types:
- **Standard Effects**: `"bleed"`, `"freeze"`, `"burn"`, `"stun"`, etc.
- **Damage Reflection**: `"reflect_damage:0.3"` (reflects 30% of blocked damage)
- **Stat Modification**: `"apply_crit_bonus:0.25"` (+25% crit chance)  
- **Healing Effects**: `"heal_self:0.2"` (heal 20% of damage dealt)
- **Chain Effects**: `"chain_damage:0.6"` (60% damage to adjacent targets)
- **Life Drain**: `"drain_life:0.05"` (drain 5% of target health per tick)
- **Divine Effects**: `"bless_allies:0.3"` (heal nearby allies)
- **Self Damage**: `"self_damage:0.5"` (take damage when triggering)
- **Resource Effects**: Various resource manipulation effects

### Trigger Events:
- `"OnHit"` - When the attack hits (any damage)
- `"OnCrit"` - When the attack crits
- `"OnBlock"` - When the attack is blocked
- `"OnDodge"` - When the attack is dodged
- `"OnSkillUsed"` - When any skill is used (requires complex_effect match)

---

## Skills and Abilities (`data/skills.csv`)

Add combat skills using the CSV-driven skill system.

### Enhanced Format v2.0
```csv
skill_id,name,damage_type,hits,description,resource_cost,cooldown,trigger_event,proc_rate,trigger_result,trigger_duration,stacks_max
```

### Column Details

| Column | Type | Description | Requirements |
|--------|------|-------------|--------------|
| `skill_id` | String | Unique identifier | Must be unique across all skills |
| `name` | String | Display name | Any descriptive string |
| `damage_type` | String | Damage category | `Physical`, `Magic`, `Fire`, `Shadow`, etc. |
| `hits` | Int | Multi-hit attacks | Number of attacks in sequence |
| `description` | String | Flavor text | Human-readable description |
| `resource_cost` | Float | Resource required | Optional; leave as 0.0 for basic attacks |
| `cooldown` | Float | Cooldown duration (seconds) | Optional; leave as 0.0 for simple skills |
| `trigger_event` | String | When skill effects activate | e.g., "OnHit", "OnCrit", "OnSkillUsed" |
| `proc_rate` | Float | Chance to trigger (0.0-1.0) | Required for triggers |
| `trigger_result` | String | Effect to apply | Simple or "effect:parameter" format |
| `trigger_duration` | Float | Effect duration | In seconds |
| `stacks_max` | Int | Maximum effect stacks | For stacking triggered effects |

### Skill Examples

```csv
# Basic skills
basic_slash,Basic Slash,Physical,1,Basic physical attack that deals moderate damage.,0,1.0,,,,,

# Resource-costing skills with triggers
bleed_strike,Bleed Strike,Physical,1,Slash that causes bleeding DoT on critical hits.,15,3.0,OnCrit,0.8,apply_bleed,8.0,3
flame_burst,Flame Burst,Fire,1,Explosive fire damage that burns enemies.,25,4.0,OnHit,0.8,apply_burn_dot,6.0,3

# Special skills with complex effects
holy_shield,Holy Shield,Divine,1,Divine protection that blocks all damage for 3 seconds.,50,12.0,OnSkillUsed,1.0,apply_divine_shield,3.0,1
berserker_rage,Berserker Rage,Physical,1,Powerful rage-fueled attack with lifesteal.,40,7.0,OnHit,1.0,heal_self:0.2,0,0
teleport_strike,Teleport Strike,Physical,1,Teleport behind enemy for guaranteed hit.,30,5.0,OnHit,1.0,stun_target,2.0,1
```

---

## Status Effects and DoTs (`data/effects.csv`)

Define the actual effect mechanics that skills and affixes trigger.

### Format v2.0
```csv
effect_id,name,type,description,max_stacks,tick_rate,damage_per_tick,stat_multiplier,stat_add,visual_effect,duration
```

### Column Details

| Column | Type | Description | Requirements |
|--------|------|-------------|--------------|
| `effect_id` | String | Unique identifier | Must match skill/affix trigger_result references |
| `name` | String | Display name | Human-readable effect name |
| `type` | String | Effect category | `buff`, `debuff`, `dot`, `stun`, etc. |
| `description` | String | Flavor text | Human-readable description |
| `max_stacks` | Int | Maximum stack count | Non-negative integer |
| `tick_rate` | Float | Seconds between ticks | 0.0 for instant effects |
| `damage_per_tick` | Float | Damage per tick (negative = healing) | 0.0 for non-damage effects |
| `stat_multiplier` | Float | Multiplicative stat bonus | 1.0 = no change, 1.2 = +20% |
| `stat_add` | Float | Additive stat bonus | Direct stat addition |
| `visual_effect` | String | Visual effect asset | VFX name for rendering |
| `duration` | Float | Effect duration | In seconds |

### Effect Examples

```csv
# Damage over time effects
bleed,Bleeding DoT,debuff,Bleeding wound that deals physical damage over time.,10,1.0,8.0,0.0,0.0,"red_blood_particles",10.0
burn,Burning DoT,debuff,Flaming burn that deals fire damage over time.,8,2.0,4.0,0.0,0.0,"flame_particles",8.0
poison,Venom DoT,debuff,Venomous poison that deals nature damage over time.,12,1.5,6.0,0.0,0.0,"green_gas_cloud",12.0

# Stun effects
freeze,Frozen,stun,Frozen solid, preventing all movement and actions.,1,0.0,0.0,0.0,0.0,"ice_crystals",4.0
stun,Stunned,stun,Stunned and incapacitated, unable to act.,1,0.0,0.0,0.0,0.0,"yellow_stun_stars",3.0

# Stat modification effects
crit_bonus_drain,Focused Rage,buff,Increased critical strike chance.,1,0.0,0.0,0.0,25.0,"golden_buff_particles",5.0
divine_shield,Divine Protection,buff,Invulnerable to all damage.,1,0.0,0.0,1.0,0.0,"golden_shield",5.0
damage_amp_buff,Berserker Rage,buff,Increased damage output.,1,0.0,0.0,0.2,0.0,"red_aura",10.0

# Healing effects
heal_over_time_buff,Divine Blessing,buff,Heal over time.,5,2.0,-15.0,0.0,0.0,"healing_particles",10.0
lifesteal_buff,Vampiric Touch,buff,Life steal on attacks.,1,0.0,0.0,0.0,0.0,"blood_trail",8.0
```

---

## Loading and Integration

### Data Loading Process

After editing any CSV files, regenerate the master data:

```bash
python src/data_loader.py
```

This loads and validates all CSV data, caching it for runtime access.

### Runtime Integration

Use the MasterRuleData singleton for all content access:

```python
from src.data_loader import get_data_loader

loader = get_data_loader()

# Load content by ID
skill = loader.get_skill('berserker_rage')
affix = loader.get_affix('thornmail')
effect = loader.get_effect('bleed')

# Query by criteria
magic_skills = loader.find_skills_by_type('Magic')
weapon_affixes = loader.find_affixes_by_pool('weapon_pool')

# Get all content
all_skills = loader.get_all_skills()
all_effects = loader.get_all_effects()
```

### Equipment Integration

Items automatically use CSV-defined affixes when equipped:

```python
from src.models import Item

# Create item with CSV-defined affixes
item = Item(instance_id='sword1', base_id='berserker_sword',
           name='Berserker Sword', slot='weapon',
           rarity='Epic', quality_tier='Perfect',
           quality_roll=9,
           affixes=[loader.get_affix('berserker_rage')])

attacker.equip_item(item)
```

## Content Creation Workflow

### Step 1: Define Effect Mechanics
Start with effects.csv to define the actual mechanics:
```csv
reflect_buff,Thornmail Reflection,buff,Reflect percentage of blocked damage,1,0.0,0.0,0.0,0.0,"spike_aura",999.0
crit_buff,Focused Rage Bonus,buff,Temporary critical strike bonus,1,0.0,0.0,0.0,25.0,"golden_buff_particles",5.0
```

### Step 2: Create Affixes with Triggers
Define affixes that reference the effects:
```csv
thornmail,,,armor_pool,,,,OnBlock,0.5,reflect_buff,,,true,,
focused_rage,,,jewelry_pool,,,,OnSkillUsed,1.0,crit_buff,5.0,3,,true,special_skill
```

### Step 3: Design Skills (Optional)
Create skills that reference the effects:
```csv
focus_skill,Focus Strike,Physical,1,Charge up for special effects,20,0.0,OnSkillUsed,1.0,special_skill,0.0,1
```

### Step 4: Configure Equipment
Set up items that use the affixes:
```csv
base_thorn_armor,Thornmail Armor,Chest,Epic,armor_pool,thornmail,2
base_rage_amulet,Rage Amulet,Amulet,Rare,jewelry_pool,focused_rage,1
```

### Step 5: Regenerate and Test
```bash
python src/data_loader.py
python test_phase4.py
```

## Advanced Mechanics

### Scaling Power System
Scaling affixes grow stronger based on character power level:

```csv
# Character power = base_damage + health/10 + armor*2 + crit_chance*100 + pierce*1000
# Scaling multiplier = 1.0 + log(power_level + 1) * 0.1
berserker_rage,base_damage;crit_chance,scaling;scaling,jewelry_pool,0.5;0.3,{value}% Damage & Crit (scales with power),,,,,,,,,true,true
```

### Complex Trigger Effects
Advanced trigger parsing supports parameterized effects:

```csv
# Format: "effect_name:parameter"
reflect_damage:0.3      # Reflect 30% of blocked damage
apply_crit_bonus:0.25   # +25% crit chance bonus
heal_self:0.2          # Heal 20% of damage dealt
chain_damage:0.6       # 60% damage to adjacent targets
drain_life:0.05        # Drain 5% of target health per tick
bless_allies:0.3       # Heal nearby allies 30% of damage
stun_target            # Apply stun debuff
```

### Dual-Stat Affixes
Single affixes that modify multiple stats simultaneously:

```csv
# "stat1;stat2" with "value1;value2" and display {value}/{dual_value}
devastating_strikes,crit_chance;crit_damage,flat;flat,jewelry_pool,0.075;0.375,{value}% Crit & {dual_value}% Crit Damage,,,,,,,,true,
```

## Validation and Debugging

### Validation Checks
The system automatically validates:
- All trigger results reference valid effects
- All stat names match EntityStats attributes
- Numeric values are properly formatted
- Required columns are present

### Troubleshooting
```bash
# Check for data consistency issues
python -c "from src.data_loader import get_data_loader; loader = get_data_loader(); print(loader.validate_data_consistency())"

# Reload data after changes
python -c "from src.data_loader import reload_data; reload_data()"
```

### Testing Framework
```bash
# Test specific functionality
python test_trigger_parsing.py    # Test trigger parsing
python test_phase4.py            # Test master data system
python run_full_test.py          # Full integration test
```

## Data Flow Diagram

```
CSV Files â”€â”€â†’ Data Loader â”€â”€â†’ Validation â”€â”€â†’ Runtime Objects
    â†“              â†“              â†“                â†“
affixes.csv    AffixDefinition   Affix Objects     Entity.active_triggers
skills.csv     LoadedSkill       Skill Objects     Attack Calculations
effects.csv    EffectDefinition  Debuff Objects    Applied Effects
items.csv      Item Templates    Item Objects      Equipment Stats

Complex Effects: "effect:parameter" â†’ Parsed â†’ Applied to Target
Scaling Affixes: power_level â†’ multiplier â†’ enhanced values
Dual-Stat: "stat1;stat2" â†’ simultaneous modifications
```

## Validation Rules

The system enforces:
- All referenced affixes must exist
- All rarity tiers must be valid
- Stat names must match EntityStats attributes
- Equipment slots must be predefined
- No duplicate affix_ids or item_ids
- Numeric values must be valid floats/integers

## Testing Changes

Test new content:
```bash
# Run all tests
python -m pytest tests/ -v

# Test item generation
python demo_item.py
```

## System Mechanics

### Item Quality System
Items use a two-step generation process:
1. **Quality Tier Roll**: Rarity determines tier weighting (e.g., Mythic items favor "Masterful" tier)
2. **Quality Percentage**: Within tier, get random percentage (21-25% for "Fine" tier)

### Sub-Quality Variation
Each affix on an item rolls its own quality level (0 to item_quality_max%):
- **High-quality items** (90%+) can have affixes ranging from 0-90% power
- **Low-quality items** (30%) are limited to 0-30% on all affixes
- **Prevents identical items** while maintaining power hierarchy

### Affix Pools
- **Weapon affixes** go in `weapon_pool` for all weapons
- **Armor affixes** go in `armor_pool` for all armor pieces
- **Jewelry affixes** go in `jewelry_pool` for rings/amulets/necklaces
- **Specific pools** like `axe_pool`, `sword_pool` for weapon-specific effects

## Best Practices

- Use descriptive, consistent naming conventions
- Balance base_values appropriately for each stat
- Consider affinity pools carefully (general vs. slot-specific affixes)
- Test edge cases (Mythic items, full armor sets)
- Ensure new content integrates with existing balance



// =================================================================
// METADATA
// =================================================================
// File Path:      docs\Production_Ready_Engine.md
// Size:           4.66 KB
// Last Modified:  2025-11-17T19:30:25.224Z
// =================================================================

### **Project Plan: The Production-Ready Engine**

This document outlines the complete, three-phase plan to transform the combat engine into a robust, maintainable, and production-ready library. Each step is defined by a corresponding Pull Request (PR) that contains the detailed technical specifications for its implementation.

### **Phase 1: Foundational Stability & Correctness**

**Objective:** To fix all outstanding bugs, establish consistent architectural patterns, and harden the data pipeline. This phase ensures the codebase is correct and stable before new features are added.

*   **Step 1: Implement System-Wide Logging and API Hardening (`PR-P1S1`)**
    *   **Objective:** Eradicate all `print()` statements from the core library, establish a structured `logging` framework, and add a missing unit test to validate the `CombatEngine` API guard.
    *   **Key Deliverables:** A `print()`-free core library, a codebase that uses logging for all output, and a more robust test suite.

*   **Step 2: Correct Core Mechanics and Unify RNG (`PR-P1S2`)**
    *   **Objective:** Fix critical bugs in proc rates, dual-stat affixes, and core game logic. Unify the Random Number Generation (RNG) system to make all simulations fully deterministic and testable.
    *   **Key Deliverables:** Functional dual-stat affixes, data-driven proc rates, and a codebase capable of perfectly reproducible, seeded test runs.

*   **Step 3: Harden Data Pipeline with Strict Typing and Validation (`PR-P1S3`)**
    *   **Objective:** Enhance the data pipeline with `Enums`, typed data models, and a second validation layer that checks for logical cross-reference errors (e.g., a skill referencing a non-existent effect).
    *   **Key Deliverables:** A data pipeline that is validated for structure, type-safety, and logical integrity, preventing a wide class of data-related bugs.

### **Phase 2: New Feature Implementation**

**Objective:** To build major new engine features on top of the stable foundation established in Phase 1.

*   **Step 4: Implement Entity Lifecycle Management (`PR-P2S4`)**
    *   **Objective:** Introduce a formal, event-driven entity lifecycle (`OnSpawn`, `OnDeath`, `OnDespawn`) to correctly manage entity state, prevent memory leaks, and enable complex mechanics like on-death effects.
    *   **Key Deliverables:** A robust system that prevents "zombie" entities, automatically cleans up event listeners for dead units, and provides clear hooks for future gameplay features.

*   **Step 5: Build Simulation Batching and Telemetry System (`PR-P2S5`)**
    *   **Objective:** Create the tools to run thousands of deterministic simulations for balancing and regression testing. This includes implementing different telemetry (logging) modes and statistical aggregators.
    *   **Key Deliverables:** A `SimulationBatchRunner` capable of producing reliable, aggregated balance data (e.g., Time-To-Kill, DPS distributions) from high-volume, automated test runs.

### **Phase 3: Finalization & Professionalization**

**Objective:** To organize, document, and polish the entire project, transforming it into a professional-grade, distributable library.

*   **Step 6: Restructure Project and Integrate Tooling (`PR-P3S6`)**
    *   **Objective:** Reorganize the repository into a clean, modular directory structure and integrate standard Python development tools (`black`, `ruff`, `mypy`) to automate code quality and formatting.
    *   **Key Deliverables:** A well-organized repository and a `pyproject.toml` file that enforces consistent code style and quality across the entire project.

*   **Step 7: Create Final Integration Test for CI (`PR-P3S7`)**
    *   **Objective:** Create a single, definitive, end-to-end integration test that is fully deterministic and uses programmatic `assert` statements instead of `print` checks, making it suitable for a Continuous Integration (CI) pipeline.
    *   **Key Deliverables:** A "gold standard" test that serves as a reliable health check for the entire engine, guaranteeing that all core systems work together correctly.

*   **Step 8: Finalize Documentation and Project Polish (`PR-P3S8`)**
    *   **Objective:** Add comprehensive documentation at both the architectural level (in a `/docs` folder) and the code level (via docstrings), and create contributor guides to make the project accessible and maintainable.
    *   **Key Deliverables:** A fully documented project with a helpful `README.md`, architectural diagrams, and contributor guides (`CONTRIBUTING.md`, `CHANGELOG.md`).

---

By executing these eight PRs in sequence, the project will be methodically and robustly transformed into a stable, feature-rich, and professional combat engine.


// =================================================================
// METADATA
// =================================================================
// File Path:      memory-bank\activeContext.md
// Size:           7.30 KB
// Last Modified:  2025-11-19T10:48:05.037Z
// =================================================================

# Active Context: Combat Engine Development

## Current Work Focus

### Primary Active Task: PR-P2S4 - Entity Lifecycle Management

**Status**: Ready for Implementation
**Files in Active Development**:
- `src/state.py` (Lifecycle management logic)
- `src/events.py` (New lifecycle events)
- `tests/test_lifecycle.py` (New test file)

**Rationale**: With Phase 1 (Foundation) complete, we need to handle the creation and destruction of entities properly. Currently, entities can "die" (health <= 0), but their event listeners remain active, leading to zombie processes and memory leaks in long simulations.

## Recent Changes

### Version 2.2.1 (2025-11-19)
- **Phase 1 Complete**: All foundational stability PRs (P1S1, P1S2, P1S3) are merged and verified.
- **Data Hardening**: Strict typing and cross-reference validation active.
- **Core Mechanics**: Dual-stats and RNG injection implemented.
- **Logging**: System-wide logging replaces print statements in core library.

### Version 2.2.0 (2025-11-17)
- **Completed GDD v4.0 Combat Engine**: Full system delivery exceeding original IP scope
- **Advanced Dual-Stat Affixes**: Single affixes affecting multiple stats simultaneously
- **Complex Reactive Effects**: Advanced trigger parsing for reflected damage, crit bonuses
- **Master Rule Data System**: CSV-driven content creation framework
- **Production Validation**: 10-second simulation with full combat verification

### Version 2.1.0 (2025-11-17)
- **Architectural Overhaul**: Action/Result pattern implementation
- **CombatOrchestrator**: Decoupled execution with dependency injection
- **Effect System Generalization**: Data-driven DoT effects (Burn, Freeze, Poison)
- **GameDataProvider Singleton**: Centralized JSON loading with validation

### Version 2.0.0 (2025-11-17)
- **Phase 5 Complete**: Procedural Item Generator system
- **CSV-to-JSON Pipeline**: Affixes, items, and quality tiers parsing
- **Sub-Quality Variation**: Items with unique characteristics within quality ceilings

## Next Steps Priority Queue

### Immediate Next (PR-P1S3 Completion)

1. **PR-P2S4 Implementation**: Entity Lifecycle
   - Define `EntitySpawnEvent`, `EntityDeathEvent`, `EntityDespawnEvent`.
   - Update `StateManager` to trigger Death events automatically on 0 HP.
   - Implement `cleanup_entity` method to unsubscribe listeners.
   
2. **PR-P2S5 Implementation**: Simulation Batching
   - Create `BatchRunner` class.
   - Implement deterministic seed increments for batch runs.

## Active Decisions and Considerations

**Lifecycle Ownership**: `StateManager` will be the source of truth for an entity's lifecycle state.
**Event Cleanup**: Cleanup must be explicit (`OnDespawn`) rather than relying on Python's garbage collector, due to the EventBus circular references.

### RNG Policy Decision
**Decision**: Strict deterministic testing with injectable RNG instances only
**Rationale**: Balance validation requires perfectly reproducible simulations
**Implementation**: All random calls use injected `rng` parameter, defaulting to `random.random()` for production
**Trade-off**: Additional code complexity for dual test/production paths
**Critical Constraint**: NO global `random.seed()` usage anywhere in codebase

### Dual-Stat Affix Complexity
**Decision**: Support ";" separator in affix values for multiple stat modifications
**Implementation**: ItemGenerator rolls two separate values, Entity.calculate_final_stats applies both
**Rationale**: Richer itemization allowing synergies between related stats (damage + crit, armor + resistance)

### Effect System Architecture
**Decision**: Event-driven observer pattern over direct method calls
**Rationale**: Enables complex interactions (crit bonus triggering rage, blocking triggering rebuke)
**Current Challenge**: Finding balance between flexibility and debugging complexity

### Data Integration Strategy
**Decision**: Triple-layer validation (structure + cross-reference + type safety)
**Implementation**: schemas.py + cross-reference checks + mypy static analysis
**Value**: Catches typos, invalid references, and type mismatches before runtime

## Important Patterns and Preferences

### Combat Resolution Pattern
```
resolve_hit() â†’ gather_stats() â†’ calculate_damage() â†’ apply_effects() â†’ state_updates()
```
**Why**: Clear pipeline from raw stats to final result, easy debugging and testing

### RNG Usage Pattern
```python
def __init__(self, rng=None):
    self.rng = rng or random.random

def roll_critical_hit(self, chance):
    return self.rng() < chance
```
**Why**: Deterministic testing capability while maintaining production unpredictability

### Data Loading Pattern
```python
def load_game_data():
    raw = parse_csvs()
    validated = apply_schemas(raw)
    cross_referenced = validate_references(validated)
    typed = convert_to_models(cross_referenced)
    return typed
```
**Why**: Progressive validation catches different error types at appropriate stages

## Learnings and Project Insights

### Combat Formula Evolution
**Insight**: `MAX((Attack - Defense), (Attack Ã— Pierce))` creates meaningful armor investment decisions
**Learning**: Simple subtraction leads to binary (tank vs glass cannon) roles; pierce allows hybrid builds
**Application**: Future game design should emphasize pierce ratios over flat values

### Event System Complexity
**Insight**: Decoupled events enable emergent gameplay but create debugging challenges
**Learning**: Event chains (crit â†’ rage â†’ attack bonus) create unexpected player strategies
**Mitigation**: Comprehensive logging in EventBus for production debugging

### Testing ROI
**Insight**: Deterministic RNG enables property-based testing approaches
**Learning**: Seeded scenarios catch state mutation bugs that random tests miss
**Benefit**: Regression prevention more valuable than new feature implementation

### Data Integrity Investment
**Insight**: Triple validation (schema + cross-reference + type) prevents entire bug categories
**Learning**: Most runtime crashes originate from data inconsistencies, not code bugs
**ROI**: Time invested in validation infrastructure saves exponential debugging time

### Architecture Evolution
**Insight**: Pure functions + orchestrator pattern cleanly separates computation from side effects
**Learning**: Action/Result pattern provides perfect testability and Godot translation path
**Benefit**: Architecture decisions directly support both technical needs and future development

## Risk Mitigation

### Technical Debt Risks
- **RNG Injection Complexity**: Monitor for developer mistakes bypassing injection
- **Event Chain Complexity**: Keep event handlers focused on single responsibilities
- **Type Annotation Overhead**: Progressive adoption to avoid developer resistance

### Schedule Risks
- **Phase Completion Dependencies**: PR-P1S2 must complete before P1S3 implementation
- **Testing Time Underestimation**: Validation of deterministic systems requires extensive testing
- **Godot Port Translation**: Ensure Python architecture patterns remain GDScript-compatible

### Quality Risks
- **Performance Regression**: Frequent benchmarking against 6993 events/sec target
- **API Consistency**: Regular review of public interfaces for breaking changes
- **Documentation Drift**: Memory bank updates required for all significant changes



// =================================================================
// METADATA
// =================================================================
// File Path:      memory-bank\productContext.md
// Size:           4.96 KB
// Last Modified:  2025-11-18T19:36:04.568Z
// =================================================================

# Product Context: Combat Engine

## Why This Project Exists

### The Problem
Traditional RPG combat systems suffer from several limitations:
- **Predictable damage**: Simple `Attack - Defense` formulas lead to repetitive gameplay
- **Poor scaling**: Difficulty in balancing stats across large level ranges
- **Mechanical complexity**: Skills and effects often implemented as special cases rather than systemic rules
- **Balance issues**: Hard to validate combat mechanics without sophisticated testing tools
- **Maintenance burden**: Tight coupling between systems makes changes risky and time-consuming

### Gaps in Current Solutions
- Most game engines provide basic combat frameworks but lack deep simulation capabilities
- Existing RPG systems favor action-oriented combat over strategic depth
- Limited tools for procedural content generation and balance validation
- Insufficient emphasis on deterministic testing and reproducible results

## What the Combat Engine Solves

### Core Combat Innovation: Pierce-Based Damage
- **Pierce Ratio**: Allows weapons to bypass defense proportionally, enabling varied combat dynamics
- **Armor Investment**: Makes defense decisions meaningful without completely negating damage
- **Tactical Depth**: Weapons have different penetration characteristics, creating rock-paper-scissors balance

### Advanced Critical Hit System
- **Rarity Scaling**: Critical hits scale based on item/character rarity, encouraging progression
- **Predictable Variance**: Crit chances provide excitement without overwhelming determinism
- **Balance Safety**: Critical damage formulas prevent infinite damage scaling

### Event-Driven Effects Architecture
- **Compositional Complexity**: Skills and items can interact in emergent ways through events
- **Temporal Mechanics**: DoTs, buffs, and debuffs create time-based strategic decisions
- **State Management**: Clean separation between raw stats and derived combat effects

### Procedural Itemization
- **Thematic Affixes**: Items gain mechanical and flavorful properties based on type
- **Quality Tiers**: Clear progression paths with meaningful mechanical differences
- **Inventory Strategy**: Players must balance specialization vs flexibility

## How It Should Work

### User Experience Goals

#### For Game Developers
- **Easy Integration**: Drop-in combat system requiring minimal setup
- **Comprehensive Testing**: Built-in simulation tools for balance validation
- **Data-Driven Content**: All game mechanics defined in external configuration files
- **Deterministic Simulation**: Perfectly reproducible combat for debugging and balance

#### For Players
- **Tactical Combat**: Meaningful decisions about equipment, skills, and timing
- **Progressive Complexity**: Fun at casual level, depth for theorycrafters
- **Reliable Systems**: Combat feels fair and understandable, not random
- **Emergent Gameplay**: Unexpected interactions between items and skills create memorable moments

### Key User Flows

#### Character Build Process
1. **Stat Allocation**: Players distribute points across damage, defense, and special stats
2. **Equipment Selection**: Items provide multiplicative bonuses that scale with investment
3. **Skill Loadout**: Active abilities with complex trigger conditions and effects
4. **Theorycrafting**: Players can analyze optimal combinations through simulation

#### Combat Encounter
1. **Target Assessment**: Evaluation of enemy defenses and vulnerabilities
2. **Skill Sequencing**: Timing critical hits, DoT applications, and effect stacks
3. **Resource Management**: Managing health, mana, and temporary power sources
4. **Adaptive Tactics**: Switching strategies based on combat feedback

#### Balance Development
1. **Simulation Batches**: Running thousands of automated fights to gather statistics
2. **Statistical Analysis**: Time-to-kill distributions, DPS variance, effect uptime
3. **Parameter Tuning**: Adjusting formulas based on empirical data
4. **Regression Testing**: Ensuring changes don't break established balance

## Success Criteria

### Technical Excellence
- **Zero Bugs**: All identified bugs fixed, comprehensive test coverage
- **Performance**: Capable of supporting large-scale simulations and real-time combat
- **Maintainability**: Clean architecture allowing easy feature additions and modifications

### User Experience
- **Intuitive API**: Game developers can integrate combat system without deep study
- **Rich Feedback**: Combat results provide clear information about why outcomes occurred
- **Balance Transparency**: Mathematical relationships between stats are clear and predictable
- **Emergent Fun**: Players discover unexpected synergies and counterplay

### Ecosystem Value
- **Modding Support**: Easy to create custom items, skills, and balance modifications
- **Multi-platform**: GDScript port enables deployment across Godot's supported platforms
- **Community Resources**: Documentation and examples for common implementation patterns



// =================================================================
// METADATA
// =================================================================
// File Path:      memory-bank\progress.md
// Size:           8.49 KB
// Last Modified:  2025-11-19T10:48:17.853Z
// =================================================================

# Progress Report: Combat Engine Development

## Current Status Summary

**Version**: 2.2.1 (2025-11-19)
**Phase**: Phase 2: New Feature Implementation
**Status**: STARTING PR-P2S4 (Entity Lifecycle Management)

### Overall Progress: 75% Complete

## What Works (âœ… Fully Implemented & Tested)

### Phase 1: Foundational Stability (COMPLETE)
- **âœ… PR-P1S1**: System-wide logging and API hardening.
- **âœ… PR-P1S2**: Core mechanics, RNG injection, and dual-stat affix logic.
- **âœ… PR-P1S3**: Data pipeline hardening with strict typing and cross-reference validation.
- **âœ… Engine Refactor**: Namespace shadowing resolved (`src/engine/core.py`).

### Phase 2: New Feature Implementation (0% Complete)
- **â³ PR-P2S4**: Entity lifecycle management (Planned)
- **â³ PR-P2S5**: Simulation batching and telemetry system (Planned)

### Phase 3: Finalization & Professionalization (0% Complete)
- **â³ PR-P3S6**: Project restructuring and tooling integration
- **â³ PR-P3S7**: Final integration test for CI
- **â³ PR-P3S8**: Documentation and project polish

## Core Combat Systems (âœ… Complete)

### âœ… Combat Resolution Pipeline
- **Pierce-based damage formula**: `MAX((Attack - Defense), (Attack Ã— Pierce))`
- **Multi-tier critical hits**: Rarity-based scaling (Commonâ†’Mythic)
- **Defensive calculations**: Armor reduction, damage thresholds, glancing blows
- **Evasion mechanics**: Full evasionâ†’dodgeâ†’blockâ†’damage resolution sequence
- **Performance**: <1ms per hit resolution

### âœ… Event-Driven Architecture
- **EventBus system**: Decoupled event dispatching and handling
- **Effect triggering**: OnHit, OnDamage, OnCrit, OnBlock, OnDodge events
- **DoT system**: Tick-based damage over time effects (Bleed, Poison, Burn)
- **Skill integration**: Multi-hit skills with complex trigger conditions
- **State management**: Entity health tracking with effect application

### âœ… Data-Driven Content
- **CSV data pipeline**: Skills, effects, items, affixes configured externally
- **Runtime validation**: Schema enforcement and basic integrity checks
- **Content creation**: Add new skills/effects without code changes
- **Dynamic loading**: Hot-reload capability for game data

### âœ… Itemization & Equipment
- **Procedural generation**: Quality-tiered items with random affixes
- **Stat modification**: Flat bonuses and percentage multipliers
- **Dual-stat affixes**: Single affixes affecting multiple related stats
- **Equipment integration**: Real-time stat calculation based on gear

### âœ… Simulation Framework
- **Time-based simulation**: Delta-time processing with 6993 events/sec
- **Deterministic scenarios**: Seeded RNG for reproducible testing
- **Balance analysis**: CombatLogger with detailed metrics and reporting
- **Statistical validation**: Automated scenario testing for balance tuning

### âœ… Testing Infrastructure
- **96+ Unit Tests**: 100% pass rate across all systems
- **Integration Testing**: End-to-end scenario validation
- **Deterministic Testing**: Seeded simulations for regression prevention
- **Performance Benchmarking**: Automated performance validation

## What's Left to Build (â³ Planned Implementation)

### Immediate Priority (Phase 2 Completion)
1. **Entity Lifecycle Management** (Phase 2S4)
   - OnSpawn, OnDeath, OnDespawn events with cleanup
   - Memory leak prevention for dead entity references
   - State reset and initialization hooks

2. **Advanced Simulation Tools** (Phase 2S5)
   - BatchRunner for thousands of automated simulations
   - Statistical aggregators (DPS distributions, Time-To-Kill)
   - Balance recommendation system

### Long-term Goals (Phase 3)
3. **Project Professionalization** (Phase 3S6)
   - Repository restructuring with proper tooling
   - black/isort/mypy/pre-commit integration
   - Automated code quality enforcement

4. **Production Validation** (Phase 3S7)
   - Definitive end-to-end integration test for CI
   - Assert-based validation replacing print checks
   - Gold standard test serving as health check

5. **Godot Ecosystem Preparation** (Phase 3S8)
   - GDScript port planning and architecture translation
   - Documentation finalization (API references, guides)
   - Content creation tool preparation

## Known Issues and Bugs (ðŸ› Active Tracking)

### Critical (Blockers)
- **Proc Rate Hardcoded**: Skills use 50% proc instead of data-driven values
- **Dual-Stat Affixes Broken**: Second stat modifications not applying correctly
- **RNG Unseeded**: Non-deterministic behavior in tests and simulations
- **Resource Bug**: Attackers gain resources when attacks are dodged (wrong)

### Major (Should Fix)
- **Data Integrity Gaps**: No validation that skill effects actually exist
- **Print Statements**: 25+ print() calls need replacement with logging
- **API Test Coverage**: CombatEngine missing unit tests for guard conditions

### Minor (Nice to Fix)
- **Performance Optimization**: Event overhead in high-frequency scenarios
- **Error Messages**: Some validation errors lack context for debugging
- **Documentation Drift**: Some new features not reflected in docs

## Testing Status

### Current Test Statistics
- **Total Tests**: 96+ unit tests
- **Pass Rate**: 100% on all implemented systems
- **Coverage**: >95% on critical combat systems
- **Performance**: All tests run in <5 seconds

### Testing Capabilities
- **Unit Tests**: Individual function validation with mocked dependencies
- **Integration Tests**: Full system behavior with CSV data loading
- **Simulation Tests**: Time-based combat with event processing
- **Deterministic Tests**: Seeded RNG ensuring reproducible results

### Testing Gaps (Needs Attention)
- **PR-P1S3 Features**: Cross-reference validation tests are being implemented
- **PR-P1S2 Features**: No tests yet for data-driven proc rates
- **Dual-Stat Logic**: Missing validation for multi-stat modifications
- **RNG Determinism**: End-to-end seeded simulation tests incomplete

## Performance Metrics

### Current Achievements
- **Combat Resolution**: <1ms per hit (includes pierce, crit, defense, effects)
- **Simulation Throughput**: 6993 events/second with logging enabled
- **Data Loading**: <5 seconds for full game data initialization
- **Test Execution**: Complete test suite in <30 seconds

### Performance Goals
- **Real-time Target**: 60+ combat calculations per second
- **Simulation Target**: 10000+ events/second for balance validation
- **Startup Target**: <3 seconds for game data loading
- **Memory Target**: <100MB for full simulation with 1000+ entities

## Quality Assurance

### Code Quality Metrics
- **Type Hints**: Required on all public functions (partially complete)
- **Documentation**: Docstrings on all classes and methods (mostly complete)
- **Linting**: Zero flake8/pylint violations (needs validation)
- **Cyclomatic Complexity**: Keep all functions under 10 branches

### Architecture Quality
- **Separation of Concerns**: Combat math separated from engine logic âœ…
- **Dependency Injection**: RNG and data providers injected cleanly âœ…
- **Event Decoupling**: Combat resolution independent of effect application âœ…
- **Testability**: Pure functions with minimal side effects âœ…

## Risk Assessment

### High Risk Items
- **Phase Dependencies**: Each PR builds on previous fixes - delays compound
- **Godot Translation**: Python patterns must be GDScript-compatible
- **Balance Complexity**: More systems = exponential balance validation needs
- **Data Integrity**: Expanded content system increases typo/debugging risks

### Mitigation Strategies
- **Incremental Implementation**: Small, testable PRs with full validation
- **Architecture Continuity**: Python design patterns chosen for GDScript compatibility
- **Simulation Tools**: Automated testing prevents manual balance regression
- **Validation Layers**: Triple-checking system catches data errors early

## Success Indicators

### Phase 1 Success Criteria
- [ ] **Determinism Achieved**: Same inputs produce identical simulation results
- [ ] **Data Integrity**: All CSV relationships validated at load time
- [ ] **API Hardening**: No print statements, full logging framework
- [ ] **Testing Complete**: 100% coverage with deterministic validation

### Project Success Criteria
- [ ] **Godot Port**: Clean translation maintaining all Python functionality
- [ ] **Performance**: Real-time combat + fast simulation balancing
- [ ] **Maintainability**: New features addable without code changes
- [ ] **Documentation**: Professional-level docs with API references



// =================================================================
// METADATA
// =================================================================
// File Path:      memory-bank\projectbrief.md
// Size:           1.94 KB
// Last Modified:  2025-11-18T19:35:44.996Z
// =================================================================

# Combat Engine Project Brief

## Overview
A modular combat system for dungeon crawler RPGs featuring sophisticated damage calculations, character progression, and itemization systems.

## Core Mission
To implement a complete RPG combat system with pierce-based damage calculation, multi-tier critical hits, event-driven effects, dynamic itemization, and time-based simulation for DoTs, duration management, and temporal effects.

## Key Features
- Pierce-based damage formula: `MAX((Attack Damage - Defense), (Attack Damage Ã— Pierce Ratio))`
- Rarity-based critical hit scaling (Commonâ†’Mythic)
- Event-driven effects system for DoTs, buffs, and skill interactions
- Thematic affix pools with equipment mechanics
- DoT ticks, duration management, and temporal effects

## Architecture Principles
- Data-driven design with all game content in external data structures
- Event-driven architecture with loose coupling through observer pattern
- Deterministic results for testing and balance validation
- Modular systems for easy maintenance and extension

## Development Status
- Python prototype: Complete and fully tested (96 unit tests)
- Godot port: Ready for implementation
- Test coverage: >95% on critical systems
- Performance: 6993 events/second in simulation

## Project Goals
1. Transform into production-ready, maintainable library through 8-phase plan
2. Port core systems to GDScript
3. Implement UI and visual feedback
4. Add content creation tools
5. Optimize performance for target platforms

## Critical Requirements
- **RNG Policy**: All combat RNG must be deterministic in tests and injectable in production. No global seeding permitted.
- **Test Determinism**: Same inputs always produce same outputs for reproducible tests and balance validation
- **Code Quality**: Type hints, comprehensive docstrings, unit tests for all functionality
- **Data Integrity**: Strict typing and validation with logical cross-reference checks



// =================================================================
// METADATA
// =================================================================
// File Path:      memory-bank\systemPatterns.md
// Size:           8.24 KB
// Last Modified:  2025-11-18T19:36:23.863Z
// =================================================================

# System Patterns: Combat Engine Architecture

## Core Architecture Overview

The Combat Engine follows a modular, event-driven architecture with clear separation of concerns and deterministic behavior for testing and simulation.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Game Data     â”‚â”€â”€â”€â–¶â”‚   State         â”‚â—€â”€â”€â–¶â”‚   Engine        â”‚
â”‚   (External)    â”‚    â”‚   Management    â”‚    â”‚   (Combat)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â–²                       â”‚
         â–¼                       â”‚                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Event Bus     â”‚â—€â”€â”€â–¶â”‚   Effect        â”‚â—€â”€â”€â–¶â”‚   Combat        â”‚
â”‚   (Decoupling)  â”‚    â”‚   Handlers      â”‚    â”‚   Resolution    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Key Design Patterns

### 1. Data-Driven Architecture Pattern
- **Pattern**: All game content defined externally in structured data files
- **Implementation**: CSV for tabular data, JSON for complex relationships
- **Benefits**: Easy content iteration, no code changes for balance tweaks
- **Critical Path**: `src/data/schemas.py` enforces structure, `src/game_data_provider.py` loads and validates

### 2. Event-Driven Observer Pattern
- **Pattern**: Loose coupling through publish-subscribe event system
- **Implementation**: `EventBus` class with event types and handler registration
- **Benefits**: Effects can interact without direct dependencies, easy testing
- **Critical Path**: Events like `OnHit`, `OnDamage`, `OnTick` drive DoTs and skill triggers

### 3. State Manager Pattern
- **Pattern**: Centralized state tracking with controlled mutations
- **Implementation**: `StateManager` class tracks entity health, active effects
- **Benefits**: Predictable state changes, easy rollback for testing
- **Critical Path**: Prevents race conditions in multi-effect scenarios

### 4. RNG Injection Pattern
- **Pattern**: Deterministic random number generation with external control
- **Implementation**: All random calls use injected `rng` parameter, defaults to `random.random`
- **Benefits**: Perfect test reproducibility, seeded simulations
- **Critical Path**: Every `random()` call must be injected, no global `random.seed()`

### 5. Hit Resolution Pipeline Pattern
- **Pattern**: Modular damage calculation through chained computations
- **Implementation**: `CombatEngine.resolve_hit()` orchestrates stat gathering, formula application, effect application
- **Benefits**: Clear separation of calculation phases, easy debugging
- **Critical Path**: Pierce formula, crit calculation, defensive calculations in sequence

## Component Relationships

### Core Combat Flow
```
Entity Stats â”€â”€â–¶ Combat Math â”€â”€â–¶ Hit Context â”€â”€â–¶ Effect Application
     â”‚                â”‚                â”‚                â”‚
     â–¼                â–¼                â–¼                â–¼
Entity Base â”€â”€â–¶ Damage Formula â”€â–¶ Crit Scaling â”€â”€â–¶ State Updates
```

### Data Pipeline
```
Raw CSV â”€â”€â–¶ Data Parser â”€â”€â–¶ Typed Models â”€â”€â–¶ Validation â”€â”€â–¶ Game Data Provider
     â”‚           â”‚              â”‚              â”‚              â”‚
     â–¼           â–¼              â–¼              â–¼              â–¼
Effects â”€â”€â–¶ Schema â”€â”€â–¶ Pydantic â”€â”€â–¶ Cross-Ref â”€â”€â–¶ Runtime Access
```

## Critical Implementation Paths

### 1. Combat Resolution Path
**Purpose**: Calculate final damage from attacker to defender with all modifiers
```
resolve_hit(attacker, defender, state_manager)
â”œâ”€â”€ gather_combat_stats()           # Combine entity + equipment stats
â”œâ”€â”€ calculate_raw_damage()          # Base damage + pierce formula
â”œâ”€â”€ apply_critical_hit()           # Rarity-based crit scaling
â”œâ”€â”€ apply_defensive_calcs()        # Armor reduction + thresholds
â”œâ”€â”€ create_hit_context()           # Bundle results for effects
â””â”€â”€ apply_effects()                # Event-driven effect application
```

### 2. Effect Processing Path
**Purpose**: Handle DoTs, buffs, and triggered abilities
```
process_effect_application(hit_context, event_bus)
â”œâ”€â”€ dispatch_hit_events()           # OnHit, OnDamage, etc.
â”œâ”€â”€ evaluate_triggers()            # Check proc conditions
â”œâ”€â”€ calculate_effect_strength()    # Stack scaling, duration
â”œâ”€â”€ update_entity_state()          # Apply to StateManager
â””â”€â”€ schedule_cleanup()             # Tick timers, removal
```

### 3. Skill Execution Path
**Purpose**: Multi-hit skills with complex trigger conditions
```
process_skill_use(attacker, defender, skill)
â”œâ”€â”€ validate_skill_requirements()   # Cooldowns, resources
â”œâ”€â”€ execute_hit_sequence()         # Multiple resolve_hit() calls
â”œâ”€â”€ aggregate_damage()             # Total damage tracking
â”œâ”€â”€ apply_skill_effects()          # Unique skill abilities
â””â”€â”€ update_cooldowns()             # Prevent spam usage
```

### 4. Data Loading Path
**Purpose**: Load and validate all game content at startup
```
initialize_game_data()
â”œâ”€â”€ load_csv_files()               # pandas/csv parsing
â”œâ”€â”€ validate_structure()           # Schema enforcement
â”œâ”€â”€ cross_reference_check()        # ID integrity validation
â”œâ”€â”€ build_derived_data()           # Computed relationships
â””â”€â”€ cache_for_runtime()            # Fast lookup structures
```

## Key Technical Decisions

### Damage Formula Choice
**Decision**: `MAX((Attack - Defense), (Attack Ã— Pierce))` over linear reduction
**Rationale**: Allows weapons to "punch through" defense without ignoring investment
**Trade-offs**: More complex than simple subtraction, but richer gameplay
**Implementation**: `src/combat_math.py::calculate_damage()`

### Event Bus vs Direct Calls
**Decision**: Observer pattern over method chaining for effects
**Rationale**: Enables buffs/debuffs to interact without tight coupling
**Trade-offs**: Indirect control flow harder to debug, but flexible composition
**Implementation**: `src/events.py::EventBus`

### Pydantic vs Plain Classes
**Decision**: Runtime type validation over simple dataclasses
**Rationale**: Catches data errors early, provides clear error messages
**Trade-offs**: Slight performance cost, but critical for data integrity
**Implementation**: `src/data/typed_models.py`

### Simulation vs Real-time Balance
**Decision**: Support both deterministic testing and live randomization
**Rationale**: Balance requires reproducible testing, gameplay needs unpredictability
**Trade-offs**: Dual code paths increase complexity, but necessary for quality
**Implementation**: RNG injection pattern throughout codebase

## Critical Failure Points

### RNG Non-Determinism
**Risk**: Hard-to-reproduce bugs caused by unseeded random calls
**Mitigation**: Static analysis to find bare `random()` calls, injected RNG requirement
**Detection**: Test failures that don't reproduce locally

### State Mutation Race Conditions
**Risk**: Multiple effects modifying entity state simultaneously
**Mitigation**: All state changes through StateManager, event ordering preserved
**Detection**: Integration tests with complex multi-effect scenarios

### Data Reference Invalidity
**Risk**: Skills referencing non-existent effects, items using invalid stats
**Mitigation**: Schema validation + cross-reference checking at load time
**Detection**: Data loading failures with detailed error messages

### Performance Degradation
**Risk**: Event system overhead in high-frequency combat scenarios
**Mitigation**: Event batching, efficient lookups, profiling-driven optimization
**Detection**: Performance benchmarks in simulation runs



// =================================================================
// METADATA
// =================================================================
// File Path:      memory-bank\techContext.md
// Size:           7.71 KB
// Last Modified:  2025-11-18T19:36:44.415Z
// =================================================================

# Technical Context: Combat Engine

## Technology Stack

### Core Runtime Environment
- **Language**: Python 3.8+ (type hints, dataclasses, modern syntax)
- **Package Manager**: pip with `requirements.txt`
- **Virtual Environment**: venv (Windows: `venv\Scripts\activate`)
- **Platform Support**: Cross-platform (Windows/macOS/Linux via Godot target)

### Testing & Validation
- **Test Framework**: pytest with coverage reporting (`--cov=src --cov-report=html`)
- **Deterministic RNG**: Custom fixtures for seeded random number generation
- **CI/CD**: Designed for integration with GitHub Actions or similar
- **Performance Benchmarking**: Simulation-based testing with 6993 events/sec target

### Data Processing
- **Tabular Data**: pandas for CSV parsing and manipulation
- **Schema Validation**: Pydantic V2 for runtime type checking and model validation
- **Configuration**: JSON for complex relationships, CSV for bulk data
- **Data Integrity**: Custom validation layers for cross-reference checking

### Development Tools
- **Code Quality**: black (formatting), ruff (linting), mypy (static type checking)
- **IDE**: Visual Studio Code with Python extensions
- **Version Control**: Git with conventional commit message standards
- **Documentation**: Markdown-based docs with Mermaid diagrams

## Development Setup Requirements

### System Prerequisites
```bash
# Python 3.8 or higher
python --version  # Must be 3.8+

# Git for version control
git --version

# Virtual environment support (usually included)
python -m venv --help
```

### Dependency Installation
```bash
# Create virtual environment
python -m venv venv

# Activate virtual environment
# Windows:
venv\Scripts\activate
# Unix/macOS:
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt
```

### Core Dependencies Breakdown
```
pandas>=1.3.0         # CSV processing, data manipulation
pydantic>=2.0.0       # Runtime validation, type enforcement
pytest>=7.0.0         # Test framework with fixtures
pytest-cov>=4.0.0     # Coverage reporting
mypy>=1.0.0           # Static type checking
black>=22.0.0         # Code formatting
ruff>=0.1.0           # Fast linting
```

## Technical Constraints

### Performance Requirements
- **Simulation Speed**: 6993 events/second minimum for balance validation
- **Memory Usage**: Must support thousands of entity simulations simultaneously
- **Startup Time**: Data loading and validation under 5 seconds for development iteration
- **Real-time Combat**: Support 60+ combat calculations per second for live gameplay

### Determinism Requirements
- **Test Reproducibility**: Same inputs always produce identical outputs
- **No Global State**: RNG must be injected, no global random seeding
- **Order Independence**: Event processing order must not affect final results
- **Seed Management**: Support for replayable combat scenarios

### Data Integrity Constraints
- **Schema Enforcement**: All data structures validated at load time
- **Cross-Reference Validation**: IDs must resolve to valid objects
- **Type Safety**: Runtime type checking prevents invalid data combinations
- **Backward Compatibility**: New versions must support existing data formats

### Code Quality Standards
- **Type Hints**: Required on all public functions and complex logic
- **Documentation**: Comprehensive docstrings with examples
- **Test Coverage**: >95% on critical systems, full integration coverage
- **Linting Compliance**: Zero ruff/black violations in CI

## Development Workflow Patterns

### Testing Patterns
```python
# Deterministic unit test
def test_damage_calculation(make_rng):
    engine = CombatEngine(rng=make_rng(42))
    result = engine.calculate_damage(attacker, defender)
    assert result == expected_value  # Always reproducible

# Integration test with fixtures
def test_full_combat_flow(make_attacker, make_defender, make_rng):
    # Set up full combat scenario
    # Verify end-to-end behavior
```

### Data Loading Pattern
```python
# Always validate data at load time
def load_game_data():
    data = GameDataLoader.load_from_files()
    validator = DataValidator()
    validator.validate_structure(data)
    validator.check_cross_references(data)
    return data
```

### RNG Usage Pattern
```python
# Never use global random
def roll_critical_hit(crit_chance: float, rng: Callable[[], float]) -> bool:
    return rng() < crit_chance

# Allow default for production
def __init__(self, rng: Optional[Callable[[], float]] = None):
    self.rng = rng or random.random
```

### State Management Pattern
```python
# Centralized state mutations
def apply_damage(entity_id: str, damage: float, state_manager: StateManager):
    current_health = state_manager.get_health(entity_id)
    new_health = max(0, current_health - damage)
    state_manager.update_health(entity_id, new_health)
    # All state changes go through manager
```

## Key Tool Usage Patterns

### pytest Testing Patterns
- **Unit Tests**: Focused on individual functions, heavy use of fixtures
- **Integration Tests**: Full system behavior, deterministic RNG throughout
- **Performance Tests**: Time budgeted assertions, simulation batch testing
- **Data Tests**: CSV/JSON validation, cross-reference integrity

### pandas Data Processing Patterns
- **CSV Loading**: `pd.read_csv()` with dtype specification for memory efficiency
- **Data Validation**: Custom validation functions applied to DataFrames
- **Lookup Tables**: Dictionary-based caching for runtime performance
- **Data Transformation**: Vectorized operations where possible

### Pydantic Model Patterns
- **Validation Models**: Strict typing with custom validators where needed
- **Serialization**: JSON-compatible models for configuration files
- **Error Messages**: Descriptive validation errors for debugging
- **Nested Models**: Complex relationships represented hierarchically

### Event System Patterns
- **Event Registration**: Handlers register interest in specific event types
- **Event Dispatch**: Batch processing to prevent re-entrancy issues
- **Handler Isolation**: Each handler receives immutable event data
- **Cleanup**: Event listener removal when objects are destroyed

## Known Technical Challenges

### Current Workarounds
- **Pydantic Performance**: Large data files may require streaming validation
- **Event Overhead**: High-frequency events batched to reduce function call overhead
- **Memory Usage**: Data structures optimized for simulation workloads

### Future Considerations
- **Godot Port**: GDScript translation maintaining same architecture patterns
- **Multi-threaded Simulation**: Parallel combat simulation for faster balancing
- **Network Play**: Deterministic combat for multiplayer synchronization
- **Save/Load**: Serializable state for persistent game sessions

### Performance Optimizations Applied
- **Data Caching**: Pre-computed lookup tables for runtime speed
- **Lazy Evaluation**: Expensive calculations deferred until needed
- **Batch Processing**: Group similar operations for vectorization
- **Memory Pooling**: Reuse allocated objects in simulation loops

## Integration Points

### Data Pipeline Integration
- External CSV/JSON files loaded through `game_data_provider.py`
- Validation occurs at application startup
- Runtime data access through typed interfaces

### Engine Integration
- Combat calculations accessible through `CombatEngine` API
- Event system integration through `EventBus` interfaces
- State management through `StateManager` for persistence

### Testing Integration
- Test fixtures provide consistent data for all test scenarios
- RNG injection enables deterministic behavior in CI/CD
- Coverage reporting integrated with development workflow



// =================================================================
// METADATA
// =================================================================
// File Path:      MIGRATION_PR8.md
// Size:           6.18 KB
// Last Modified:  2025-11-17T13:47:03.035Z
// =================================================================

# Migration Guide for PR8a â†’ PR8c

## Breaking Changes in PR8c - Strict Mode Enforcement

PR8c implements **strict entity registration enforcement** by default. All effects, health modifications, and state queries now require entities to be registered first via `add_entity()`.

### Summary of Breaking Changes

- **`strict_mode=True`** set by default in `StateManager.__init__()`
- **KeyError** thrown when referencing unregistered entities
- **No automatic entity creation** - all entities must be explicitly registered
- Backwards compatibility **completely removed** - migration required

---

## ðŸ”´ 1. All Entities Must Be Registered First

### Before (PR8a/PR8b backward-compatible mode):
```python
# Worked in legacy mode - auto-created entities
state.apply_effect("player1", effect)
state.apply_damage("player1", 10)
```

### After (PR8c strict mode):
```python
# Must register first
state.add_entity(player_entity)
state.apply_effect("player1", effect)
state.apply_damage("player1", 10)
```

**Migration Required:** Add `state.add_entity(entity)` calls before any entity operations.

---

## ðŸ”´ 2. Direct Dict Access Completely Removed

### Before:
```python
# Direct access to internal data structures
for eff in state.effects[entity_id]:
    pass

state.effects[entity_id].append(effect)
state.entities[entity_id] = new_state
```

### After:
```python
# Use new API methods
for eff in state.iter_effects(entity_id):
    pass

state.apply_effect(entity_id, effect)
state.add_entity(entity)
```

**Migration Required:** Replace all `state.entities[...]` and `state.effects[...]` with StateManager API calls.

---

## ðŸ”´ 3. Effect Handlers Must Use Unified Signature

### Before:
```python
def apply_bleed(attacker, target, effect):
    target.hp -= effect.value
```

### After:
```python
def apply_bleed(attacker, target, effect, rng, state_manager):
    actual_damage = state_manager.apply_damage(target.id, effect.value)
```

**Migration Required:** Update all 24+ effect handlers to use unified signature pattern.

---

## ðŸ”´ 4. CombatEngine Uses StateManager Exclusively

### Before:
```python
class CombatEngine:
    def __init__(self, state):
        self.state = state  # Direct dict access

    def apply_hit(self, target_id, damage):
        self.state.entities[target_id].hp -= damage  # Direct mutation
```

### After:
```python
class CombatEngine:
    def __init__(self, state_manager):
        self.state_manager = state_manager  # Dependency injection

    def apply_hit(self, target_id, damage):
        self.state_manager.apply_damage(target_id, damage)  # Pure function
```

**Migration Required:** Inject `StateManager` instead of direct state dict, use API methods.

---

## ðŸ”´ 5. Orchestrator Updates All Methods

### Before:
```python
class CombatOrchestrator:
    def process_effects(self, entity_id):
        for eff in self.state.effects.get(entity_id, []):
            self.effect_handlers[eff.id](attacker, target, eff)
```

### After:
```python
class CombatOrchestrator:
    def process_effects(self, entity_id):
        for eff in self.state_manager.iter_effects(entity_id):
            # Handlers now get state_manager reference
            self.effect_handlers[eff.id](attacker, target, eff, self.rng, self.state_manager)
```

**Migration Required:** Update all orchestrator methods to use StateManager API and unified handler signatures.

---

## ðŸ”´ 6. Simulation Centralized Tick Processing

### Before:
```python
class BattleSimulation:
    def run_frame(self, delta):
        # Inline DoT processing
        for entity in self.entities:
            for eff in self.state.effects.get(entity.id, []):
                if eff.tick_timer <= 0:
                    self.apply_dot_damage(entity.id, eff.value)
```

### After:
```python
class BattleSimulation:
    def run_frame(self, delta):
        # Single centralized tick
        self.state_manager.update(delta, self.event_bus)
```

**Migration Required:** Remove inline effect processing loops, rely on `state_manager.update()` for all timing.

---

## ðŸ”´ 7. Test Updates Required

### Before:
```python
def test_some_combat_logic():
    state = StateManager()
    state.effects['player1'] = [some_effect]  # Direct setting
    state.entities['player1'] = EntityState()  # Direct setting
```

### After:
```python
def test_some_combat_logic():
    state = StateManager()
    # Use helper methods
    player = make_entity('player1')
    state.add_entity(player)
    state.apply_effect('player1', some_effect)
```

**Migration Required:** Replace all direct dict writes with StateManager API calls, use test fixtures.

---

## ðŸŸ¡ Transitional Configuration (Not Recommended)

If you absolutely need backward compatibility during transition:

```python
# WARNING: This will be removed in future versions
state = StateManager(strict_mode=False)
```

---

## âœ… Recommended Migration Steps

1. **Start with tests**: Update all test files to use new API
2. **Migrate effect handlers**: Update signatures and implementations
3. **Update CombatEngine**: Replace direct state access with StateManager calls
4. **Update CombatOrchestrator**: Inject StateManager, use new API
5. **Update Simulation**: Remove inline effect loops
6. **Add entity registration**: Ensure all entities are registered before use
7. **Verify**: Run full test suite to ensure correctness

---

## ðŸ” Verification

After migration, all functionality should work identically but with:
- Better type safety
- Proper separation of concerns
- Easier testing with deterministic state
- Clearer interfaces
- Godot port compatibility

---

## ðŸ“š Reference

- **Current API**: See `StateManager` class docstring
- **Effect Patterns**: Check updated handler examples
- **Test Fixtures**: Use `make_entity()` and `make_effect()` helpers
- **PR8c Docs**: Review `docs/meta_docs/PR8c.md` for detailed requirements

---

**Migration Priority:** HIGH - These are breaking changes that affect all subsystems.
**Estimated Effort:** 4-6 hours for complete codebase migration.
**Backwards Compatibility:** None - clean break to ensure consistency.



// =================================================================
// METADATA
// =================================================================
// File Path:      package-lock.json
// Size:           5.70 KB
// Last Modified:  2025-11-18T19:59:48.509Z
// =================================================================

{
  "name": "combat_engine",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "dependencies": {
        "yargs": "^18.0.0"
      }
    },
    "node_modules/ansi-regex": {
      "version": "6.2.2",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/ansi-styles": {
      "version": "6.2.3",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/cliui": {
      "version": "9.0.1",
      "resolved": "https://registry.npmjs.org/cliui/-/cliui-9.0.1.tgz",
      "integrity": "sha512-k7ndgKhwoQveBL+/1tqGJYNz097I7WOvwbmmU2AR5+magtbjPWQTS1C5vzGkBC8Ym8UWRzfKUzUUqFLypY4Q+w==",
      "license": "ISC",
      "dependencies": {
        "string-width": "^7.2.0",
        "strip-ansi": "^7.1.0",
        "wrap-ansi": "^9.0.0"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/emoji-regex": {
      "version": "10.6.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-10.6.0.tgz",
      "integrity": "sha512-toUI84YS5YmxW219erniWD0CIVOo46xGKColeNQRgOzDorgBi1v4D71/OFzgD9GO2UGKIv1C3Sp8DAn0+j5w7A==",
      "license": "MIT"
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/get-caller-file": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
      "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
      "license": "ISC",
      "engines": {
        "node": "6.* || 8.* || >= 10.*"
      }
    },
    "node_modules/get-east-asian-width": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/get-east-asian-width/-/get-east-asian-width-1.4.0.tgz",
      "integrity": "sha512-QZjmEOC+IT1uk6Rx0sX22V6uHWVwbdbxf1faPqJ1QhLdGgsRGCZoyaQBm/piRdJy/D2um6hM1UP7ZEeQ4EkP+Q==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/string-width": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-7.2.0.tgz",
      "integrity": "sha512-tsaTIkKW9b4N+AEj+SVA+WhJzV7/zMhcSu78mLKWSk7cXMOSHsBKFWUs0fWwq8QyK3MgJBQRX6Gbi4kYbdvGkQ==",
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^10.3.0",
        "get-east-asian-width": "^1.0.0",
        "strip-ansi": "^7.1.0"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/strip-ansi": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-9.0.2.tgz",
      "integrity": "sha512-42AtmgqjV+X1VpdOfyTGOYRi0/zsoLqtXQckTmqTeybT+BDIbM/Guxo7x3pE2vtpr1ok6xRqM9OpBe+Jyoqyww==",
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^6.2.1",
        "string-width": "^7.0.0",
        "strip-ansi": "^7.1.0"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/y18n": {
      "version": "5.0.8",
      "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
      "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
      "license": "ISC",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/yargs": {
      "version": "18.0.0",
      "resolved": "https://registry.npmjs.org/yargs/-/yargs-18.0.0.tgz",
      "integrity": "sha512-4UEqdc2RYGHZc7Doyqkrqiln3p9X2DZVxaGbwhn2pi7MrRagKaOcIKe8L3OxYcbhXLgLFUS3zAYuQjKBQgmuNg==",
      "license": "MIT",
      "dependencies": {
        "cliui": "^9.0.1",
        "escalade": "^3.1.1",
        "get-caller-file": "^2.0.5",
        "string-width": "^7.2.0",
        "y18n": "^5.0.5",
        "yargs-parser": "^22.0.0"
      },
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=23"
      }
    },
    "node_modules/yargs-parser": {
      "version": "22.0.0",
      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-22.0.0.tgz",
      "integrity": "sha512-rwu/ClNdSMpkSrUb+d6BRsSkLUq1fmfsY6TOpYzTwvwkg1/NRG85KBy3kq++A8LKQwX6lsu+aWad+2khvuXrqw==",
      "license": "ISC",
      "engines": {
        "node": "^20.19.0 || ^22.12.0 || >=23"
      }
    }
  }
}



// =================================================================
// METADATA
// =================================================================
// File Path:      package.json
// Size:           0.05 KB
// Last Modified:  2025-11-18T19:59:48.504Z
// =================================================================

{
  "dependencies": {
    "yargs": "^18.0.0"
  }
}



// =================================================================
// METADATA
// =================================================================
// File Path:      pyproject.toml
// Size:           1.78 KB
// Last Modified:  2025-11-17T21:47:59.823Z
// =================================================================

[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta"

[tool.mypy]
python_version = "3.11"
warn_return_any = true
warn_unused_ignores = true
strict = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_no_return = true
warn_unreachable = true
ignore_missing_imports = true

# Module-specific overrides for gradual adoption
[[tool.mypy.overrides]]
module = [
    "src.combat_math",
    "src.combat_orchestrator",
    "src.effect_handlers",
    "src.events",
    "src.item_generator",
    "src.simulation",
    "tests.*"
]
ignore_errors = true  # These will be migrated incrementally

# Core data models should be strictly typed
[[tool.mypy.overrides]]
module = "src.data.*"
ignore_errors = false

# The main game data provider should be strictly typed
[[tool.mypy.overrides]]
module = "src.game_data_provider"
ignore_errors = false

# Combat engine (main entry point)
[[tool.mypy.overrides]]
module = "src.engine"
ignore_errors = false

[tool.black]
line-length = 120
target-version = ['py311']

[tool.isort]
profile = "black"
line_length = 120
multi_line_output = 3

[tool.pytest.ini_options]
minversion = "6.0"
addopts = "-ra -q"
testpaths = [
    "tests"
]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "integration: marks tests as integration tests"
]

[tool.coverage.run]
source = ["src"]
omit = [
    "src/__init__.py",
    "tests/*"
]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:"
]



// =================================================================
// METADATA
// =================================================================
// File Path:      README.md
// Size:           6.42 KB
// Last Modified:  2025-11-16T13:57:37.614Z
// =================================================================

# Combat Engine

A modular combat system for dungeon crawler RPGs, featuring sophisticated damage calculations, character progression, and itemization systems.

## Overview

The Combat Engine implements a complete RPG combat system with:
- **Pierce-based damage calculation**: `MAX((Attack Damage - Defense), (Attack Damage Ã— Pierce Ratio))`
- **Multi-tier critical hits**: Rarity-based crit scaling (Commonâ†’Mythic)
- **Event-driven effects**: DoTs, buffs, and complex skill interactions
- **Dynamic itemization**: Thematic affix pools with equipment mechanics
- **Time-based simulation**: DoT ticks, duration management, and temporal effects

## Architecture

### Core Components
- **`src/engine.py`**: CombatEngine with damage calculation and hit resolution
- **`src/models.py`**: Entity, EntityStats, Affix, Item data models
- **`src/state.py`**: StateManager for entity state tracking
- **`src/events.py`**: EventBus for decoupled effect triggering
- **`src/effect_handlers.py`**: DoT and effect application logic
- **`src/skills.py`**: Multi-hit skills with configurable triggers

### Design Principles
- **Data-driven**: All game content defined in external data structures
- **Event-driven**: Loose coupling through observer pattern
- **Deterministic**: Reproducible results for testing and balance
- **Modular**: Independent systems for easy maintenance and extension

## Testing & Determinism

### RNG Policy
**All combat RNG must be deterministic in tests and injectable in production. No global seeding permitted.**

This ensures:
- **Reproducible tests**: Same inputs always produce same outputs
- **Balance validation**: Simulation results are consistent and verifiable
- **Debugging**: Issues can be reproduced with specific RNG states
- **Production safety**: No hidden randomness affecting game state

### Testing Conventions

#### RNG Injection
```python
from tests.fixtures import make_rng

# For deterministic tests
engine = CombatEngine(rng=make_rng(42))
handler = BleedHandler(event_bus, state_manager, rng=make_rng(123))

# For production (uses random.random() internally)
engine = CombatEngine()  # rng=None uses system random
```

#### Test Fixtures
Common test entities are available through fixtures:
```python
from tests.fixtures import make_attacker, make_defender, make_rng

attacker = make_attacker(base_damage=100.0, crit_chance=0.25)
defender = make_defender(armor=50.0, max_health=1000.0)
```

#### Running Tests
```bash
# Run all tests
python -m pytest

# Run with coverage
python -m pytest --cov=src --cov-report=html

# Run specific test file
python -m pytest tests/test_engine.py

# Run integration tests
python run_phase1_test.py  # Basic combat
python run_phase2_test.py  # Crits & events
python run_phase3_test.py  # Items & skills
```

## Installation & Setup

### Requirements
```bash
pip install -r requirements.txt
```

### Development Setup
```bash
# Clone repository
git clone <repository-url>
cd combat_engine

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Run tests
python -m pytest
```

## Usage Examples

### Basic Combat
```python
from src.engine import CombatEngine
from src.models import Entity, EntityStats

# Create entities
attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=0.2)
attacker = Entity(id="hero", base_stats=attacker_stats)

defender_stats = EntityStats(armor=50.0, max_health=1000.0)
defender = Entity(id="monster", base_stats=defender_stats)

# Resolve hit
engine = CombatEngine()
hit_context = engine.resolve_hit(attacker, defender, state_manager)

print(f"Damage dealt: {hit_context.final_damage}")
print(f"Was critical: {hit_context.is_crit}")
```

### Skills with Effects
```python
from src.skills import Skill, Trigger
from src.events import EventBus
from src.state import StateManager
from src.effect_handlers import BleedHandler

# Set up systems
event_bus = EventBus()
state_manager = StateManager()
bleed_handler = BleedHandler(event_bus, state_manager)

# Create multi-hit skill
skill = Skill(
    id="whirlwind",
    name="Whirlwind Strike",
    hits=3,
    triggers=[{
        "event": "OnHit",
        "check": {"proc_rate": 0.5},
        "result": {"apply_debuff": "Bleed", "stacks": 1}
    }]
)

# Execute skill
engine.process_skill_use(attacker, defender, skill, event_bus, state_manager)
```

## Development Status

### Completed Phases âœ…
- **Phase 1**: Core combat foundation (damage formulas, entity management)
- **Phase 2**: Enhanced combat (crits, events, DoTs)
- **Phase 3**: Game systems (items, skills, equipment)
- **Phase 4**: Simulation & balancing (time-based effects, comprehensive testing)

### Current Status
- **Python Prototype**: Complete and fully tested (96 unit tests)
- **Godot Port**: Ready for implementation
- **Test Coverage**: >95% on critical systems
- **Performance**: 6993 events/second in simulation

### Next Steps
- Port core systems to GDScript
- Implement UI and visual feedback
- Add content creation tools
- Performance optimization for target platforms

## API Reference

### CombatEngine
- `resolve_hit(attacker, defender, state_manager)`: Calculate single hit damage
- `calculate_effective_damage(attacker, defender)`: Get detailed breakdown
- `validate_damage_calculation(attacker, defender)`: Check calculation validity
- `process_skill_use(attacker, defender, skill, event_bus, state_manager)`: Execute skill

### Key Classes
- `Entity`: Combat participant with stats and equipment
- `EntityStats`: Base stats (damage, armor, crit chance, etc.)
- `Skill`: Multi-hit ability with triggers
- `StateManager`: Tracks entity health and active effects
- `EventBus`: Decoupled event dispatching system

## Contributing

### Code Standards
- Type hints required for all public functions
- Comprehensive docstrings
- Unit tests for all new functionality
- RNG injection for any random behavior

### Testing Requirements
- All tests must pass with `python -m pytest`
- New features require corresponding tests
- Deterministic RNG usage in tests
- Integration tests for complex interactions

### Documentation
- Update memory bank for significant changes
- Keep API examples current
- Document any new RNG usage patterns

## License

[License information here]

## Contact

[Contact information here]



// =================================================================
// METADATA
// =================================================================
// File Path:      requirements.txt
// Size:           0.10 KB
// Last Modified:  2025-11-09T17:32:48.740Z
// =================================================================

numpy>=1.21.0
pandas>=1.3.0
matplotlib>=3.4.0
pytest>=6.2.0
pytest-cov>=2.12.0
pydantic>=1.8.0



// =================================================================
// METADATA
// =================================================================
// File Path:      run_full_test.py
// Size:           0.16 KB
// Last Modified:  2025-11-17T19:47:38.216Z
// =================================================================

import time
import logging

logging.basicConfig(level=logging.INFO, format='%(message)s')

from src.models import Entity, EntityStats, RolledAffix, Item



// =================================================================
// METADATA
// =================================================================
// File Path:      run_phase1_test.py
// Size:           4.37 KB
// Last Modified:  2025-11-17T19:49:03.776Z
// =================================================================

#!/usr/bin/env python3
"""
Phase 1 Integration Test: "First Hit" Demo

This script demonstrates the complete Phase 1 combat system by simulating
a single attack from one entity to another, combining all Phase 1 components:
- Entity creation with stats
- State management
- Damage calculation
- Health tracking

Expected output for the test scenario:
- Attacker: base_damage=120, pierce_ratio=0.1
- Defender: max_health=1000, armor=150
- Damage calculation: max(120-150, 120*0.1) = max(-30, 12) = 12
- Defender health: 1000 â†’ 988
"""

import logging

logging.basicConfig(level=logging.INFO, format='%(message)s')

from src.models import Entity, EntityStats
from src.state import StateManager
from src.engine import CombatEngine


def main():
    """Run the Phase 1 integration test."""
    print("=== Phase 1: First Hit Test ===")
    print("Testing complete combat system integration")
    print()

    # Create test entities
    print("1. Creating test entities...")

    # Attacker: Strong but low pierce
    attacker_stats = EntityStats(base_damage=120.0, pierce_ratio=0.1)
    attacker = Entity(id="player_1", base_stats=attacker_stats, name="Hero")

    # Defender: Heavily armored
    defender_stats = EntityStats(max_health=1000.0, armor=150.0)
    defender = Entity(id="enemy_1", base_stats=defender_stats, name="Armored Knight")

    print(f"   Attacker: {attacker} (Damage: {attacker.stats.base_damage}, Pierce: {attacker.stats.pierce_ratio})")
    print(f"   Defender: {defender} (Health: {defender.stats.max_health}, Armor: {defender.stats.armor})")
    print()

    # Set up state management
    print("2. Initializing combat state...")
    state_manager = StateManager()
    state_manager.register_entity(attacker)
    state_manager.register_entity(defender)

    defender_state = state_manager.get_state(defender.id)
    assert defender_state is not None, f"Defender {defender.id} not registered"
    initial_hp = defender_state.current_health
    print(f"   {defender} initial health: {initial_hp}")
    print()

    # Execute the attack
    print("3. Executing attack...")

    # Calculate damage
    engine = CombatEngine()
    damage_context = engine.resolve_hit(attacker, defender, state_manager)
    damage = damage_context.final_damage
    print(f"   {attacker} attacks {defender} for {damage:.2f} damage")

    # Show damage breakdown for analysis
    breakdown = CombatEngine.calculate_effective_damage(attacker, defender)
    print("   Damage breakdown:")
    print(f"     Attack damage: {breakdown['attack_damage']}")
    print(f"     Pre-pierce damage: {breakdown['pre_pierce_damage']}")
    print(f"     Pierced damage: {breakdown['pierced_damage']}")
    print(f"     Armor reduction: {breakdown['armor_reduction']}")
    print(f"     Final damage: {breakdown['final_damage']}")
    print()

    # Apply damage to defender
    print("4. Applying damage...")
    state_manager.apply_damage(defender.id, damage)

    final_defender_state = state_manager.get_state(defender.id)
    assert final_defender_state is not None, f"Defender {defender.id} state lost"
    final_hp = final_defender_state.current_health
    is_alive = final_defender_state.is_alive

    print(f"   {defender} final health: {final_hp}")
    print(f"   {defender} is alive: {is_alive}")
    print()

    # Verify expected results
    print("5. Verification...")
    expected_damage = 12.0  # max(120-150, 120*0.1) = max(-30, 12) = 12
    expected_final_hp = 988.0  # 1000 - 12

    if abs(damage - expected_damage) < 0.01:
        print("   âœ… Damage calculation correct")
    else:
        print(f"   âŒ Damage calculation incorrect. Expected: {expected_damage}, Got: {damage}")

    if abs(final_hp - expected_final_hp) < 0.01:
        print("   âœ… Health tracking correct")
    else:
        print(f"   âŒ Health tracking incorrect. Expected: {expected_final_hp}, Got: {final_hp}")

    if is_alive:
        print("   âœ… Alive status correct")
    else:
        print("   âŒ Alive status incorrect")

    print()
    print("=== Test Complete ===")

    # Return success/failure for automated testing
    success = (abs(damage - expected_damage) < 0.01 and
               abs(final_hp - expected_final_hp) < 0.01 and
               is_alive)
    return success


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)



// =================================================================
// METADATA
// =================================================================
// File Path:      run_phase2_test.py
// Size:           3.08 KB
// Last Modified:  2025-11-17T19:50:18.418Z
// =================================================================

#!/usr/bin/env python3
"""Phase 2 Integration Test - Critical Hits, Events, and DoTs."""

import random
import logging

logging.basicConfig(level=logging.INFO, format='%(message)s')

from src.models import Entity, EntityStats
from src.events import EventBus
from src.state import StateManager
from src.combat import process_attack
from src.effect_handlers import BleedHandler


def main():
    """Run the Phase 2 integration test."""
    print("=== Phase 2: Crit & Event Test ===")

    # Set up seeded random for reproducible results
    random.seed(42)

    # Create EventBus and StateManager
    event_bus = EventBus()
    state_manager = StateManager()

    # Create attacker (Rare - Tier 2 crits)
    attacker_stats = EntityStats(
        base_damage=100.0,
        crit_chance=0.8,  # High crit chance for testing
        crit_damage=2.0,
        pierce_ratio=0.1
    )
    attacker = Entity(id="player_1", stats=attacker_stats, rarity="Rare")

    # Create defender
    defender_stats = EntityStats(max_health=2000.0, armor=100.0)
    defender = Entity(id="enemy_1", stats=defender_stats)

    # Register entities
    state_manager.register_entity(attacker)
    state_manager.register_entity(defender)

    # Register effect handler
    bleed_handler = BleedHandler(event_bus, state_manager, proc_rate=0.6)  # 60% proc rate

    print(f"Attacker is '{attacker.rarity}', using Crit Tier {attacker.get_crit_tier()}.")
    print(f"Defender starts with {defender.stats.max_health} health.")
    print()

    # Simulate 5 attacks
    for i in range(5):
        print(f"Attack #{i+1}:")
        hit_context = process_attack(attacker, defender, event_bus, state_manager)

        is_crit_str = "CRITICAL HIT!" if hit_context.is_crit else "Normal Hit."
        print(f"  > {is_crit_str} Damage: {hit_context.final_damage:.2f}")

        # Show current defender state
        defender_state = state_manager.get_state(defender.id)
        assert defender_state is not None, "Defender state should not be None"
        print(f"  > Defender Health: {defender_state.current_health:.2f}")

        if defender_state.active_debuffs:
            for debuff_name, debuff in defender_state.active_debuffs.items():
                print(f"  > Debuff: {debuff_name}, Stacks: {debuff.stacks}, Time: {debuff.time_remaining:.1f}s")
        else:
            print("  > No debuffs applied.")

        print()

    # Final state summary
    print("--- Final State ---")
    defender_state = state_manager.get_state(defender.id)
    assert defender_state is not None, "Defender state should not be None"
    print(f"Defender Health: {defender_state.current_health:.2f} / {defender.stats.max_health}")
    if defender_state.active_debuffs:
        print("Active Debuffs:")
        for debuff_name, debuff in defender_state.active_debuffs.items():
            print(f"  - {debuff_name}: {debuff.stacks} stacks, {debuff.time_remaining:.1f}s remaining")
    else:
        print("No debuffs applied.")

    print("\n=== Phase 2 Test Complete ===")


if __name__ == "__main__":
    main()



// =================================================================
// METADATA
// =================================================================
// File Path:      run_phase3_test.py
// Size:           4.30 KB
// Last Modified:  2025-11-17T19:51:17.603Z
// =================================================================

#!/usr/bin/env python3
"""Phase 3 Integration Test - Items, Skills, and Equipment."""

import random
import logging

logging.basicConfig(level=logging.INFO, format='%(message)s')

from src.models import Entity, EntityStats, RolledAffix, Item
from src.skills import Skill, Trigger
from src.events import EventBus
from src.state import StateManager
from src.engine import CombatEngine
from src.effect_handlers import BleedHandler, PoisonHandler


def main():
    """Run the Phase 3 integration test."""
    print("=== Phase 3: Items, Skills & Equipment Test ===")

    # Set up seeded random for reproducible results
    random.seed(42)

    # Create EventBus and StateManager
    event_bus = EventBus()
    state_manager = StateManager()

    # Create effect handlers
    bleed_handler = BleedHandler(event_bus, state_manager, proc_rate=0.6)
    poison_handler = PoisonHandler(event_bus, state_manager, proc_rate=0.33)

    # Create player with base stats
    player_base_stats = EntityStats(
        base_damage=50.0,
        crit_chance=0.1,
        crit_damage=2.0,
        pierce_ratio=0.1,
        max_health=1000.0
    )
    player = Entity(id="player_1", base_stats=player_base_stats, rarity="Rare")

    # Create enemy
    enemy_base_stats = EntityStats(
        max_health=1500.0,
        armor=50.0
    )
    enemy = Entity(id="enemy_1", base_stats=enemy_base_stats)

    # Register entities
    state_manager.register_entity(player)
    state_manager.register_entity(enemy)

    # Create equipment
    vicious_axe = Item(
        id="axe_01",
        name="Vicious Axe",
        slot="Weapon",
        affixes=[
            Affix(stat="base_damage", mod_type="flat", value=20.0),
            Affix(stat="crit_chance", mod_type="flat", value=0.15),
            Affix(stat="pierce_ratio", mod_type="multiplier", value=1.5)
        ]
    )

    enchanted_helm = Item(
        id="helm_01",
        name="Enchanted Helm",
        slot="Head",
        affixes=[
            Affix(stat="max_health", mod_type="flat", value=200.0),
            Affix(stat="armor", mod_type="multiplier", value=1.25)
        ]
    )

    # Create skill
    multi_slash = Skill(
        id="skill_01",
        name="Multi-Slash",
        hits=3,
        triggers=[
            Trigger(
                event="OnHit",
                check={"proc_rate": 0.4},
                result={"apply_debuff": "Poison", "stacks": 1}
            )
        ]
    )

    # Show initial stats
    print("--- Initial Player Stats ---")
    print(f"Base Damage: {player.base_stats.base_damage}")
    print(f"Crit Chance: {player.base_stats.crit_chance}")
    print(f"Max Health: {player.base_stats.max_health}")
    print(f"Armor: {player.base_stats.armor}")
    print(f"Pierce Ratio: {player.base_stats.pierce_ratio}")
    print()

    # Equip items
    print("--- Equipping Items ---")
    player.equip_item(vicious_axe)
    print(f"Equipped: {vicious_axe.name}")

    player.equip_item(enchanted_helm)
    print(f"Equipped: {enchanted_helm.name}")
    print()

    # Show final stats after equipment
    print("--- Player Stats After Equipment ---")
    print(f"Final Damage: {player.final_stats.base_damage}")
    print(f"Final Crit Chance: {player.final_stats.crit_chance}")
    print(f"Final Max Health: {player.final_stats.max_health}")
    print(f"Final Armor: {player.final_stats.armor}")
    print(f"Final Pierce Ratio: {player.final_stats.pierce_ratio}")
    print()

    # Use skill
    print(f"--- {player.name} uses {multi_slash.name} on {enemy.name} ---")
    CombatEngine.process_skill_use(player, enemy, multi_slash, event_bus, state_manager)

    # Show results
    print()
    print("--- Final Results ---")
    enemy_state = state_manager.get_state(enemy.id)
    if enemy_state:
        print(f"Enemy Health: {enemy_state.current_health:.1f} / {enemy.final_stats.max_health}")
        if enemy_state.active_debuffs:
            print("Active Debuffs:")
            for debuff_name, debuff in enemy_state.active_debuffs.items():
                print(f"  - {debuff_name}: {debuff.stacks} stacks, {debuff.time_remaining:.1f}s remaining")
        else:
            print("No debuffs applied.")

    print("\n=== Phase 3 Test Complete ===")


if __name__ == "__main__":
    main()



// =================================================================
// METADATA
// =================================================================
// File Path:      run_simulation.py
// Size:           9.07 KB
// Last Modified:  2025-11-17T19:48:28.607Z
// =================================================================

#!/usr/bin/env python3
"""Simulation runner for combat engine testing and balancing.

This script runs automated combat simulations with predefined entities
and generates detailed reports for balance analysis.
"""

import random
import json
import logging

logging.basicConfig(level=logging.INFO, format='%(message)s')

from src.models import Entity, EntityStats
from src.state import StateManager
from src.events import EventBus
from src.engine import CombatEngine
from src.effect_handlers import BleedHandler, PoisonHandler
from src.simulation import SimulationRunner, ReportGenerator
from src.item_generator import ItemGenerator


def create_sample_entities() -> list[Entity]:
    """Create sample entities for simulation testing.

    Returns:
        List of sample entities with different stats
    """
    # Warrior - High damage, low speed, tanky
    warrior_stats = EntityStats(
        base_damage=25.0,
        attack_speed=0.8,  # attacks per second
        crit_chance=0.1,
        crit_damage=1.8,
        pierce_ratio=0.05,
        max_health=150.0,
        armor=15.0,
        resistances=0.0
    )
    warrior = Entity("warrior", warrior_stats, "Warrior", "Rare")

    # Assassin - High speed, moderate damage, low health
    assassin_stats = EntityStats(
        base_damage=18.0,
        attack_speed=1.5,  # attacks per second
        crit_chance=0.25,
        crit_damage=2.0,
        pierce_ratio=0.1,
        max_health=80.0,
        armor=5.0,
        resistances=0.0
    )
    assassin = Entity("assassin", assassin_stats, "Assassin", "Epic")

    # Mage - Moderate damage, low speed, squishy
    mage_stats = EntityStats(
        base_damage=30.0,
        attack_speed=0.6,  # attacks per second
        crit_chance=0.15,
        crit_damage=1.5,
        pierce_ratio=0.02,
        max_health=70.0,
        armor=0.0,
        resistances=0.2
    )
    mage = Entity("mage", mage_stats, "Mage", "Legendary")

    # Tank - Low damage, very tanky, slow
    tank_stats = EntityStats(
        base_damage=12.0,
        attack_speed=0.5,  # attacks per second
        crit_chance=0.05,
        crit_damage=1.3,
        pierce_ratio=0.01,
        max_health=200.0,
        armor=25.0,
        resistances=0.1
    )
    tank = Entity("tank", tank_stats, "Tank", "Uncommon")

    return [warrior, assassin, mage, tank]


def setup_simulation() -> SimulationRunner:
    """Set up the simulation with all necessary components.

    Returns:
        Configured SimulationRunner instance
    """
    # Initialize core systems
    state_manager = StateManager()
    event_bus = EventBus()
    combat_engine = CombatEngine()

    # Set up effect handlers
    bleed_handler = BleedHandler(event_bus, state_manager, proc_rate=0.4)
    poison_handler = PoisonHandler(event_bus, state_manager, proc_rate=0.25)

    # Create simulation runner
    runner = SimulationRunner(combat_engine, state_manager, event_bus)

    return runner


def run_combat_simulation(seed: int = 42, duration: float = 30.0) -> dict:
    """Run a complete combat simulation.

    Args:
        seed: Random seed for reproducible results
        duration: Simulation duration in seconds

    Returns:
        Dictionary containing simulation results and reports
    """
    # Set random seed for reproducible results
    random.seed(seed)

    print(f"Starting combat simulation (seed: {seed}, duration: {duration}s)")

    # Set up simulation
    runner = setup_simulation()

    # Create and add entities
    entities = create_sample_entities()
    for entity in entities:
        runner.add_entity(entity)
        print(f"Added entity: {entity.name} ({entity.id}) - {entity.final_stats}")

    # Run simulation
    print("Running simulation...")
    runner.run_simulation(duration)

    # Generate reports
    print("Generating reports...")
    report_generator = ReportGenerator(runner.logger)
    full_report = report_generator.generate_full_report()

    # Add simulation metadata
    full_report["metadata"] = {
        "seed": seed,
        "duration": duration,
        "entity_count": len(entities),
        "entities": [
            {
                "id": e.id,
                "name": e.name,
                "rarity": e.rarity,
                "stats": {
                    "damage": e.final_stats.base_damage,
                    "attack_speed": e.final_stats.attack_speed,
                    "health": e.final_stats.max_health,
                    "armor": e.final_stats.armor
                }
            }
            for e in entities
        ]
    }

    return full_report


def print_simulation_summary(report: dict) -> None:
    """Print a human-readable summary of the simulation results.

    Args:
        report: The full simulation report
    """
    print("\n" + "="*60)
    print("COMBAT SIMULATION SUMMARY")
    print("="*60)

    metadata = report.get("metadata", {})
    print(f"Seed: {metadata.get('seed', 'N/A')}")
    print(f"Duration: {metadata.get('duration', 0):.1f} seconds")
    print(f"Entities: {metadata.get('entity_count', 0)}")

    # Performance summary
    perf = report.get("performance_analysis", {})
    print("\nPerformance:")
    print(f"  Duration: {perf.get('simulation_duration', 0):.2f}s")
    print(f"  Events/second: {perf.get('events_per_second', 0):.1f}")
    print(f"  Rating: {perf.get('performance_rating', 'Unknown')}")

    # Damage summary
    damage = report.get("damage_analysis", {})
    summary = damage.get("summary", {})
    print("\nDamage Summary:")
    print(f"  Total damage: {summary.get('total_damage', 0):.1f}")
    print(f"  Total hits: {summary.get('total_hits', 0)}")
    print(f"  Critical hits: {summary.get('total_crits', 0)}")
    print(f"  Overall crit rate: {summary.get('overall_crit_rate', 0):.1%}")
    print(f"  Avg damage per hit: {summary.get('avg_damage_per_hit', 0):.1f}")

    # Entity breakdown
    entity_breakdown = damage.get("entity_breakdown", {})
    print("\nEntity Performance:")
    for entity_id, stats in entity_breakdown.items():
        print(f"  {entity_id}:")
        print(f"    Damage: {stats.get('total_damage', 0):.1f} ({stats.get('damage_percentage', 0):.1f}%)")
        print(f"    Hits: {stats.get('hits', 0)}, Crits: {stats.get('crits', 0)}")
        print(f"    Crit rate: {stats.get('crit_rate', 0):.1%}")

    # Effect summary
    effect = report.get("effect_analysis", {})
    effect_summary = effect.get("summary", {})
    print("\nEffect Summary:")
    print(f"  Total applications: {effect_summary.get('total_applications', 0)}")
    print(f"  Total DoT ticks: {effect_summary.get('total_ticks', 0)}")
    print(f"  Total DoT damage: {effect_summary.get('total_dot_damage', 0):.1f}")

    # Balance insights
    insights = report.get("balance_insights", {})
    recommendations = insights.get("recommendations", [])
    print("\nBalance Recommendations:")
    for rec in recommendations:
        print(f"  â€¢ {rec}")

    print("="*60)


def save_report_to_file(report: dict, filename: str = "simulation_report.json") -> None:
    """Save the simulation report to a JSON file.

    Args:
        filename: Output filename
    """
    try:
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        print(f"Report saved to {filename}")
    except Exception as e:
        print(f"Error saving report: {e}")


def main():
    """Main entry point for the simulation script."""
    import argparse

    parser = argparse.ArgumentParser(description="Run combat engine simulations")
    parser.add_argument("--seed", type=int, default=42, help="Random seed for reproducible results")
    parser.add_argument("--duration", type=float, default=30.0, help="Simulation duration in seconds")
    parser.add_argument("--output", type=str, default="simulation_report.json", help="Output report filename")
    parser.add_argument("--quiet", action="store_true", help="Suppress detailed output")

    args = parser.parse_args()

    # Run simulation
    report = run_combat_simulation(seed=args.seed, duration=args.duration)

    # Print summary
    if not args.quiet:
        print_simulation_summary(report)

    # Save report
    save_report_to_file(report, args.output)

    # Item generation demo
    print("\n--- Item Generation Demo ---")
    try:
        with open('data/game_data.json', 'r') as f:
            game_data = json.load(f)
        item_gen = ItemGenerator(game_data)

        # Generate a few random items
        for base_id in ['base_iron_axe', 'base_gold_ring', 'base_leather_chest']:
            item = item_gen.generate(base_id)
            print(f"Generated: {item.name} (Quality: {item.quality_tier}, Rarity: {item.rarity})")
            for affix in item.affixes:
                print(f"  - {affix.description.replace('{value}', str(affix.value))}")

    except Exception as e:
        print(f"Item generation demo failed: {e}")

    print(f"\nSimulation complete! Report saved to {args.output}")


if __name__ == "__main__":
    main()



// =================================================================
// METADATA
// =================================================================
// File Path:      simulation_report.json
// Size:           4.45 KB
// Last Modified:  2025-11-16T14:58:29.457Z
// =================================================================

{
  "damage_analysis": {
    "summary": {
      "total_damage": 213.39000000000001,
      "total_hits": 20,
      "total_crits": 2,
      "overall_crit_rate": 0.1,
      "avg_damage_per_hit": 10.669500000000001
    },
    "entity_breakdown": {
      "assassin": {
        "total_damage": 65.4,
        "damage_percentage": 30.64810909602137,
        "hits": 7,
        "crits": 1,
        "crit_rate": 0.14285714285714285,
        "avg_damage_per_hit": 9.342857142857143,
        "avg_crit_damage": 21.0,
        "avg_normal_damage": 7.3999999999999995
      },
      "warrior": {
        "total_damage": 88.75,
        "damage_percentage": 41.590515019447956,
        "hits": 7,
        "crits": 1,
        "crit_rate": 0.14285714285714285,
        "avg_damage_per_hit": 12.678571428571429,
        "avg_crit_damage": 20.0,
        "avg_normal_damage": 11.458333333333334
      },
      "mage": {
        "total_damage": 40.0,
        "damage_percentage": 18.745020853835697,
        "hits": 2,
        "crits": 0,
        "crit_rate": 0.0,
        "avg_damage_per_hit": 20.0,
        "avg_crit_damage": 0,
        "avg_normal_damage": 20.0
      },
      "tank": {
        "total_damage": 19.240000000000002,
        "damage_percentage": 9.016355030694973,
        "hits": 4,
        "crits": 0,
        "crit_rate": 0.0,
        "avg_damage_per_hit": 4.8100000000000005,
        "avg_crit_damage": 0,
        "avg_normal_damage": 4.8100000000000005
      }
    }
  },
  "effect_analysis": {
    "summary": {
      "total_applications": 0,
      "total_ticks": 33,
      "total_dot_damage": 320.0,
      "avg_damage_per_tick": 9.696969696969697
    },
    "entity_breakdown": {
      "tank": {
        "Bleed": {
          "applications": 0,
          "total_ticks": 7,
          "total_damage": 65.0,
          "avg_damage_per_tick": 9.285714285714286
        },
        "Poison": {
          "applications": 0,
          "total_ticks": 9,
          "total_damage": 115.0,
          "avg_damage_per_tick": 12.777777777777779
        }
      },
      "assassin": {
        "Bleed": {
          "applications": 0,
          "total_ticks": 3,
          "total_damage": 25.0,
          "avg_damage_per_tick": 8.333333333333334
        }
      },
      "warrior": {
        "Bleed": {
          "applications": 0,
          "total_ticks": 7,
          "total_damage": 35.0,
          "avg_damage_per_tick": 5.0
        },
        "Poison": {
          "applications": 0,
          "total_ticks": 7,
          "total_damage": 80.0,
          "avg_damage_per_tick": 11.428571428571429
        }
      }
    }
  },
  "performance_analysis": {
    "simulation_duration": 0.002952098846435547,
    "total_events": 53,
    "events_per_second": 17953.328379906317,
    "performance_rating": "Excellent"
  },
  "balance_insights": {
    "damage_distribution": {
      "distribution_type": "unbalanced",
      "max_damage_percentage": 41.590515019447956,
      "min_damage_percentage": 9.016355030694973,
      "variance": 150.43699889870692,
      "range": 32.57415998875298
    },
    "effect_balance": {
      "entities_with_effects": 3,
      "total_entities": 3,
      "effect_coverage": 1.0
    },
    "recommendations": [
      "Consider balancing damage output - high variance detected in damage distribution"
    ]
  },
  "generated_at": 1763305109.4525793,
  "metadata": {
    "seed": 42,
    "duration": 30.0,
    "entity_count": 4,
    "entities": [
      {
        "id": "warrior",
        "name": "Warrior",
        "rarity": "Rare",
        "stats": {
          "damage": 25.0,
          "attack_speed": 0.8,
          "health": 150.0,
          "armor": 15.0
        }
      },
      {
        "id": "assassin",
        "name": "Assassin",
        "rarity": "Epic",
        "stats": {
          "damage": 18.0,
          "attack_speed": 1.5,
          "health": 80.0,
          "armor": 5.0
        }
      },
      {
        "id": "mage",
        "name": "Mage",
        "rarity": "Legendary",
        "stats": {
          "damage": 30.0,
          "attack_speed": 0.6,
          "health": 70.0,
          "armor": 0.0
        }
      },
      {
        "id": "tank",
        "name": "Tank",
        "rarity": "Uncommon",
        "stats": {
          "damage": 12.0,
          "attack_speed": 0.5,
          "health": 200.0,
          "armor": 25.0
        }
      }
    ]
  }
}


// =================================================================
// METADATA
// =================================================================
// File Path:      src\combat.py
// Size:           1.41 KB
// Last Modified:  2025-11-16T13:56:08.100Z
// =================================================================

"""Combat integration layer - ties together engine, events, and state management."""

from .engine import CombatEngine, HitContext
from .events import EventBus, OnHitEvent, OnCritEvent
from .state import StateManager


def process_attack(attacker, defender, event_bus: EventBus, state_manager: StateManager) -> HitContext:
    """Process a complete attack from hit calculation through event dispatching.

    Args:
        attacker: The entity performing the attack
        defender: The entity receiving the attack
        event_bus: The event bus for dispatching combat events
        state_manager: The state manager for applying damage

    Returns:
        HitContext containing the complete damage calculation results
    """
    # Calculate the hit using the combat engine
    hit_context = CombatEngine.resolve_hit(attacker, defender, state_manager)

    # Apply damage to the defender
    damage = hit_context.final_damage
    state_manager.apply_damage(defender.id, damage)

    # Dispatch the hit event
    hit_event = OnHitEvent(
        attacker=attacker,
        defender=defender,
        damage_dealt=damage,
        is_crit=hit_context.is_crit
    )
    event_bus.dispatch(hit_event)

    # Dispatch crit event if it was a critical hit
    if hit_context.is_crit:
        crit_event = OnCritEvent(hit_event=hit_event)
        event_bus.dispatch(crit_event)

    return hit_context



// =================================================================
// METADATA
// =================================================================
// File Path:      src\combat_math.py
// Size:           3.05 KB
// Last Modified:  2025-11-17T20:10:56.701Z
// =================================================================

"""
Pure, stateless combat math functions.

These functions never:
- store state
- reference CombatEngine
- reference HitContext
- call RNG internally

All randomness must be provided by the caller.
"""

from typing import Tuple


def roll_chance(rng, chance: float) -> bool:
    """Return True if proc occurs. Assumes rng is Random or similar."""
    if chance <= 0:
        return False
    if chance >= 1:
        return True
    return rng.random() < chance


def resolve_crit(rng, crit_chance: float, crit_mult: float) -> Tuple[bool, float]:
    """Returns (is_crit, multiplier).

    Crit multiplier is applied by caller to damage calculations.
    """
    is_crit = roll_chance(rng, crit_chance)
    return is_crit, (crit_mult if is_crit else 1.0)


def evade_dodge_or_normal(rng, dodge_chance: float, evade_chance: float) -> str:
    """Returns 'dodge', 'evade', or 'normal'.

    Dodge and evade are mutually exclusive with priority to full dodges.
    """
    if roll_chance(rng, dodge_chance):
        return 'dodge'
    if roll_chance(rng, evade_chance):
        return 'evade'
    return 'normal'


def apply_block_damage(damage: float, block_amount: float) -> float:
    """Apply damage reduction from blocking. Returns reduced damage."""
    # Never reduce below 1 damage
    return max(1.0, damage - block_amount)


def apply_glancing_damage(damage: float, glancing_multiplier: float) -> float:
    """Apply glancing blow damage reduction."""
    if glancing_multiplier <= 0:
        return 0  # 0% damage on glancing blow means 0 damage total
    return damage * glancing_multiplier


def apply_pierce_to_armor(armor: float, pierce_ratio: float) -> float:
    """Pierce bypasses a portion of armor. Returns effective armor after pierce."""
    # Pierce ratio of 1.0 bypasses all armor (100% pierce)
    # Pierce ratio of 0.0 leaves armor unchanged (0% pierce)
    return max(0.0, armor * (1.0 - pierce_ratio))


def apply_armor_mitigation(damage: float, effective_armor: float) -> float:
    """Apply armor mitigation to damage."""
    # GDD Formula: damage - armor, clamped to 0
    mitigated_damage = max(0.0, damage - effective_armor)

    # Alternative formula could be: damage * (100 / (100 + effective_armor))
    # But current implementation uses the simpler damage - armor approach

    return mitigated_damage


def calculate_pierce_damage_formula(
    pre_pierce_damage: float,
    pierced_damage: float
) -> float:
    """Calculate final damage using pierce formula.

    Current GDD: max(0, max(pre_pierce_damage, pierced_damage))
    This means damage ignores pierce if normal armor reduction gives higher damage.
    """
    return max(0.0, max(pre_pierce_damage, pierced_damage))


def clamp_min_damage(damage: float, min_value: float = 0.0) -> float:
    """Ensure damage never goes below minimum value."""
    return max(min_value, damage)


def calculate_skill_effect_proc(rng, proc_rate: float) -> bool:
    """Determine if a skill effect should proc."""
    return roll_chance(rng, proc_rate)



// =================================================================
// METADATA
// =================================================================
// File Path:      src\combat_orchestrator.py
// Size:           4.38 KB
// Last Modified:  2025-11-17T20:08:36.727Z
// =================================================================

"""Combat Orchestrator - Executes calculated skill actions.

Orchestrator pattern that separates action execution from calculation.
Handles the imperative side effects of combat while keeping the engine pure.
"""

import random
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .models import SkillUseResult
    from .state import StateManager
    from .events import EventBus

from .models import ApplyDamageAction, DispatchEventAction, ApplyEffectAction, EffectInstance


class CombatOrchestrator:
    """Orchestrates the execution of calculated combat actions.

    Takes SkillUseResult from CombatEngine and executes the actions
    via StateManager and EventBus. Handles all side effects.
    """

    def __init__(self, state_manager: "StateManager", event_bus: "EventBus", rng=None):
        """Initialize the orchestrator with required dependencies.

        Args:
            state_manager: The state manager for applying entity state changes
            event_bus: The event bus for dispatching combat events
            rng: Optional RNG for effect proc rolls and other random behaviors
        """
        self.state_manager = state_manager
        self.event_bus = event_bus
        self.rng = rng

    def execute_skill_use(self, skill_result: "SkillUseResult") -> None:
        """Execute all actions from a calculated skill use.

        Args:
            skill_result: The calculated result from CombatEngine.calculate_skill_use()
        """
        for action in skill_result.actions:
            if isinstance(action, ApplyDamageAction):
                self._execute_damage_action(action)
            elif isinstance(action, DispatchEventAction):
                self._execute_event_action(action)
            elif isinstance(action, ApplyEffectAction):
                self._execute_effect_action(action)
            else:
                raise ValueError(f"Unknown action type: {type(action)}")

    def _execute_damage_action(self, action: ApplyDamageAction) -> None:
        """Execute a damage application action.

        Args:
            action: The ApplyDamageAction to execute
        """
        self.state_manager.apply_damage(action.target_id, action.damage)

    def _execute_event_action(self, action: DispatchEventAction) -> None:
        """Execute an event dispatching action.

        Args:
            action: The DispatchEventAction to execute
        """
        self.event_bus.dispatch(action.event)

    def _execute_effect_action(self, action: ApplyEffectAction) -> None:
        """Execute an effect application action.

        Handles random proc checks for triggered effects.

        Args:
            action: The ApplyEffectAction to execute
        """
        # Check proc rate if less than 1.0
        should_apply = True
        if action.proc_rate < 1.0:
            rng_value = self.rng.random() if self.rng else random.random()
            should_apply = rng_value < action.proc_rate

        if should_apply:
            # PR8c: Updated to use modern StateManager API instead of legacy compatibility method
            # Create an EffectInstance from the action parameters
            effect = EffectInstance(
                id=f"{action.effect_name}_{action.target_id}",  # Simple unique ID
                definition_id=action.effect_name,
                source_id=action.source,
                time_remaining=10.0,  # Default duration - should be made configurable
                stacks=action.stacks_to_add,
                value=0.0,  # Will be overridden by effect definition
                tick_interval=1.0  # Default tick interval
            )
            self.state_manager.apply_effect(action.target_id, effect)


# Convenience function for executing skill results
def execute_skill_use(skill_result: "SkillUseResult", state_manager: "StateManager", event_bus: "EventBus", rng=None) -> None:
    """Convenience function to execute skill use results.

    Args:
        skill_result: The calculated result from CombatEngine.calculate_skill_use()
        state_manager: The state manager for applying entity state changes
        event_bus: The event bus for dispatching combat events
        rng: Optional RNG for effect proc rolls and other random behaviors
    """
    orchestrator = CombatOrchestrator(state_manager, event_bus, rng)
    orchestrator.execute_skill_use(skill_result)



// =================================================================
// METADATA
// =================================================================
// File Path:      src\data\data_parser.py
// Size:           7.11 KB
// Last Modified:  2025-11-17T10:27:32.979Z
// =================================================================

import csv
import json
import os
import logging
from typing import Dict, Any, List
from .schemas import get_schema_validator

logger = logging.getLogger(__name__)


def parse_csv(filepath: str, schema: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Parse CSV with schema validation.

    Args:
        filepath: Path to CSV file
        schema: Dict specifying required columns and validators

    Returns:
        List of validated row dictionaries

    Raises:
        ValueError: If validation fails
        FileNotFoundError: If file doesn't exist
    """
    with open(filepath, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)

        # Validate columns
        missing = [c for c in schema["required"] if c not in reader.fieldnames]
        if missing:
            raise ValueError(
                f"CSV Schema Error in {filepath}: Missing required columns: {missing}"
            )

        rows = []
        for i, row in enumerate(reader, start=2):  # header is line 1
            validated = {}
            for col, validator in schema["columns"].items():
                raw_value = row.get(col, "")
                try:
                    validated[col] = validator(raw_value)
                except Exception as e:
                    raise ValueError(
                        f"CSV Parse Error in {filepath} at line {i}: "
                        f"Column '{col}', value '{raw_value}': {e}"
                    )
            rows.append(validated)
        return rows


def parse_all_csvs(base_path: str = "data") -> Dict[str, Any]:
    """Parse all CSV files in the data directory using schema validation.

    Args:
        base_path: Path to the data directory

    Returns:
        Dictionary with all parsed CSV data organized by type
    """
    # Convert relative path to absolute
    if not os.path.isabs(base_path):
        base_path = os.path.join(os.path.dirname(__file__), "..", "..", base_path)

    csv_files = [
        ("affixes.csv", "affixes"),
        ("items.csv", "items"),
        ("quality_tiers.csv", "quality_tiers"),
        ("effects.csv", "effects"),
        ("skills.csv", "skills")
    ]

    game_data = {
        "affixes": {},
        "items": {},
        "quality_tiers": [],
        "effects": {},
        "skills": {}
    }

    for filename, data_key in csv_files:
        filepath = os.path.join(base_path, filename)
        if not os.path.exists(filepath):
            logger.warning(f"CSV file not found: {filepath}, skipping")
            continue

        try:
            schema = get_schema_validator(filepath)
            rows = parse_csv(filepath, schema)

            if data_key == "quality_tiers":
                # Special validation for quality tiers: min_range < max_range
                game_data[data_key] = rows
                for row in rows:
                    if row["min_range"] >= row["max_range"]:
                        raise ValueError(
                            f"Quality tier validation error in {filename}: "
                            f"min_range ({row['min_range']}) must be < max_range ({row['max_range']})"
                        )
            elif data_key in ["affixes", "items", "effects", "skills"]:
                # These are keyed by ID
                id_key = list(schema["required"])[0]  # First required column is usually the ID
                for row in rows:
                    game_data[data_key][row[id_key]] = row
            else:
                # quality_tiers is a list
                game_data[data_key] = rows

            logger.info(f"Successfully parsed {filename} ({len(rows)} rows)")

        except Exception as e:
            logger.error(f"Failed to parse {filename}: {e}")
            raise

    return game_data


def parse_csv_data():
    """
    Parses the CSV files into a structured game_data dictionary and saves as JSON.
    """
    data_dir = "data"
    
    # Initialize empty structures
    game_data = {
        "affixes": {},
        "items": {},
        "quality_tiers": []
    }
    
    # Parse affixes.csv
    affixes_path = os.path.join(data_dir, "affixes.csv")
    with open(affixes_path, 'r', newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            affix_id = row['affix_id']
            game_data["affixes"][affix_id] = {
                "affix_id": affix_id,
                "stat_affected": row["stat_affected"],
                "mod_type": row["mod_type"],
                "affix_pools": row["affix_pools"].split('|') if row["affix_pools"] else [],
                "base_value": float(row["base_value"]),
                "description": row["description"]
            }
    
    # Parse items.csv
    items_path = os.path.join(data_dir, "items.csv")
    with open(items_path, 'r', newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            item_id = row['item_id']
            game_data["items"][item_id] = {
                "item_id": item_id,
                "name": row["name"],
                "slot": row["slot"],
                "rarity": row["rarity"],
                "affix_pools": row["affix_pools"].split('|') if row["affix_pools"] else [],
                "implicit_affixes": row["implicit_affixes"].split('|') if row["implicit_affixes"] else [],
                "num_random_affixes": int(row["num_random_affixes"])
            }
    
    # Parse quality_tiers.csv
    tiers_path = os.path.join(data_dir, "quality_tiers.csv")
    with open(tiers_path, 'r', newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            game_data["quality_tiers"].append({
                "quality_id": int(row["quality_id"]),
                "tier_name": row["tier_name"],
                "min_range": int(row["min_range"]),
                "max_range": int(row["max_range"]),
                "Normal": int(row["Normal"]) if row["Normal"] else 0,
                "Common": int(row["Common"]) if row["Common"] else 0,
                "Unusual": int(row["Unusual"]) if row["Unusual"] else 0,
                "Uncommon": int(row["Uncommon"]) if row["Uncommon"] else 0,
                "Rare": int(row["Rare"]) if row["Rare"] else 0,
                "Exotic": int(row["Exotic"]) if row["Exotic"] else 0,
                "Epic": int(row["Epic"]) if row["Epic"] else 0,
                "Glorious": int(row["Glorious"]) if row["Glorious"] else 0,
                "Exalted": int(row["Exalted"]) if row["Exalted"] else 0,
                "Legendary": int(row["Legendary"]) if row["Legendary"] else 0,
                "Mythic": int(row["Mythic"]) if row["Mythic"] else 0,
                "Godly": int(row["Godly"]) if row["Godly"] else 0
            })
    
    # Save to JSON
    output_path = os.path.join(data_dir, "game_data.json")
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(game_data, f, indent=2)
    
    return game_data


if __name__ == "__main__":
    parse_csv_data()
    logger.info("Data parsed and game_data.json created successfully.")



// =================================================================
// METADATA
// =================================================================
// File Path:      src\data\schemas.py
// Size:           8.87 KB
// Last Modified:  2025-11-17T20:17:34.937Z
// =================================================================

"""CSV Schema definitions for data validation.

This module defines validation schemas for all CSV data files.
Each schema specifies required columns and validation functions for their values.
"""

import logging
from typing import Any, Dict, Callable

logger = logging.getLogger(__name__)


def str_validator(value: str) -> str:
    """Validate string values."""
    if value is None:
        return ""
    return str(value).strip()


def int_validator(value: str) -> int:
    """Validate integer values."""
    if not value or value.strip() == "":
        raise ValueError("Value cannot be empty")
    try:
        return int(float(value))  # Handle float strings like "1.0"
    except (ValueError, TypeError):
        raise ValueError(f"Invalid integer value: '{value}'")


def float_validator(value: str) -> float:
    """Validate float values. Can be empty for optional fields."""
    if not value or value.strip() == "":
        # Allow empty values - this should be handled by the lambda wrappers
        raise ValueError("Value cannot be empty")
    try:
        return float(value)
    except (ValueError, TypeError):
        raise ValueError(f"Invalid float value: '{value}'")


def flexible_float_validator(value: str) -> str:
    """Validate float values or semicolon-separated float values for complex affixes."""
    if not value or value.strip() == "":
        return ""  # Allow empty values

    # Check if it's semicolon-separated values
    if ";" in value:
        # Validate each part is a float
        parts = value.split(";")
        try:
            for part in parts:
                part = part.strip()
                if part:  # Allow empty parts
                    float(part)
            return value.strip()
        except ValueError:
            raise ValueError(f"Invalid float values in semicolon-separated list: '{value}'")

    # Single float value
    try:
        float(value.strip())
        return value.strip()
    except ValueError:
        raise ValueError(f"Invalid float value: '{value}'")





def flexible_damage_validator(value: str) -> float:
    """Validate damage values - can be empty (0.0) or any float (including negative for healing)."""
    if not value or value.strip() == "":
        return 0.0  # Empty is default damage
    try:
        return float(value)
    except ValueError:
        raise ValueError(f"Invalid damage value: '{value}'")


def positive_float_validator(value: str) -> float:
    """Validate positive float values."""
    val = float_validator(value)
    if val <= 0:
        raise ValueError(f"Value must be > 0, got {val}")
    return val


def non_negative_float_validator(value: str) -> float:
    """Validate non-negative float values."""
    val = float_validator(value)
    if val < 0:
        raise ValueError(f"Value must be >= 0, got {val}")
    return val


def quality_id_validator(value: str) -> int:
    """Validate quality tier IDs."""
    val = int_validator(value)
    if val < 1:
        raise ValueError(f"Quality ID must be >= 1, got {val}")
    return val


def tier_range_validator(min_val: str, max_val: str) -> tuple[int, int]:
    """Validate tier range values and ensure min < max."""
    min_range = int_validator(min_val)
    max_range = int_validator(max_val)
    if min_range >= max_range:
        raise ValueError(f"Min range ({min_range}) must be < max range ({max_range})")
    return min_range, max_range


def affix_pools_validator(value: str) -> list[str]:
    """Validate affix pools - can be empty or pipe-separated string."""
    if not value or value.strip() == "":
        return []
    return [pool.strip() for pool in value.split('|') if pool.strip()]


def tier_probabilities_validator(value: str) -> int:
    """Validate tier probabilities - can be empty (0) or positive integer."""
    if not value or value.strip() == "":
        return 0
    val = int_validator(value)
    if val < 0:
        raise ValueError(f"Tier probability must be >= 0, got {val}")
    return val


# Schema definitions
AFFIX_SCHEMA = {
    "required": ["affix_id", "stat_affected", "mod_type", "base_value", "description"],
    "columns": {
        "affix_id": str_validator,
        "stat_affected": str_validator,
        "mod_type": str_validator,
        "affix_pools": affix_pools_validator,
        "base_value": flexible_float_validator,
        "description": str_validator,
        "trigger_event": str_validator,
        "proc_rate": lambda x: float_validator(x) if x and x.strip() else 0.0,
        "trigger_result": str_validator,
        "trigger_duration": lambda x: non_negative_float_validator(x) if x and x.strip() else 0.0,
        "stacks_max": lambda x: int_validator(x) if x and x.strip() else 1,
        "dual_stat": lambda x: x.upper() == "TRUE" if x and x.strip() else False,
        "scaling_power": lambda x: x.upper() == "TRUE" if x and x.strip() else False,
        "complex_effect": str_validator,
    },
}

ITEM_SCHEMA = {
    "required": ["item_id", "name", "slot", "rarity", "num_random_affixes"],
    "columns": {
        "item_id": str_validator,
        "name": str_validator,
        "slot": str_validator,
        "rarity": str_validator,
        "affix_pools": affix_pools_validator,
        "implicit_affixes": affix_pools_validator,  # Same validation as affix_pools
        "num_random_affixes": lambda x: int_validator(x) if x and x.strip() else 0,
    },
}

QUALITY_TIERS_SCHEMA = {
    "required": ["quality_id", "tier_name", "min_range", "max_range"],
    "columns": {
        "quality_id": quality_id_validator,
        "tier_name": str_validator,
        "min_range": int_validator,
        "max_range": int_validator,
        # Rarity probability columns (can be empty for 0)
        "Normal": tier_probabilities_validator,
        "Common": tier_probabilities_validator,
        "Unusual": tier_probabilities_validator,
        "Uncommon": tier_probabilities_validator,
        "Rare": tier_probabilities_validator,
        "Exotic": tier_probabilities_validator,
        "Epic": tier_probabilities_validator,
        "Glorious": tier_probabilities_validator,
        "Exalted": tier_probabilities_validator,
        "Legendary": tier_probabilities_validator,
        "Mythic": tier_probabilities_validator,
        "Godly": tier_probabilities_validator,
    },
}

EFFECTS_SCHEMA = {
    "required": ["effect_id", "name", "type", "description"],
    "columns": {
        "effect_id": str_validator,
        "name": str_validator,
        "type": str_validator,
        "description": str_validator,
        "max_stacks": lambda x: int_validator(x) if x and x.strip() else 1,
        "tick_rate": lambda x: non_negative_float_validator(x) if x and x.strip() else 1.0,
        "damage_per_tick": flexible_damage_validator,
        "stat_multiplier": lambda x: float_validator(x) if x and x.strip() else 0.0,
        "stat_add": lambda x: float_validator(x) if x and x.strip() else 0.0,
        "visual_effect": str_validator,
        "duration": lambda x: non_negative_float_validator(x) if x and x.strip() else 10.0,  # Default to 10 if empty
    },
}

SKILLS_SCHEMA = {
    "required": ["skill_id", "name", "damage_type"],
    "columns": {
        "skill_id": str_validator,
        "name": str_validator,
        "damage_type": str_validator,
        "hits": lambda x: int_validator(x) if x and x.strip() else 1,
        "description": str_validator,
        "resource_cost": lambda x: non_negative_float_validator(x) if x and x.strip() else 0.0,
        "cooldown": lambda x: non_negative_float_validator(x) if x and x.strip() else 0.0,
        "trigger_event": str_validator,
        "proc_rate": lambda x: float_validator(x) if x and x.strip() else 0.0,
        "trigger_result": str_validator,
        "trigger_duration": lambda x: non_negative_float_validator(x) if x and x.strip() else 0.0,
        "stacks_max": lambda x: int_validator(x) if x and x.strip() else 1,
    },
}


def get_schema_validator(filepath: str) -> Dict[str, Any]:
    """Get the appropriate schema validator for a CSV file based on its path.

    Args:
        filepath: Path to the CSV file

    Returns:
        Schema dictionary with validation rules

    Raises:
        ValueError: If no schema matches the file
    """
    filename = filepath.lower()

    if "affixes" in filename and filename.endswith(".csv"):
        return AFFIX_SCHEMA
    elif "items" in filename and filename.endswith(".csv"):
        return ITEM_SCHEMA
    elif "quality_tiers" in filename and filename.endswith(".csv"):
        return QUALITY_TIERS_SCHEMA
    elif "effects" in filename and filename.endswith(".csv"):
        return EFFECTS_SCHEMA
    elif "skills" in filename and filename.endswith(".csv"):
        return SKILLS_SCHEMA
    else:
        raise ValueError(f"No schema found for CSV file: {filepath}")



// =================================================================
// METADATA
// =================================================================
// File Path:      src\data\typed_models.py
// Size:           13.43 KB
// Last Modified:  2025-11-19T10:32:58.942Z
// =================================================================

"""Typed data models for game data with strict typing and enums.

This module defines dataclasses and enums for all core game data structures.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional, Dict, Any, Type, TypeVar

T = TypeVar('T', bound=Enum)

# ========== Enums ==========

class Rarity(str, Enum):
    """Enum for item and entity rarity tiers."""
    COMMON = "Common"
    UNCOMMON = "Uncommon"
    RARE = "Rare"
    EPIC = "Epic"
    LEGENDARY = "Legendary"
    MYTHIC = "Mythic"
    MAGIC = "Magic"

class ItemSlot(str, Enum):
    """Enum for equipment slots."""
    WEAPON = "Weapon"
    OFF_HAND = "OffHand"
    HEAD = "Head"
    CHEST = "Chest"
    LEGS = "Legs"
    FEET = "Feet"
    HANDS = "Hands"
    RING = "Ring"
    AMULET = "Amulet"
    BELT = "Belt"
    SHOULDERS = "Shoulders"
    CLOAK = "Cloak"
    QUIVER = "Quiver"
    ACCESSORY = "Accessory"

class ModType(str, Enum):
    """Enum for affix modification types."""
    FLAT = "flat"
    MULTIPLIER = "multiplier"
    SCALING = "scaling"

class DamageType(str, Enum):
    """Enum for damage types."""
    PHYSICAL = "Physical"
    FIRE = "Fire"
    COLD = "Cold"
    LIGHTNING = "Lightning"
    POISON = "Poison"
    ACID = "Acid"
    EARTH = "Earth"
    DARK = "Dark"
    LIGHT = "Light"
    MAGIC = "Magic"
    SHADOW = "Shadow"
    DIVINE = "Divine"
    PIERCING = "Piercing"

class EffectType(str, Enum):
    """Enum for effect types."""
    BUFF = "Buff"
    DEBUFF = "Debuff"
    DOT = "DoT"
    HOT = "HoT"
    STUN = "Stun"
    ROOT = "Root"
    SILENCE = "Silence"
    IMMUNE = "Immune"
    SPECIAL = "Special"

class TriggerEvent(str, Enum):
    """Enum for trigger events."""
    ON_HIT = "OnHit"
    ON_KILL = "OnKill"
    ON_DAMAGE_TAKEN = "OnDamageTaken"
    ON_CRIT = "OnCrit"
    ON_EVADE = "OnEvade"
    ON_BLOCK = "OnBlock"
    ON_DODGE = "OnDodge"
    ON_SKILL_USED = "OnSkillUsed"
    ON_USE = "OnUse"
    ON_SELF = "OnSelf"


# ========== Data Classes ==========

@dataclass
class AffixDefinition:
    """Strongly-typed model for affix data from CSV."""
    affix_id: str
    stat_affected: str
    mod_type: str
    base_value: str
    description: str
    affix_pools: List[str] = field(default_factory=list)
    trigger_event: Optional[TriggerEvent] = None
    proc_rate: float = 0.0
    trigger_result: str = ""
    trigger_duration: float = 10.0
    stacks_max: int = 1
    dual_stat: bool = False
    scaling_power: bool = False
    complex_effect: str = ""

    def __post_init__(self):
        if not self.affix_id:
            raise ValueError("affix_id cannot be empty")
        if not self.stat_affected:
            raise ValueError("stat_affected cannot be empty")
        
        # Validate dual_stat flag
        has_semicolon = ";" in self.base_value
        if self.dual_stat != has_semicolon:
            # Allow exception for non-numeric base values that might not match this rule strictly
            # but warn if it looks like a stat value
            pass 

    def get_mod_types(self) -> List[ModType]:
        parts = self.mod_type.split(';')
        return [ModType(part.strip()) for part in parts]

@dataclass
class ItemTemplate:
    """Strongly-typed model for item template data."""
    item_id: str
    name: str
    slot: ItemSlot
    rarity: Rarity
    affix_pools: List[str] = field(default_factory=list)
    implicit_affixes: List[str] = field(default_factory=list)
    num_random_affixes: int = 0

    def __post_init__(self):
        if not self.item_id:
            raise ValueError("item_id cannot be empty")
        if not self.name:
            raise ValueError("name cannot be empty")
        if self.num_random_affixes < 0:
            raise ValueError("num_random_affixes must be non-negative")

@dataclass
class QualityTier:
    """Strongly-typed model for quality tier data."""
    quality_id: int
    tier_name: str
    min_range: int
    max_range: int
    common: int = 0
    uncommon: int = 0
    rare: int = 0
    epic: int = 0
    legendary: int = 0
    mythic: int = 0

    def __post_init__(self):
        if self.quality_id < 1:
            raise ValueError("quality_id must be >= 1")
        if self.min_range >= self.max_range:
            raise ValueError(f"min_range ({self.min_range}) must be < max_range ({self.max_range})")

    def get_probability_for_rarity(self, rarity: Rarity) -> int:
        return getattr(self, rarity.value.lower())

@dataclass
class EffectDefinition:
    """Strongly-typed model for effect data."""
    effect_id: str
    name: str
    type: EffectType
    description: str
    max_stacks: int = 1
    tick_rate: float = 1.0
    damage_per_tick: float = 0.0
    stat_multiplier: float = 0.0
    stat_add: float = 0.0
    visual_effect: str = ""
    duration: float = 10.0

    def __post_init__(self):
        if not self.effect_id:
            raise ValueError("effect_id cannot be empty")
        if not self.name:
            raise ValueError("name cannot be empty")

@dataclass
class SkillDefinition:
    """Strongly-typed model for skill data."""
    skill_id: str
    name: str
    damage_type: DamageType
    hits: int = 1
    description: str = ""
    resource_cost: float = 0.0
    cooldown: float = 0.0
    trigger_event: Optional[TriggerEvent] = None
    proc_rate: float = 0.0
    trigger_result: str = ""
    trigger_duration: float = 10.0
    stacks_max: int = 1

    def __post_init__(self):
        if not self.skill_id:
            raise ValueError("skill_id cannot be empty")
        if not self.name:
            raise ValueError("name cannot be empty")


# ========== Exception Classes ==========

class DataValidationError(ValueError):
    """Exception raised when data validation fails."""
    def __init__(self, message: str, data_type: str = "", field_name: str = "",
                 invalid_id: str = "", suggestions: Optional[List[str]] = None):
        super().__init__(message)
        self.data_type = data_type
        self.field_name = field_name
        self.invalid_id = invalid_id
        self.suggestions = suggestions or []

    def __str__(self):
        msg = super().__str__()
        if self.suggestions:
            msg += f"\nSuggestions: {', '.join(self.suggestions)}"
        return msg


# ========== Utility Functions ==========

def validate_entity_stats_are_valid(stats_list: List[str]) -> None:
    """Validate that all stat names are valid EntityStats attributes."""
    from ..models import EntityStats
    valid_stats = set(vars(EntityStats(0, 1)).keys())
    for stat_name in stats_list:
        if stat_name and stat_name not in valid_stats:
            raise DataValidationError(
                f"Invalid stat name '{stat_name}'",
                data_type="EntityStats",
                field_name="stat_affected",
                invalid_id=stat_name,
                suggestions=list(valid_stats)
            )

def parse_affix_pools(value: str) -> List[str]:
    """Parse affix pools from pipe-separated string."""
    if isinstance(value, list):
        return value
    if not value or (isinstance(value, str) and value.strip() == ""):
        return []
    if isinstance(value, str):
        return [pool.strip() for pool in value.split('|') if pool.strip()]
    return []

def normalize_enum(enum_cls: Type[T], value: str, default: Optional[T] = None) -> T:
    """Helper to fuzzy-match strings to Enum values (case-insensitive)."""
    if not value:
        if default is not None:
            return default
        raise ValueError(f"Empty value for {enum_cls.__name__}")
        
    # Try direct lookup
    try:
        return enum_cls(value)
    except ValueError:
        pass
        
    # Try case-insensitive lookup
    normalized = value.strip().lower()
    
    # Manual mapping for legacy/alternate terms
    mappings = {
        'ItemSlot': {
            'offhand': ItemSlot.OFF_HAND,
            'off-hand': ItemSlot.OFF_HAND,
            'helmet': ItemSlot.HEAD,
            'helm': ItemSlot.HEAD,
            'armor': ItemSlot.CHEST,
            'boots': ItemSlot.FEET,
            'gloves': ItemSlot.HANDS,
            'pants': ItemSlot.LEGS,
            'jewelry': ItemSlot.ACCESSORY, # Fallback
            'shield': ItemSlot.OFF_HAND,
        },
        'DamageType': {
            'piercing': DamageType.PIERCING,
            'physical': DamageType.PHYSICAL,
            'acid': DamageType.ACID, # Map to new Acid type
        }
    }
    
    # Apply specific mappings if they exist
    if enum_cls.__name__ in mappings and normalized in mappings[enum_cls.__name__]:
        return mappings[enum_cls.__name__][normalized]
        
    # General case-insensitive search
    for member in enum_cls:
        if member.value.lower() == normalized:
            return member
            
    raise ValueError(f"Invalid {enum_cls.__name__}: '{value}'")

# ========== Hydration Functions ==========

def hydrate_affix_definition(raw_data: Dict[str, Any]) -> AffixDefinition:
    return AffixDefinition(
        affix_id=raw_data['affix_id'],
        stat_affected=raw_data['stat_affected'],
        mod_type=raw_data['mod_type'],
        base_value=raw_data['base_value'],
        description=raw_data['description'],
        affix_pools=parse_affix_pools(raw_data.get('affix_pools', '')),
        trigger_event=normalize_enum(TriggerEvent, raw_data['trigger_event']) if raw_data.get('trigger_event') else None,
        proc_rate=float(raw_data['proc_rate']) if raw_data.get('proc_rate') else 0.0,
        trigger_result=raw_data.get('trigger_result', ''),
        trigger_duration=float(raw_data['trigger_duration']) if raw_data.get('trigger_duration') else 10.0,
        stacks_max=int(raw_data['stacks_max']) if raw_data.get('stacks_max') else 1,
        dual_stat=bool(raw_data.get('dual_stat', False)),
        scaling_power=bool(raw_data.get('scaling_power', False)),
        complex_effect=raw_data.get('complex_effect', '')
    )

def hydrate_item_template(raw_data: Dict[str, Any]) -> ItemTemplate:
    implicit_affixes_raw = raw_data.get('implicit_affixes', '')
    if isinstance(implicit_affixes_raw, list):
        implicit_affixes = implicit_affixes_raw
    else:
        implicit_affixes = parse_affix_pools(implicit_affixes_raw)

    return ItemTemplate(
        item_id=raw_data['item_id'],
        name=raw_data['name'],
        slot=normalize_enum(ItemSlot, raw_data['slot']),
        rarity=normalize_enum(Rarity, raw_data['rarity']),
        affix_pools=parse_affix_pools(raw_data.get('affix_pools', '')),
        implicit_affixes=implicit_affixes,
        num_random_affixes=int(raw_data['num_random_affixes']) if raw_data.get('num_random_affixes') else 0
    )

def hydrate_quality_tier(raw_data: Dict[str, Any]) -> QualityTier:
    return QualityTier(
        quality_id=int(raw_data['quality_id']),
        tier_name=raw_data['tier_name'],
        min_range=int(raw_data['min_range']),
        max_range=int(raw_data['max_range']),
        common=int(raw_data.get('Common', 0)) if raw_data.get('Common') else 0,
        uncommon=int(raw_data.get('Uncommon', 0)) if raw_data.get('Uncommon') else 0,
        rare=int(raw_data.get('Rare', 0)) if raw_data.get('Rare') else 0,
        epic=int(raw_data.get('Epic', 0)) if raw_data.get('Epic') else 0,
        legendary=int(raw_data.get('Legendary', 0)) if raw_data.get('Legendary') else 0,
        mythic=int(raw_data.get('Mythic', 0)) if raw_data.get('Mythic') else 0
    )

def hydrate_effect_definition(raw_data: Dict[str, Any]) -> EffectDefinition:
    return EffectDefinition(
        effect_id=raw_data['effect_id'],
        name=raw_data['name'],
        type=normalize_enum(EffectType, raw_data['type']),
        description=raw_data['description'],
        max_stacks=int(raw_data['max_stacks']) if raw_data.get('max_stacks') else 1,
        tick_rate=float(raw_data['tick_rate']) if raw_data.get('tick_rate') else 1.0,
        damage_per_tick=float(raw_data['damage_per_tick']) if raw_data.get('damage_per_tick') else 0.0,
        stat_multiplier=float(raw_data['stat_multiplier']) if raw_data.get('stat_multiplier') else 0.0,
        stat_add=float(raw_data['stat_add']) if raw_data.get('stat_add') else 0.0,
        visual_effect=raw_data.get('visual_effect', ''),
        duration=float(raw_data['duration']) if raw_data.get('duration') else 10.0
    )

def hydrate_skill_definition(raw_data: Dict[str, Any]) -> SkillDefinition:
    return SkillDefinition(
        skill_id=raw_data['skill_id'],
        name=raw_data['name'],
        damage_type=normalize_enum(DamageType, raw_data['damage_type']),
        hits=int(raw_data['hits']) if raw_data.get('hits') else 1,
        description=raw_data.get('description', ''),
        resource_cost=float(raw_data['resource_cost']) if raw_data.get('resource_cost') else 0.0,
        cooldown=float(raw_data['cooldown']) if raw_data.get('cooldown') else 0.0,
        trigger_event=normalize_enum(TriggerEvent, raw_data['trigger_event']) if raw_data.get('trigger_event') else None,
        proc_rate=float(raw_data['proc_rate']) if raw_data.get('proc_rate') else 0.0,
        trigger_result=raw_data.get('trigger_result', ''),
        trigger_duration=float(raw_data['trigger_duration']) if raw_data.get('trigger_duration') else 10.0,
        stacks_max=int(raw_data['stacks_max']) if raw_data.get('stacks_max') else 1
    )



// =================================================================
// METADATA
// =================================================================
// File Path:      src\data_loader.py
// Size:           12.81 KB
// Last Modified:  2025-11-16T14:18:40.886Z
// =================================================================

"""
Master Rule Data System - CSV-driven data loading for combat mechanics.
Phase 4: Complete data-driven combat system.
"""

import csv
import os
import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from .skills import Skill, Trigger
from .models import RolledAffix


@dataclass
class EffectDefinition:
    """Complete definition of an effect loaded from effects.csv"""
    effect_id: str
    name: str
    type: str  # 'buff', 'debuff', 'dot', 'stun', etc.
    description: str
    max_stacks: int = 1
    tick_rate: float = 0.0  # Seconds between ticks
    damage_per_tick: float = 0.0
    stat_multiplier: float = 0.0  # Multiplier to stats
    stat_add: float = 0.0  # Flat add to stats
    visual_effect: str = ""
    duration: float = 0.0

    def __post_init__(self):
        """Validate and convert types from CSV strings"""
        self.max_stacks = int(self.max_stacks)
        self.tick_rate = float(self.tick_rate)
        self.damage_per_tick = float(self.damage_per_tick)
        self.stat_multiplier = float(self.stat_multiplier)
        self.stat_add = float(self.stat_add)
        self.duration = float(self.duration)


@dataclass
class LoadedSkill:
    """Complete skill definition loaded from skills.csv"""
    skill_id: str
    name: str
    damage_type: str = "Physical"
    hits: int = 1
    description: str = ""
    resource_cost: float = 0.0
    cooldown: float = 0.0
    triggers: List[Trigger] = field(default_factory=list)

    def __post_init__(self):
        """Validate and convert types"""
        self.hits = int(self.hits)
        self.resource_cost = float(self.resource_cost)
        self.cooldown = float(self.cooldown)

    def to_skill_object(self) -> Skill:
        """Convert to runtime Skill object"""
        return Skill(
            id=self.skill_id,
            name=self.name,
            damage_type=self.damage_type,
            hits=self.hits,
            triggers=self.triggers
        )


logger = logging.getLogger(__name__)


class MasterRuleData:
    """Central repository for all CSV-driven combat data.
    Phase 4: Complete data-driven combat system."""

    def __init__(self, data_directory: str = "data"):
        self.data_dir = data_directory
        self.affixes: Dict[str, RolledAffix] = {}
        self.skills: Dict[str, LoadedSkill] = {}
        self.effects: Dict[str, EffectDefinition] = {}

        # Load all data on initialization
        self._load_all_data()

    def _load_all_data(self):
        """Load all CSV data files"""
        self._load_affixes()
        self._load_skills()
        self._load_effects()

    def _load_affixes(self):
        """Load affixes.csv into RolledAffix objects"""
        path = os.path.join(self.data_dir, "affixes.csv")
        if not os.path.exists(path):
            logger.warning("affixes.csv not found at %s", path)
            return

        with open(path, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                try:
                    # Skip comments and invalid rows
                    if not row.get('affix_id') or row['affix_id'].startswith('#'):
                        continue

                    # Safe type conversions with fallbacks
                    try:
                        value = float(row.get('value', '0'))
                    except ValueError:
                        value = 0.0

                    try:
                        proc_rate_str = row.get('proc_rate', '0').strip()
                        proc_rate = float(proc_rate_str) if proc_rate_str else None
                    except (ValueError, TypeError):
                        proc_rate = None

                    try:
                        trigger_duration_str = row.get('trigger_duration', '0').strip()
                        trigger_duration = float(trigger_duration_str) if trigger_duration_str else None
                    except (ValueError, TypeError):
                        trigger_duration = None

                    try:
                        stacks_max_str = row.get('stacks_max', '1').strip()
                        stacks_max = int(stacks_max_str) if stacks_max_str else None
                    except (ValueError, TypeError):
                        stacks_max = None

                    try:
                        scaling_power_str = row.get('scaling_power', '').strip().lower()
                        scaling_power = scaling_power_str == 'true'
                    except:
                        scaling_power = False

                    affix = RolledAffix(
                        affix_id=row['affix_id'],
                        stat_affected=row['stat_affected'],
                        mod_type=row['mod_type'],
                        affix_pools=row.get('affix_pools', ''),
                        description=row['description'],
                        base_value=row.get('base_value', ''),
                        value=value,
                        trigger_event=row.get('trigger_event', '').strip() or None,
                        proc_rate=proc_rate,
                        trigger_result=row.get('trigger_result', '').strip() or None,
                        trigger_duration=trigger_duration,
                        stacks_max=stacks_max,
                        dual_stat=row.get('dual_stat', '').strip() or None,
                        scaling_power=scaling_power,
                        complex_effect=row.get('complex_effect', '').strip() or None
                    )
                    self.affixes[affix.affix_id] = affix

                except Exception as e:
                    logger.error("Error loading affix %s: %s", row.get('affix_id', 'unknown'), e)

    def _load_skills(self):
        """Load skills.csv into LoadedSkill objects"""
        path = os.path.join(self.data_dir, "skills.csv")
        if not os.path.exists(path):
            logger.warning("skills.csv not found at %s", path)
            return

        with open(path, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                try:
                    # Parse triggers for this skill
                    triggers = []
                    if row.get('trigger_event') and row.get('proc_rate') and row.get('trigger_result'):
                        result_dict = {}

                        # Parse trigger result (same logic as affixes)
                        if ':' in row['trigger_result']:
                            effect_name, effect_value = row['trigger_result'].split(':', 1)
                            try:
                                result_dict[effect_name] = float(effect_value)
                            except ValueError:
                                result_dict[effect_name] = effect_value
                        else:
                            result_dict["apply_debuff"] = row['trigger_result']

                        # Add metadata
                        result_dict["duration"] = float(row.get('trigger_duration', '10.0'))
                        result_dict["stacks_max"] = int(row.get('stacks_max', '1'))

                        trigger = Trigger(
                            event=row['trigger_event'],
                            check={"proc_rate": float(row['proc_rate'])},
                            result=result_dict
                        )
                        triggers.append(trigger)

                    # Create LoadedSkill
                    skill = LoadedSkill(
                        skill_id=row['skill_id'],
                        name=row['name'],
                        damage_type=row.get('damage_type', 'Physical'),
                        hits=int(row.get('hits', '1')),
                        description=row.get('description', ''),
                        resource_cost=float(row.get('resource_cost', '0')),
                        cooldown=float(row.get('cooldown', '0')),
                        triggers=triggers
                    )
                    self.skills[skill.skill_id] = skill

                except Exception as e:
                    logger.error("Error loading skill %s: %s", row.get('skill_id', 'unknown'), e)

    def _load_effects(self):
        """Load effects.csv into EffectDefinition objects"""
        path = os.path.join(self.data_dir, "effects.csv")
        if not os.path.exists(path):
            logger.warning("effects.csv not found at %s", path)
            return

        with open(path, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                try:
                    effect = EffectDefinition(
                        effect_id=row['effect_id'],
                        name=row['name'],
                        type=row['type'],
                        description=row['description'],
                        max_stacks=int(row.get('max_stacks', '1')),
                        tick_rate=float(row.get('tick_rate', '0')),
                        damage_per_tick=float(row.get('damage_per_tick', '0')),
                        stat_multiplier=float(row.get('stat_multiplier', '0')),
                        stat_add=float(row.get('stat_add', '0')),
                        visual_effect=row.get('visual_effect', ''),
                        duration=float(row.get('duration', '0'))
                    )
                    self.effects[effect.effect_id] = effect

                except Exception as e:
                    logger.error("Error loading effect %s: %s", row.get('effect_id', 'unknown'), e)

    # Query methods
    def get_affix(self, affix_id: str) -> Optional[RolledAffix]:
        """Get affix by ID"""
        return self.affixes.get(affix_id)

    def get_skill(self, skill_id: str) -> Optional[LoadedSkill]:
        """Get skill by ID"""
        return self.skills.get(skill_id)

    def get_effect(self, effect_id: str) -> Optional[EffectDefinition]:
        """Get effect by ID"""
        return self.effects.get(effect_id)

    def get_all_affixes(self) -> List[RolledAffix]:
        """Get all loaded affixes"""
        return list(self.affixes.values())

    def get_all_skills(self) -> List[LoadedSkill]:
        """Get all loaded skills"""
        return list(self.skills.values())

    def get_all_effects(self) -> List[EffectDefinition]:
        """Get all loaded effects"""
        return list(self.effects.values())

    def find_affixes_by_pool(self, pool_name: str) -> List[RolledAffix]:
        """Find affixes that can appear in a given affix pool"""
        return [affix for affix in self.affixes.values()
                if pool_name in affix.affix_pools]

    def find_skills_by_type(self, skill_type: str) -> List[LoadedSkill]:
        """Find skills by damage type (Physical, Magic, etc.)"""
        return [skill for skill in self.skills.values()
                if skill.damage_type == skill_type]

    # Statistics methods
    def get_data_stats(self) -> Dict[str, int]:
        """Get statistics about loaded data"""
        return {
            'affixes': len(self.affixes),
            'skills': len(self.skills),
            'effects': len(self.effects)
        }

    def validate_data_consistency(self) -> List[str]:
        """Validate that all referenced effects and triggers exist"""
        issues = []

        # Check if skill trigger results reference valid effects
        for skill_id, skill in self.skills.items():
            for trigger in skill.triggers:
                if "apply_debuff" in trigger.result:
                    debuff_name = trigger.result["apply_debuff"]
                    if debuff_name not in self.effects:
                        issues.append(f"Skill {skill_id} references unknown debuff '{debuff_name}'")

        # Check if affix trigger results reference valid effects
        for affix_id, affix in self.affixes.items():
            if affix.trigger_result and affix.trigger_result not in self.effects:
                # Skip if it's a complex effect (contains colon)
                if ':' not in affix.trigger_result:
                    issues.append(f"Affix {affix_id} references unknown debuff '{affix.trigger_result}'")

        return issues


# Global instance for easy access
_global_data_loader = None

def get_data_loader() -> MasterRuleData:
    """Get the global data loader instance"""
    global _global_data_loader
    if _global_data_loader is None:
        _global_data_loader = MasterRuleData()
    return _global_data_loader

def reload_data() -> MasterRuleData:
    """Reload all CSV data (useful for development)"""
    global _global_data_loader
    _global_data_loader = MasterRuleData()
    return _global_data_loader



// =================================================================
// METADATA
// =================================================================
// File Path:      src\effect_handlers.py
// Size:           7.46 KB
// Last Modified:  2025-11-17T19:46:17.879Z
// =================================================================

"""Effect handlers for combat events - secondary effects like DoTs."""

import random
import logging
from abc import ABC, abstractmethod
from .events import EventBus, OnHitEvent
from .state import StateManager
from .models import DamageOnHitConfig

logger = logging.getLogger(__name__)


# Effect Configuration Constants - can be moved to data files in future
BLEED_CONFIG = DamageOnHitConfig(
    debuff_name="Bleed",
    proc_rate=0.5,
    duration=5.0,
    damage_per_tick=2.5,  # Example: 2.5 damage per stack per tick
    stacks_to_add=1,
    display_message="Bleed proc'd on {target}!"
)

POISON_CONFIG = DamageOnHitConfig(
    debuff_name="Poison",
    proc_rate=0.33,
    duration=8.0,
    damage_per_tick=1.5,  # Example: 1.5 damage per stack per tick
    stacks_to_add=1,
    display_message="Poison proc'd on {target}!"
)


# Legacy Handler Functions - for backward compatibility during transition
def create_bleed_handler(event_bus, state_manager, rng=None):
    """Create a BleedHandler using the generic DamageOnHitHandler."""
    return DamageOnHitHandler(BLEED_CONFIG, event_bus, state_manager, rng)


def create_poison_handler(event_bus, state_manager, rng=None):
    """Create a PoisonHandler using the generic DamageOnHitHandler."""
    return DamageOnHitHandler(POISON_CONFIG, event_bus, state_manager, rng)


class EffectHandler(ABC):
    """Base class for effect handlers that respond to combat events.

    Provides common functionality for subscribing to events and managing
    effect application logic.
    """

    def __init__(self, event_bus: EventBus, state_manager: StateManager, rng=None):
        """Initialize the effect handler.

        Args:
            event_bus: The event bus to subscribe to
            state_manager: The state manager for applying effects
            rng: Random number generator for deterministic testing. If None,
                 uses random.random() without seeding.
        """
        self.event_bus = event_bus
        self.state_manager = state_manager
        self.rng = rng

    @abstractmethod
    def setup_subscriptions(self):
        """Set up event subscriptions. Must be implemented by subclasses."""
        pass


class DamageOnHitHandler(EffectHandler):
    """Generic handler for damage-over-time effects applied on hit events.

    Configured via DamageOnHitConfig for data-driven effect creation.
    Enables adding new DoT effects without code changes.
    """

    def __init__(self, config: DamageOnHitConfig, event_bus: EventBus, state_manager: StateManager, rng=None):
        """Initialize the generic damage-on-hit handler.

        Args:
            config: Configuration for this effect (name, proc_rate, duration, etc.)
            event_bus: The event bus to subscribe to
            state_manager: The state manager for applying effects
            rng: Random number generator for deterministic testing. If None,
                 uses random.random() without seeding.
        """
        super().__init__(event_bus, state_manager, rng)
        self.config = config
        self.setup_subscriptions()

    def setup_subscriptions(self):
        """Set up event subscriptions for this effect."""
        self.event_bus.subscribe(OnHitEvent, self.handle_on_hit)

    def handle_on_hit(self, event: OnHitEvent, rng=None) -> None:
        """Handle an OnHitEvent by potentially applying the configured effect.

        Args:
            event: The hit event that occurred
            rng: RNG passed explicitly (per PR6 specification)
        """
        if rng is None:
            rng = self.rng or random
        rng_value = rng.random()
        if rng_value < self.config.proc_rate:
            # Display message if configured
            if self.config.display_message:
                target_name = getattr(event.defender, 'name', event.defender.id)
                message = self.config.display_message.format(target=target_name)
                logger.debug("Effect proc: %s", message)
            else:
                # Default message format
                message = f"{self.config.debuff_name} proc'd on {event.defender.id}!"
                logger.debug("Effect proc: %s", message)

            self.state_manager.apply_debuff(
                entity_id=event.defender.id,
                debuff_name=self.config.debuff_name,
                stacks_to_add=self.config.stacks_to_add,
                max_duration=self.config.duration
            )


class BleedHandler(EffectHandler):
    """Handles Bleed DoT application on hit events."""

    def __init__(self, event_bus: EventBus, state_manager: StateManager, proc_rate: float = 0.5, rng=None):
        """Initialize the Bleed handler.

        Args:
            event_bus: The event bus to subscribe to
            state_manager: The state manager for applying debuffs
            proc_rate: Probability of bleed procing on hit (0.0 to 1.0)
            rng: Random number generator for deterministic testing. If None,
                 uses random.random() without seeding.
        """
        super().__init__(event_bus, state_manager, rng)
        self.proc_rate = proc_rate
        self.setup_subscriptions()

    def setup_subscriptions(self):
        """Set up event subscriptions for Bleed effects."""
        self.event_bus.subscribe(OnHitEvent, self.handle_on_hit)

    def handle_on_hit(self, event: OnHitEvent) -> None:
        """Handle an OnHitEvent by potentially applying Bleed.

        Args:
            event: The hit event that occurred
        """
        rng_value = self.rng.random() if self.rng else random.random()
        if rng_value < self.proc_rate:
            logger.debug("Effect proc: Bleed procd on %s", event.defender.id)
            self.state_manager.apply_debuff(
                entity_id=event.defender.id,
                debuff_name="Bleed",
                stacks_to_add=1,
                max_duration=5.0  # Example duration
            )


class PoisonHandler(EffectHandler):
    """Handles Poison DoT application on hit events."""

    def __init__(self, event_bus: EventBus, state_manager: StateManager, proc_rate: float = 0.33, rng=None):
        """Initialize the Poison handler.

        Args:
            event_bus: The event bus to subscribe to
            state_manager: The state manager for applying debuffs
            proc_rate: Probability of poison procing on hit (0.0 to 1.0)
            rng: Random number generator for deterministic testing. If None,
                 uses random.random() without seeding.
        """
        super().__init__(event_bus, state_manager, rng)
        self.proc_rate = proc_rate
        self.setup_subscriptions()

    def setup_subscriptions(self):
        """Set up event subscriptions for Poison effects."""
        self.event_bus.subscribe(OnHitEvent, self.handle_on_hit)

    def handle_on_hit(self, event: OnHitEvent) -> None:
        """Handle an OnHitEvent by potentially applying Poison.

        Args:
            event: The hit event that occurred
        """
        rng_value = self.rng.random() if self.rng else random.random()
        if rng_value < self.proc_rate:
            logger.debug("Effect proc: Poison procd on %s", event.defender.id)
            self.state_manager.apply_debuff(
                entity_id=event.defender.id,
                debuff_name="Poison",
                stacks_to_add=1,
                max_duration=8.0  # Longer duration than Bleed
            )



// =================================================================
// METADATA
// =================================================================
// File Path:      src\engine\core.py
// Size:           23.89 KB
// Last Modified:  2025-11-19T10:16:00.492Z
// =================================================================

"""Core combat engine - damage calculation and hit resolution."""

import random
from typing import Optional, List, Dict, Any
from ..models import Entity, SkillUseResult, ApplyDamageAction, DispatchEventAction, ApplyEffectAction, Action
from ..skills import Skill
from ..events import EventBus, OnHitEvent, OnCritEvent
from ..state import StateManager
from .hit_context import HitContext
from ..combat_math import (
    evade_dodge_or_normal,
    resolve_crit,
    apply_pierce_to_armor,
    calculate_pierce_damage_formula,
    calculate_skill_effect_proc,
    apply_glancing_damage,
    apply_block_damage,
    clamp_min_damage
)


class CombatEngine:
    """Static class containing core combat calculation methods.

    This engine implements the damage formulas from the Game Design Document,
    providing pure functions for hit resolution and damage calculation.
    """

    def __init__(self, rng=None):
        """Initialize CombatEngine with optional RNG for deterministic testing.

        Args:
            rng: Random number generator for reproducible results. If None,
                 uses random.random() without seeding.
        """
        self.rng = rng

    def _get_modified_chance(self, entity: Entity, state_manager: StateManager, base_chance: float, roll_type: str) -> float:
        """Calculate the final chance after applying bonus/penalty modifiers.

        Args:
            entity: The entity whose modifiers to check
            state_manager: StateManager to get entity state
            base_chance: The base percentage chance (e.g., 0.5 for 50%)
            roll_type: The type of roll (e.g., 'crit_chance', 'evasion_chance')

        Returns:
            Final modified chance, clamped to 0-1
        """
        state = state_manager.get_state(entity.id)
        if not state or not state.roll_modifiers.get(roll_type):
            return base_chance

        total_modifier = 0.0
        for mod in state.roll_modifiers[roll_type]:
            total_modifier += mod.value

        final_chance = base_chance + total_modifier
        return max(0.0, min(1.0, final_chance))  # Clamp to 0-1

    def _perform_evasion_check(self, defender: Entity, state_manager: StateManager) -> tuple[bool, bool]:
        """Perform evasion check with glancing/dodge mechanics.

        Args:
            defender: The defending entity
            state_manager: StateManager for modifiers

        Returns:
            Tuple of (was_dodged, was_glanced)
        """
        # Roll against modified evasion chance
        evasion_chance = self._get_modified_chance(defender, state_manager, defender.final_stats.evasion_chance, 'evasion_chance')
        rng_value = self.rng.random() if self.rng else random.random()

        if rng_value >= evasion_chance:
            return False, False  # Normal hit

        # If evaded, roll for dodge vs glance
        dodge_chance = self._get_modified_chance(defender, state_manager, defender.final_stats.dodge_chance, 'dodge_chance')
        rng_value = self.rng.random() if self.rng else random.random()

        # Actual dodge chance is the modified dodge chance
        # If dodge roll < modified dodge chance, it's a full dodge
        if rng_value < dodge_chance:
            return True, False  # Dodged

        return False, True  # Glanced

    def _perform_block_check(self, defender: Entity, state_manager: StateManager) -> bool:
        """Perform block check for potential damage reduction.

        Args:
            defender: The defending entity
            state_manager: StateManager for modifiers

        Returns:
            True if the attack was blocked
        """
        block_chance = self._get_modified_chance(defender, state_manager, defender.final_stats.block_chance, 'block_chance')
        rng_value = self.rng.random() if self.rng else random.random()
        return rng_value < block_chance

    def resolve_hit(self, attacker: Entity, defender: Entity, state_manager: "StateManager") -> "HitContext":
        """Calculate the damage of a single hit following the 9-step GDD pipeline.

        Args:
            attacker: The entity performing the attack
            defender: The entity receiving the attack
            state_manager: StateManager for accessing entity modifiers

        Returns:
            HitContext with complete damage calculation results and outcome flags
        """
        if state_manager is None:
            raise ValueError(
                "CombatEngine.resolve_hit() requires state_manager parameter. "
                "Hit resolution needs entity state for crit/evasion/block modifiers. "
                "Example: engine.resolve_hit(attacker, defender, state_manager)"
            )

        # Step 1: Gather modified stats from StateManager
        defender_evasion_chance = self._get_modified_chance(defender, state_manager, defender.final_stats.evasion_chance, 'evasion_chance')
        defender_dodge_chance = self._get_modified_chance(defender, state_manager, defender.final_stats.dodge_chance, 'dodge_chance')
        attacker_crit_chance = self._get_modified_chance(attacker, state_manager, attacker.final_stats.crit_chance, 'crit_chance')
        defender_block_chance = self._get_modified_chance(defender, state_manager, defender.final_stats.block_chance, 'block_chance')

        # Step 2: Initial Setup
        base_damage_input = attacker.final_stats.base_damage
        ctx = HitContext(
            attacker=attacker,
            defender=defender,
            base_raw=base_damage_input,
            base_resolved=int(base_damage_input),
            final_damage=base_damage_input
        )

        # Step 3: Evasion Check - Call pure math function with pre-computed modifiers
        evasion_result = evade_dodge_or_normal(self.rng, defender_dodge_chance, defender_evasion_chance)
        if evasion_result == 'dodge':
            ctx.was_dodged = True
            ctx.final_damage = 0
            return ctx
        elif evasion_result == 'evade':
            ctx.was_glancing = True

        # Step 4: Critical Hit Check - Call pure math function
        is_crit, _ = resolve_crit(self.rng, attacker_crit_chance, attacker.final_stats.crit_damage)
        ctx.was_crit = is_crit and not ctx.was_glancing  # Glancing hits cannot crit

        # Step 5: Pre-Mitigation Damage Calculation
        ctx.damage_pre_mitigation = base_damage_input

        # Apply Tier 2 crits (Enhanced) - affects pre-mitigation
        if ctx.was_crit and attacker.get_crit_tier() >= 2:
            ctx.damage_pre_mitigation *= attacker.final_stats.crit_damage

        # Step 6: Defense Mitigation (GDD formula)
        pre_pierce_damage = ctx.damage_pre_mitigation - defender.final_stats.armor
        pierced_damage = ctx.damage_pre_mitigation * attacker.final_stats.pierce_ratio

        # Use pierce damage formula: max(0, max(pre_pierce_damage, pierced_damage))
        ctx.damage_post_armor = calculate_pierce_damage_formula(
            pre_pierce_damage,
            pierced_damage
        )

        # Step 7: Post-Mitigation Modifiers
        ctx.final_damage = ctx.damage_post_armor

        # Apply Tier 3 crits (True) - full recalculation
        if ctx.was_crit and attacker.get_crit_tier() == 3:
            CombatEngine._apply_post_pierce_crit(ctx)

        # Step 8: Glancing Penalty - Call pure math function
        if ctx.was_glancing:
            ctx.final_damage = apply_glancing_damage(ctx.final_damage, 0.5)  # 50% reduction

        # Step 9: Block Check - Call pure math function
        if defender_block_chance > 0 and attacker.final_stats.pierce_ratio < 1:
            was_blocked = calculate_skill_effect_proc(self.rng, defender_block_chance)
            if was_blocked:
                ctx.was_blocked = True
                ctx.damage_blocked = min(ctx.final_damage, defender.final_stats.block_amount)
                ctx.final_damage = apply_block_damage(ctx.final_damage, defender.final_stats.block_amount)

        # Step 10: Final clamping
        ctx.final_damage = clamp_min_damage(ctx.final_damage, 0.0)

        return ctx

    @staticmethod
    def calculate_effective_damage(attacker: Entity, defender: Entity) -> dict:
        """Calculate detailed damage breakdown for analysis.

        Args:
            attacker: The entity performing the attack
            defender: The entity receiving the attack

        Returns:
            Dictionary with damage calculation details:
            {
                'final_damage': float,
                'attack_damage': float,
                'pre_pierce_damage': float,
                'pierced_damage': float,
                'armor_reduction': float,
                'pierce_ratio': float
            }
        """
        attack_damage = attacker.final_stats.base_damage
        defenses = defender.final_stats.armor
        pierce_ratio = attacker.final_stats.pierce_ratio

        pre_pierce_damage = attack_damage - defenses
        pierced_damage = attack_damage * pierce_ratio
        final_damage = max(pre_pierce_damage, pierced_damage)
        final_damage = max(0, final_damage)

        return {
            'final_damage': final_damage,
            'attack_damage': attack_damage,
            'pre_pierce_damage': pre_pierce_damage,
            'pierced_damage': pierced_damage,
            'armor_reduction': defenses,
            'pierce_ratio': pierce_ratio
        }

    @staticmethod
    def validate_damage_calculation(attacker: Entity, defender: Entity) -> Optional[str]:
        """Validate that a damage calculation would be valid.

        Args:
            attacker: The entity performing the attack
            defender: The entity receiving the attack

        Returns:
            None if valid, error message string if invalid
        """
        if attacker.final_stats.base_damage < 0:
            return f"Attacker base_damage cannot be negative: {attacker.final_stats.base_damage}"

        if attacker.final_stats.pierce_ratio < 0.01:
            return f"Attacker pierce_ratio below minimum: {attacker.final_stats.pierce_ratio}"

        if attacker.final_stats.pierce_ratio > 1.0:
            return f"Attacker pierce_ratio above maximum: {attacker.final_stats.pierce_ratio}"

        if defender.final_stats.armor < 0:
            return f"Defender armor cannot be negative: {defender.final_stats.armor}"

        return None

    @staticmethod
    def _apply_pre_pierce_crit(ctx: HitContext):
        """Apply pre-pierce critical hit multipliers based on crit tier.

        Tier 1 (Base Crit): Only affects base_damage (not yet implemented)
        Tier 2 (Enhanced Crit): Affects all pre-mitigation damage
        """
        crit_tier = ctx.attacker.get_crit_tier()

        if crit_tier == 2:  # Enhanced Crit
            ctx.damage_pre_mitigation *= ctx.attacker.final_stats.crit_damage

    @staticmethod
    def _apply_post_pierce_crit(ctx: HitContext):
        """Apply post-pierce critical hit multipliers based on crit tier.

        Tier 3 (True Crit): Affects post-mitigation damage
        """
        crit_tier = ctx.attacker.get_crit_tier()

        if crit_tier == 3:  # True Crit
            # Re-calculate mitigated damage using crit-boosted pre_mitigation_damage
            crit_pre_mit_damage = ctx.base_resolved * ctx.attacker.final_stats.crit_damage
            pre_pierce_damage = crit_pre_mit_damage - ctx.defender.final_stats.armor
            pierced_damage = crit_pre_mit_damage * ctx.attacker.final_stats.pierce_ratio

            # Update final damage directly based on new calculation
            ctx.final_damage = max(0, max(pre_pierce_damage, pierced_damage))

    def calculate_skill_use(self, attacker: Entity, defender: Entity, skill: Skill, state_manager: StateManager) -> SkillUseResult:
        """Calculate the results of a skill use without executing actions.

        Pure function that computes all hit contexts and intended actions.
        Separates calculation from execution for architectural purity.

        Args:
            attacker: The entity using the skill
            defender: The target of the skill
            skill: The skill being used

        Returns:
            SkillUseResult containing calculated hit contexts and actions to execute
        """
        hit_results: List[HitContext] = []
        actions: List[Action] = []

        for _ in range(skill.hits):
            # 1. Resolve the damage for a single hit
            hit_context = self.resolve_hit(attacker, defender, state_manager)
            hit_results.append(hit_context)
            damage = hit_context.final_damage

            # 2. Create actions for damage application and event dispatching
            actions.append(ApplyDamageAction(
                target_id=defender.id,
                damage=damage,
                source=f"{skill.name}"
            ))

            hit_event = OnHitEvent(
                attacker=attacker,
                defender=defender,
                damage_dealt=damage,
                is_crit=hit_context.was_crit
            )
            actions.append(DispatchEventAction(event=hit_event))

            if hit_context.was_crit:
                crit_event = OnCritEvent(hit_event=hit_event)
                actions.append(DispatchEventAction(event=crit_event))

            # 3. Process Skill-Specific Triggers (create effect actions)
            for trigger in skill.triggers:
                if trigger.event == "OnHit":
                    # Calculate if trigger would proc (but don't execute randomness yet)
                    # For now, we create the action assuming it will proc - execution will check RNG
                    # TODO: Pre-calculate proc results for true determinism if needed
                    if "apply_debuff" in trigger.result:
                        actions.append(ApplyEffectAction(
                            target_id=defender.id,
                            effect_name=trigger.result["apply_debuff"],
                            stacks_to_add=trigger.result.get("stacks", 1),
                            source=f"{skill.name}_trigger"
                        ))

        return SkillUseResult(hit_results=hit_results, actions=actions)

    def process_skill_use(self, attacker: Entity, defender: Entity, skill: Skill, event_bus: EventBus, state_manager: StateManager) -> bool:
        """Process a full skill use with resource checks, executing hits and dispatching all events.

        Primary skill execution method that handles resource consumption, cooldowns,
        damage application, and comprehensive event dispatching for the full pipeline.

        Args:
            attacker: The entity using the skill
            defender: The target of the skill
            skill: The skill being used
            event_bus: The event bus for dispatching events
            state_manager: The state manager for damage/effects/resources

        Returns:
            True if skill was successfully used, False if unable (cooldown/resource issues)
        """
        from .events import OnDodgeEvent, OnBlockEvent, OnGlancingBlowEvent, OnSkillUsedEvent

        # 0. Check resource availability
        attacker_state = state_manager.get_state(attacker.id)
        if not attacker_state:
            return False  # Invalid attacker state

        # Assume skill has resource_cost (will be added to skill model)
        skill_cost = getattr(skill, 'resource_cost', 0.0)
        if attacker_state.current_resource < skill_cost:
            return False  # Insufficient resource

        # Check cooldown
        skill_name = getattr(skill, 'name', str(skill))
        if attacker_state.active_cooldowns.get(skill_name, 0) > 0:
            return False  # On cooldown

        # 1. Consume resource and set cooldown
        if skill_cost > 0:
            state_manager.spend_resource(attacker.id, skill_cost)
        if hasattr(skill, 'cooldown') and skill.cooldown > 0:
            cooldown_duration = skill.cooldown * (1.0 - attacker.final_stats.cooldown_reduction)
            state_manager.set_cooldown(attacker.id, skill_name, cooldown_duration)

        # 2. Process all hits
        for hit_num in range(skill.hits):
            # Resolve the damage for a single hit
            hit_context = self.resolve_hit(attacker, defender, state_manager)

            # Dispatch outcome-specific events first
            if hit_context.was_dodged:
                dodge_event = OnDodgeEvent(attacker=attacker, defender=defender)
                event_bus.dispatch(dodge_event)
                # Award evasion resource if applicable
            continue  # No damage/debuffs on dodge

            # Create the hit event first
            hit_event = OnHitEvent(
                attacker=attacker,
                defender=defender,
                damage_dealt=hit_context.final_damage,
                is_crit=hit_context.was_crit
            )

            if hit_context.was_glancing:
                # OnGlancingBlowEvent for glancing hits
                event_bus.dispatch(hit_event)
                glancing_event = OnGlancingBlowEvent(hit_event=hit_event)
                event_bus.dispatch(glancing_event)

            elif hit_context.was_blocked:
                # Normal hit with block event
                event_bus.dispatch(hit_event)
                block_event = OnBlockEvent(
                    attacker=attacker,
                    defender=defender,
                    damage_before_block=hit_context.damage_post_armor + (hit_context.final_damage * 2 if hit_context.was_glancing else hit_context.final_damage),  # Pre-block damage
                    damage_blocked=hit_context.damage_blocked,
                    hit_context=hit_context
                )
                event_bus.dispatch(block_event)

            else:
                # Normal hit event only
                event_bus.dispatch(hit_event)

            # Apply damage and award resource
            if hit_context.final_damage > 0:
                state_manager.apply_damage(defender.id, hit_context.final_damage)
                state_manager.add_resource(attacker.id, attacker.final_stats.resource_on_hit)

                # OnKill resource bonus (check if defender died)
                defender_state = state_manager.get_state(defender.id)
                if defender_state and not defender_state.is_alive:
                    state_manager.add_resource(attacker.id, attacker.final_stats.resource_on_kill)

            # Dispatch crit event if critical
            if hit_context.was_crit:
                crit_event = OnCritEvent(hit_event=hit_event)
                event_bus.dispatch(crit_event)

            # Process skill triggers and active triggers
            self._process_skill_triggers(attacker, defender, skill, hit_context, event_bus, state_manager)

        # 3. Dispatch OnSkillUsed event (after execution)
        skill_used_event = OnSkillUsedEvent(entity=attacker, skill_id=str(skill), skill_type="damage")
        event_bus.dispatch(skill_used_event)

        return True  # Successfully used

    def _process_skill_triggers(self, attacker: Entity, defender: Entity, skill: Skill, hit_context: HitContext,
                               event_bus: EventBus, state_manager: StateManager):
        """Process skill triggers and active triggers for a hit context."""

        # Process skill-specific triggers (pass RNG explicitly per PR6)
        from .combat_math import calculate_skill_effect_proc
        for trigger in skill.triggers:
            if trigger.event == "OnHit" and hit_context.final_damage > 0:
                if calculate_skill_effect_proc(self.rng, trigger.check.get("proc_rate", 1.0)):
                    self._execute_trigger_result(trigger.result, attacker, defender, hit_context, event_bus, state_manager)

        # Process active triggers from attacker affixes (pass RNG explicitly per PR6)
        for trigger in attacker.active_triggers:
            if trigger.event == "OnHit" and hit_context.final_damage > 0:
                if calculate_skill_effect_proc(self.rng, trigger.check.get("proc_rate", 1.0)):
                    self._execute_trigger_result(trigger.result, attacker, defender, hit_context, event_bus, state_manager)

            elif trigger.event == "OnSkillUsed":
                # Special case for OnSkillUsed triggers (like Focused Rage)
                rng_value = self.rng.random() if self.rng else random.random()
                if rng_value < trigger.check.get("proc_rate", 1.0):
                    self._execute_trigger_result(trigger.result, attacker, defender, hit_context, event_bus, state_manager)

        # Process defender active triggers (block/dodge effects)
        defender_state = state_manager.get_state(defender.id)
        if defender_state and defender_state.is_alive:
            for trigger in defender.active_triggers:
                if trigger.event == "OnBlock" and hit_context.was_blocked:
                    rng_value = self.rng.random() if self.rng else random.random()
                    if rng_value < trigger.check.get("proc_rate", 1.0):
                        self._execute_trigger_result(trigger.result, defender, attacker, hit_context, event_bus, state_manager)

                elif trigger.event == "OnDodge" and hit_context.was_dodged:
                    # Defender reactive effects on dodge
                    pass

    def _execute_trigger_result(self, result: Dict[str, any], source: Entity, target: Entity, hit_context: HitContext,
                              event_bus: EventBus, state_manager: StateManager):
        """Execute the result of a trigger with support for complex effects.

        Args:
            result: The trigger result dictionary
            source: Entity that triggered the effect
            target: Entity that receives the effect
            hit_context: Current hit context for damage calculations
            event_bus: Event bus for dispatching events
            state_manager: State manager for applying effects
        """
        # Standard debuff application
        if "apply_debuff" in result:
            state_manager.apply_debuff(
                entity_id=target.id,
                debuff_name=result["apply_debuff"],
                stacks_to_add=result.get("stacks", 1),
                max_duration=result.get("duration", 10.0)
            )

        # Complex effects - Phase 3
        if "apply_crit_bonus" in result:
            # Focused Rage effect - apply crit chance bonus to source
            bonus_value = result["apply_crit_bonus"]
            duration = result.get("duration", 5.0)

            # Create a crit chance modifier
            from .state import Modifier
            modifier = Modifier(
                value=bonus_value,
                duration=duration,
                source="focused_rage"
            )

            source_state = state_manager.get_state(source.id)
            if source_state:
                if 'crit_chance' not in source_state.roll_modifiers:
                    source_state.roll_modifiers['crit_chance'] = []
                source_state.roll_modifiers['crit_chance'].append(modifier)

        if "reflect_damage" in result:
            # Thornmail effect - reflect damage back to attacker
            reflect_ratio = result["reflect_damage"]
            reflected_damage = hit_context.final_damage * reflect_ratio

            if reflected_damage > 0:
                state_manager.apply_damage(source.id, reflected_damage)

                # Create reflect damage event
                from .events import OnHitEvent
                reflect_event = OnHitEvent(
                    attacker=target,  # Defender is now attacker
                    defender=source, # Attacker becomes defender
                    damage_dealt=int(reflected_damage),
                    is_crit=False
                )
                event_bus.dispatch(reflect_event)



// =================================================================
// METADATA
// =================================================================
// File Path:      src\engine\hit_context.py
// Size:           2.29 KB
// Last Modified:  2025-11-19T10:13:12.413Z
// =================================================================

"""HitContext - telemetry dataclass for combat hit resolution."""

from dataclasses import dataclass
from typing import Optional, Dict, Any
from ..models import Entity


@dataclass
class HitContext:
    """Telemetry object capturing combat hit resolution results.

    Provides structured data about each combat hit for debugging,
    testing, and analytics while maintaining Entity references
    for backward compatibility.
    """
    attacker: Entity
    defender: Entity

    # Core damage values
    base_raw: Any        # Original damage input (int, tuple, etc.)
    base_resolved: int   # Final resolved base damage value
    final_damage: float    # Final damage after all calculations

    # Combat outcome flags (Phase 2 mechanics)
    was_crit: bool = False
    was_dodged: bool = False
    was_blocked: bool = False
    was_glancing: bool = False

    # Partial damage accounting
    damage_pre_mitigation: float = 0.0  # Damage before armor mitigation
    damage_post_armor: float = 0.0      # Damage after pierce/armor calculation
    damage_blocked: float = 0.0         # Amount reduced by blocking

    # Optional RNG debugging (disabled by default for performance)
    rng_seed: Optional[int] = None

    @property
    def attacker_id(self) -> str:
        """Get attacker entity ID for serialization."""
        return self.attacker.id

    @property
    def defender_id(self) -> str:
        """Get defender entity ID for serialization."""
        return self.defender.id

    def to_serializable(self) -> Dict[str, Any]:
        """Return JSON-safe representation for telemetry/logging.

        Returns:
            Dict with string IDs and primitive values only (no Entity objects)
        """
        return {
            "attacker_id": self.attacker_id,
            "defender_id": self.defender_id,
            "base_resolved": self.base_resolved,
            "final_damage": self.final_damage,
            "was_crit": self.was_crit,
            "was_dodged": self.was_dodged,
            "was_blocked": self.was_blocked,
            "was_glancing": self.was_glancing,
            "damage_pre_mitigation": self.damage_pre_mitigation,
            "damage_post_armor": self.damage_post_armor,
            "damage_blocked": self.damage_blocked,
        }



// =================================================================
// METADATA
// =================================================================
// File Path:      src\engine\__init__.py
// Size:           0.13 KB
// Last Modified:  2025-11-19T09:49:31.924Z
// =================================================================

"""Engine package - core combat mechanics and calculations."""

from .hit_context import HitContext
from .core import CombatEngine



// =================================================================
// METADATA
// =================================================================
// File Path:      src\events.py
// Size:           9.95 KB
// Last Modified:  2025-11-17T13:13:45.632Z
// =================================================================

"""Event system for combat engine.

Provides the EventBus and event classes for decoupling combat logic from effects.

Enhanced with PR3: Production-grade event system with unsubscribe support,
exception isolation, safe iteration, and listener priority support.
"""

import logging
import time
from collections import defaultdict
from dataclasses import dataclass
from typing import TYPE_CHECKING, Callable, Dict, List, Optional

if TYPE_CHECKING:
    from models import Entity, EffectInstance
    from engine import HitContext

logger = logging.getLogger(__name__)


@dataclass
class Event:
    """Base class for all combat events."""
    pass


@dataclass
class OnHitEvent(Event):
    """Event fired when an attack hits a target."""
    attacker: "Entity"
    defender: "Entity"
    damage_dealt: float
    is_crit: bool = False


@dataclass
class OnCritEvent(Event):
    """Event fired when a critical hit occurs."""
    hit_event: OnHitEvent


@dataclass
class DamageTickEvent(Event):
    """Event fired when a damage-over-time effect ticks."""
    target: "Entity"
    effect_name: str
    damage_dealt: float
    stacks: int


@dataclass
class OnDodgeEvent(Event):
    """Fired when an attack is fully dodged."""
    attacker: "Entity"
    defender: "Entity"


@dataclass
class OnBlockEvent(Event):
    """Fired when a hit is successfully blocked."""
    attacker: "Entity"
    defender: "Entity"
    damage_before_block: float
    damage_blocked: float
    hit_context: "HitContext"


@dataclass
class OnGlancingBlowEvent(Event):
    """Fired when a hit is downgraded to a Glancing Blow."""
    hit_event: OnHitEvent


@dataclass
class OnSkillUsedEvent(Event):
    """Fired when an entity successfully uses a skill (after cost/cooldown checks)."""
    entity: "Entity"
    skill_id: str
    skill_type: str


@dataclass
class EffectApplied(Event):
    """Fired when a status effect is applied to an entity."""
    entity_id: str
    effect: "EffectInstance"


@dataclass
class EffectExpired(Event):
    """Fired when a status effect expires from an entity."""
    entity_id: str
    effect: "EffectInstance"


@dataclass
class EffectTick(Event):
    """Fired when a periodic effect applies its tick damage/healing."""
    entity_id: str
    effect: "EffectInstance"
    damage_applied: float
    stacks: int = 1


@dataclass
class ListenerEntry:
    """Represents a listener with metadata for priority and management."""
    listener: Callable
    priority: int = 0  # Higher priority = executed first
    name: str = ""     # Optional name for debugging


class EventBus:
    """Production-grade EventBus with PR3 enhancements.

    Features:
    - Exception isolation: One failing listener cannot break others
    - Unsubscribe support: Proper resource management
    - Safe iteration: No concurrent modification issues
    - Listener priorities: Critical listeners run first
    - Event profiling: Optional monitoring and metrics
    """

    def __init__(self):
        """Initialize the enhanced event bus."""
        # Listener registry: event_type -> list of ListenerEntry (sorted by priority)
        self.listeners: Dict[type, List[ListenerEntry]] = defaultdict(list)

        # Optional profiling/metrics
        self._profiling_enabled = False
        self._profiling_initialized = False  # Track if profiling has been enabled at least once
        self._dispatch_counts: Dict[type, int] = defaultdict(int)
        self._dispatch_times: Dict[type, List[float]] = defaultdict(list)
        self._failure_counts: Dict[Callable, int] = defaultdict(int)

    def subscribe(self, event_type: type, listener: Callable, priority: int = 0, name: str = ""):
        """Register a listener for the given event type.

        Args:
            event_type: The event class to listen for
            listener: Function to call when event is dispatched
            priority: Higher values executed first (default: 0)
            name: Optional name for debugging (default: "")
        """
        entry = ListenerEntry(listener=listener, priority=priority, name=name)
        self.listeners[event_type].append(entry)

        # Keep listeners sorted by priority (highest first)
        self.listeners[event_type].sort(key=lambda e: e.priority, reverse=True)

        logger.debug("Subscribed listener %s for %s (priority: %d)",
                    name or str(listener), event_type.__name__, priority)

    def unsubscribe(self, event_type: type, listener: Callable):
        """Remove a listener from the event type.

        Args:
            event_type: The event class to unsubscribe from
            listener: The listener function to remove

        Returns:
            True if listener was found and removed, False otherwise
        """
        listeners = self.listeners.get(event_type, [])
        for i, entry in enumerate(listeners):
            if entry.listener is listener:
                removed = listeners.pop(i)
                logger.debug("Unsubscribed listener %s from %s",
                           removed.name or str(listener), event_type.__name__)
                return True

        logger.debug("Listener %s not found for %s", str(listener), event_type.__name__)
        return False

    def dispatch(self, event: Event):
        """Dispatch an event to all registered listeners safely.

        Features:
        - Exception isolation: Listener failures don't stop dispatch
        - Safe iteration: Copy list to prevent concurrent modification
        - Logging: Failed listeners logged as errors
        - Profiling: Optional dispatch metrics

        Args:
            event: The event instance to dispatch
        """
        event_type = event.__class__
        event_listeners = self.listeners.get(event_type, [])

        if not event_listeners:
            return

        # Create safe copy for iteration (prevents modification during dispatch)
        safe_listeners = list(event_listeners)

        dispatch_start = time.perf_counter() if self._profiling_enabled else 0
        failed_count = 0

        logger.debug("Dispatching %s to %d listeners", event_type.__name__, len(safe_listeners))

        for entry in safe_listeners:
            try:
                entry.listener(event)
            except Exception as e:
                failed_count += 1
                self._failure_counts[entry.listener] += 1

                listener_name = entry.name or str(entry.listener)
                logger.error(
                    "Listener %s failed while handling %s: %s",
                    listener_name, event_type.__name__, e,
                    exc_info=True
                )
                # Continue dispatching to other listeners

        # Collect profiling data
        if self._profiling_enabled:
            dispatch_time = time.perf_counter() - dispatch_start
            self._dispatch_counts[event_type] += 1
            self._dispatch_times[event_type].append(dispatch_time)

            logger.debug(
                "Dispatched %s in %.3fms (%d listeners, %d failed)",
                event_type.__name__, dispatch_time * 1000, len(safe_listeners), failed_count
            )

    # === Profiling and Monitoring Features ===

    def enable_profiling(self, enabled: bool = True):
        """Enable or disable event dispatch profiling.

        Args:
            enabled: Whether to collect dispatch performance metrics
        """
        previously_enabled = self._profiling_enabled
        self._profiling_enabled = enabled

        # Reset only when first enabling profiling
        if enabled and not self._profiling_initialized:
            self.reset_profiling()
            self._profiling_initialized = True

    def reset_profiling(self):
        """Reset all profiling data."""
        self._dispatch_counts.clear()
        self._dispatch_times.clear()
        self._failure_counts.clear()

    def get_profiling_stats(self) -> Dict:
        """Get comprehensive profiling statistics.

        Returns:
            Dictionary containing dispatch counts, average times, and failure rates
        """
        stats = {}

        for event_type, times in self._dispatch_times.items():
            if times:
                avg_time = sum(times) / len(times)
                max_time = max(times)
                total_dispatches = self._dispatch_counts[event_type]

                stats[event_type.__name__] = {
                    'total_dispatches': total_dispatches,
                    'avg_dispatch_time_ms': avg_time * 1000,
                    'max_dispatch_time_ms': max_time * 1000,
                    'listeners_count': len(self.listeners[event_type])
                }

        # Include failure stats
        failure_summary = {}
        for listener, count in self._failure_counts.items():
            listener_name = getattr(listener, '__name__', str(listener))
            failure_summary[listener_name] = count

        stats['_failures'] = failure_summary
        stats['_total_events_dispatched'] = sum(self._dispatch_counts.values())

        return stats

    # === Utility and Management Methods ===

    def get_listener_count(self, event_type: Optional[type] = None) -> int:
        """Get the total number of listeners.

        Args:
            event_type: If specified, count only for this event type

        Returns:
            Number of registered listeners
        """
        if event_type:
            return len(self.listeners.get(event_type, []))
        return sum(len(listeners) for listeners in self.listeners.values())

    def clear(self):
        """Remove all listeners from the event bus.

        Useful for cleanup or testing.
        """
        total_removed = sum(len(listeners) for listeners in self.listeners.values())
        self.listeners.clear()
        self.reset_profiling()
        logger.debug("Cleared all listeners (%d removed)", total_removed)



// =================================================================
// METADATA
// =================================================================
// File Path:      src\game_data_provider.py
// Size:           12.30 KB
// Last Modified:  2025-11-18T20:58:17.530Z
// =================================================================

"""Game Data Provider - Centralized access to typed game data.

Provides a singleton interface for accessing strongly-typed game data loaded from CSV files.
Includes cross-reference validation for data integrity.
"""

import logging
import os
from typing import Dict, Any, Optional, List
from .data.data_parser import parse_all_csvs
from .data.typed_models import (
    DataValidationError,
    AffixDefinition,
    ItemTemplate,
    QualityTier,
    EffectDefinition,
    SkillDefinition,
    hydrate_affix_definition,
    hydrate_item_template,
    hydrate_quality_tier,
    hydrate_effect_definition,
    hydrate_skill_definition,
    validate_entity_stats_are_valid
)

logger = logging.getLogger(__name__)


class GameDataProvider:
    """Singleton provider for strongly-typed game data loaded from CSV files.

    Manages loading, hydration, and cross-reference validation of game data.
    Uses singleton pattern to ensure data is loaded once and shared across the application.
    """

    _instance: Optional["GameDataProvider"] = None

    # Typed data storage - replaces loose Dict[str, Any] with strongly-typed dataclasses
    affixes: Dict[str, AffixDefinition]
    items: Dict[str, ItemTemplate]
    quality_tiers: List[QualityTier]
    effects: Dict[str, EffectDefinition]
    skills: Dict[str, SkillDefinition]

    # Initialization flag to track if data has been loaded
    _is_initialized: bool = False

    def __new__(cls):
        """Singleton pattern - return existing instance or create new one."""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self) -> None:
        """Initialize the provider. Only loads data on first instantiation due to singleton."""
        if not self._is_initialized:
            self._load_and_validate_data()

    def _load_and_validate_data(self) -> None:
        """Load, hydrate, and validate game data from CSV files."""
        data_dir = os.path.join(os.path.dirname(__file__), '..', 'data')

        try:
            # Stage 1: Parse raw CSV data with schema validation
            raw_data = parse_all_csvs(data_dir)
            logger.info("GameDataProvider: Successfully parsed raw CSV data")

            # Stage 2: Hydrate raw dictionaries into strongly-typed dataclasses
            self._hydrate_data(raw_data)

            # Stage 3: Perform cross-reference validation
            self._validate_cross_references()

            self._is_initialized = True
            logger.info("GameDataProvider: Data loading and validation complete")

        except Exception as e:
            logger.error("GameDataProvider: Failed to load and validate data: %s", e)
            raise

    def _hydrate_data(self, raw_data: Dict[str, Any]) -> None:
        """Convert raw CSV dictionary data into typed dataclass objects."""
        # Hydrate affixes
        self.affixes = {}
        for affix_id, raw_affix in raw_data.get('affixes', {}).items():
            self.affixes[affix_id] = hydrate_affix_definition(raw_affix)

        # Hydrate items
        self.items = {}
        for item_id, raw_item in raw_data.get('items', {}).items():
            # Special handling for implicit_affixes that may use semicolon to list multiple affixes
            item_data = dict(raw_item)
            if 'implicit_affixes' in item_data:
                implicit_raw = item_data['implicit_affixes']
                # Handle the case where CSV parser has already created a list containing semicolon-separated strings
                if isinstance(implicit_raw, list) and len(implicit_raw) == 1 and isinstance(implicit_raw[0], str) and ';' in implicit_raw[0]:
                    # Split the single semicolon-separated string inside the list
                    implicit_list = [affix.strip() for affix in implicit_raw[0].split(';') if affix.strip()]
                    item_data['implicit_affixes'] = implicit_list
            self.items[item_id] = hydrate_item_template(item_data)

        # Hydrate quality tiers (stored as list)
        self.quality_tiers = []
        for raw_tier in raw_data.get('quality_tiers', []):
            self.quality_tiers.append(hydrate_quality_tier(raw_tier))

        # Hydrate effects
        self.effects = {}
        for effect_id, raw_effect in raw_data.get('effects', {}).items():
            self.effects[effect_id] = hydrate_effect_definition(raw_effect)

        # Hydrate skills
        self.skills = {}
        for skill_id, raw_skill in raw_data.get('skills', {}).items():
            self.skills[skill_id] = hydrate_skill_definition(raw_skill)

        logger.info("GameDataProvider: Successfully hydrated all data into typed objects")

    def _validate_cross_references(self) -> None:
        """
        Validates all data cross-references for logical integrity.
        Raises DataValidationError if any dangling reference is found.
        """
        logger.info("GameDataProvider: Starting cross-reference validation")

        # 1. Validate skills -> effects: skill trigger_result must point to valid effect_id
        # But skip validation for complex effect syntax (containing : or _target)
        for skill_id, skill in self.skills.items():
            if skill.trigger_result:
                # Skip validation for complex effect syntax
                if ":" in skill.trigger_result or "_target" in skill.trigger_result:
                    continue
                # Skip validation for heal/bless effects (special handling)
                if any(keyword in skill.trigger_result for keyword in ["heal_", "bless_", "drain_"]):
                    continue

                if skill.trigger_result not in self.effects:
                    raise DataValidationError(
                        f"Skill '{skill_id}' references non-existent effect ID '{skill.trigger_result}'",
                        data_type="SkillDefinition",
                        field_name="trigger_result",
                        invalid_id=skill.trigger_result,
                        suggestions=list(self.effects.keys())
                    )

        # 2. Validate items -> implicit_affixes: item implicit affixes must point to valid affix_ids
        for item_id, item in self.items.items():
            if item.implicit_affixes:
                for affix_id in item.implicit_affixes:
                    if affix_id not in self.affixes:
                        raise DataValidationError(
                            f"Item '{item_id}' references non-existent implicit affix ID '{affix_id}'",
                            data_type="ItemTemplate",
                            field_name="implicit_affixes",
                            invalid_id=affix_id,
                            suggestions=list(self.affixes.keys())
                        )

        # 3. Validate affixes -> EntityStats: affix stat_affected must be valid EntityStats attribute
        all_stat_names = []
        for affix in self.affixes.values():
            # Handle dual-stats (separated by semicolon)
            stat_names = [s.strip() for s in affix.stat_affected.split(';')]
            all_stat_names.extend(stat_names)

        validate_entity_stats_are_valid(all_stat_names)

        # 4. Validate quality tiers -> Rarity: rarity columns should match Rarity enum
        from .data.typed_models import Rarity
        valid_rarities = [r.value for r in Rarity]
        for tier in self.quality_tiers:
            for rarity in valid_rarities:
                if hasattr(tier, rarity.lower()):
                    # Column exists, validate that it makes sense (basic sanity check)
                    value = getattr(tier, rarity.lower())
                    if value < 0:
                        raise DataValidationError(
                            f"Quality tier '{tier.tier_name}' has negative probability for rarity '{rarity}'",
                            data_type="QualityTier",
                            field_name=rarity.lower(),
                            invalid_id=str(value)
                        )

        logger.info("GameDataProvider: Cross-reference validation completed successfully")

    def get_affixes(self) -> Dict[str, AffixDefinition]:
        """Get the affixes data.

        Returns:
            Dictionary of affix definitions, keyed by affix_id
        """
        if not self._is_initialized:
            raise RuntimeError("GameDataProvider has not been initialized yet")
        return self.affixes

    def get_items(self) -> Dict[str, ItemTemplate]:
        """Get the items data.

        Returns:
            Dictionary of item templates, keyed by item_id
        """
        if not self._is_initialized:
            raise RuntimeError("GameDataProvider has not been initialized yet")
        return self.items

    def get_quality_tiers(self) -> List[QualityTier]:
        """Get the quality tiers data.

        Returns:
            List of quality tier objects
        """
        if not self._is_initialized:
            raise RuntimeError("GameDataProvider has not been initialized yet")
        return self.quality_tiers

    def get_effects(self) -> Dict[str, EffectDefinition]:
        """Get the effects data.

        Returns:
            Dictionary of effect definitions, keyed by effect_id
        """
        if not self._is_initialized:
            raise RuntimeError("GameDataProvider has not been initialized yet")
        return self.effects

    def get_skills(self) -> Dict[str, SkillDefinition]:
        """Get the skills data.

        Returns:
            Dictionary of skill definitions, keyed by skill_id
        """
        if not self._is_initialized:
            raise RuntimeError("GameDataProvider has not been initialized yet")
        return self.skills

    def reload_data(self) -> bool:
        """Reload game data from disk.

        Useful during development when data files change.

        Returns:
            True if data was successfully reloaded, False if there were errors
        """
        old_initialized = self._is_initialized
        last_affixes = self.affixes if old_initialized else {}
        last_items = self.items if old_initialized else {}
        last_quality_tiers = self.quality_tiers if old_initialized else []
        last_effects = self.effects if old_initialized else {}
        last_skills = self.skills if old_initialized else {}

        try:
            self._load_and_validate_data()
            return True
        except Exception:
            logger.warning("GameDataProvider: Reload failed, reverting to previous data")
            if old_initialized:
                self.affixes = last_affixes
                self.items = last_items
                self.quality_tiers = last_quality_tiers
                self.effects = last_effects
                self.skills = last_skills
                self._is_initialized = True
            else:
                self._is_initialized = False
            return False

    def is_data_loaded(self) -> bool:
        """Check if game data has been successfully loaded.

        Returns:
            True if data is loaded and validated, False otherwise
        """
        return self._is_initialized


# Convenience functions for typed data access
def get_affixes() -> Dict[str, AffixDefinition]:
    """Convenience function to get affixes data.

    Returns:
        Dictionary of affix definitions
    """
    return GameDataProvider().get_affixes()


def get_items() -> Dict[str, ItemTemplate]:
    """Convenience function to get items data.

    Returns:
        Dictionary of item templates
    """
    return GameDataProvider().get_items()


def get_quality_tiers() -> List[QualityTier]:
    """Convenience function to get quality tiers data.

    Returns:
        List of quality tier objects
    """
    return GameDataProvider().get_quality_tiers()


def get_effects() -> Dict[str, EffectDefinition]:
    """Convenience function to get effects data.

    Returns:
        Dictionary of effect definitions
    """
    return GameDataProvider().get_effects()


def get_skills() -> Dict[str, SkillDefinition]:
    """Convenience function to get skills data.

    Returns:
        Dictionary of skill definitions
    """
    return GameDataProvider().get_skills()



// =================================================================
// METADATA
// =================================================================
// File Path:      src\handlers.py
// Size:           3.43 KB
// Last Modified:  2025-11-16T14:26:16.790Z
// =================================================================

"""
Event-driven handlers for conditional affixes.
Phase 3: Simulation & Balancing implementation.
"""

import logging
from .events import EventBus, OnSkillUsedEvent, OnBlockEvent
from .state import Modifier
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .state import StateManager

logger = logging.getLogger(__name__)


class FocusedRageHandler:
    """Handler for Focused Rage affix.
    Applies crit chance bonus when special skills are used.
    """

    def __init__(self, event_bus: EventBus, state_manager: "StateManager"):
        self.event_bus = event_bus
        self.state_manager = state_manager
        self.event_bus.subscribe(OnSkillUsedEvent, self.handle_skill_used)

    def handle_skill_used(self, event: OnSkillUsedEvent):
        """Apply crit chance modifier when special skills are used."""
        # TODO: Check if it's a special skill (based on skill data)
        # For now, all skills qualify
        bonus_value = 0.25  # +25% crit chance
        duration = 5.0      # 5 seconds

        modifier = Modifier(
            value=bonus_value,
            duration=duration,
            source="focused_rage"
        )

        entity_state = self.state_manager.get_state(event.entity.id)
        if entity_state:
            if 'crit_chance' not in entity_state.roll_modifiers:
                entity_state.roll_modifiers['crit_chance'] = []
            entity_state.roll_modifiers['crit_chance'].append(modifier)

            # Optional: Dispatch event for UI feedback
            # self.event_bus.dispatch(BuffAppliedEvent(event.entity, modifier))


class BlindingRebukeHandler:
    """Handler for Blinding Rebuke affix.
    Applies evasion penalty to attacker when defender blocks.
    """

    def __init__(self, event_bus: EventBus, state_manager: "StateManager"):
        self.event_bus = event_bus
        self.state_manager = state_manager
        self.event_bus.subscribe(OnBlockEvent, self.handle_block)

    def handle_block(self, event: OnBlockEvent):
        """Apply evasion penalty to the attacker when they get blocked."""
        penalty_value = -0.15  # -15% evasion chance
        duration = 3.0         # 3 seconds

        modifier = Modifier(
            value=penalty_value,
            duration=duration,
            source="blinding_rebuke"
        )

        # Apply to attacker's evasion modifiers
        attacker_state = self.state_manager.get_state(event.attacker.id)
        if attacker_state:
            if 'evasion_chance' not in attacker_state.roll_modifiers:
                attacker_state.roll_modifiers['evasion_chance'] = []
            attacker_state.roll_modifiers['evasion_chance'].append(modifier)

            # Optional: Dispatch event for UI feedback
            # self.event_bus.dispatch(DebuffAppliedEvent(event.attacker, modifier))


def setup_conditional_affix_handlers(event_bus: EventBus, state_manager: "StateManager"):
    """Initialize all conditional affix handlers.

    Args:
        event_bus: The game's event bus
        state_manager: The game's state manager
    """
    # Create and register handlers
    FocusedRageHandler(event_bus, state_manager)
    BlindingRebukeHandler(event_bus, state_manager)

    logger.info("Conditional affix handlers initialized")
    logger.info("  âœ… Focused Rage: Crit bonus on special skill use")
    logger.info("  âœ… Blinding Rebuke: Evasion penalty on attacker when blocked")



// =================================================================
// METADATA
// =================================================================
// File Path:      src\item_generator.py
// Size:           7.20 KB
// Last Modified:  2025-11-17T20:09:55.167Z
// =================================================================

import random
import uuid
from src.models import Item, RolledAffix
from src.game_data_provider import GameDataProvider


class ItemGenerator:
    """
    Procedural item generator that creates randomized equipment with rolled affixes.
    Uses a two-step quality roll system: first tier based on rarity, then percentage within tier.
    """

    def __init__(self, game_data: dict = None, rng=None):
        """
        Initialize with parsed game data.

        Args:
            game_data: Optional dictionary from game_data.json with affixes, items, quality_tiers.
                      If None, data will be loaded from GameDataProvider.
            rng: Optional RNG instance for deterministic generation. Falls back to random module if None.
        """
        if game_data is not None:
            # Legacy support - use provided data
            self.affix_defs = game_data['affixes']
            self.item_templates = game_data['items']
            self.quality_tiers = game_data['quality_tiers']
        else:
            # Use centralized provider
            provider = GameDataProvider()
            self.affix_defs = provider.get_affixes()
            self.item_templates = provider.get_items()
            self.quality_tiers = provider.get_quality_tiers()

        self.rng = rng if rng is not None else random

    def generate(self, base_item_id: str) -> Item:
        """
        Generates a fully rolled item instance from a base item ID.

        Args:
            base_item_id: ID of the base item template to generate from

        Returns:
            Item: A fully rolled item with random affixes
        """
        template = self.item_templates[base_item_id]
        item_rarity = template['rarity']

        # Step 1 & 2: Perform the two-step quality roll
        quality_tier_obj = self._roll_quality_tier(item_rarity)
        if not quality_tier_obj:
            raise ValueError(f"No quality tiers available for rarity: {item_rarity}")
        quality_roll = random.randint(quality_tier_obj['min_range'], quality_tier_obj['max_range'])

        # Step 3: Prepare affixes
        all_affix_ids_to_roll = []

        # Add implicits
        implicits = template['implicit_affixes']
        all_affix_ids_to_roll.extend(implicits)

        # Determine and add random explicits
        possible_random_affixes = self._get_affix_pool(template['affix_pools'])
        num_random = template['num_random_affixes']

        # Ensure we don't try to roll more affixes than exist in the pool or add duplicates
        possible_random_affixes = [aff for aff in possible_random_affixes if aff not in all_affix_ids_to_roll]
        num_to_roll = min(num_random, len(possible_random_affixes))

        if num_to_roll > 0:
            random_selection = random.sample(possible_random_affixes, k=num_to_roll)
            all_affix_ids_to_roll.extend(random_selection)

        # Step 4: Roll and create affix objects with sub-quality variation
        rolled_affixes = []
        for affix_id in all_affix_ids_to_roll:
            rolled_affix = self._roll_one_affix(affix_id, quality_roll)
            rolled_affixes.append(rolled_affix)

        # Step 5: Create the item instance
        new_item = Item(
            instance_id=str(uuid.uuid4()),
            base_id=base_item_id,
            name=template['name'],
            slot=template['slot'],
            rarity=item_rarity,
            quality_tier=quality_tier_obj['tier_name'],
            quality_roll=quality_roll,
            affixes=rolled_affixes
        )

        return new_item

    def _roll_quality_tier(self, rarity: str) -> dict:
        """
        Performs a weighted roll to select a quality tier based on item rarity.

        Args:
            rarity: Item rarity (e.g., "Common", "Rare")

        Returns:
            dict: Quality tier object with tier_name, min_range, max_range, etc.
        """
        possible_tiers = [tier for tier in self.quality_tiers if tier[rarity] > 0]
        if not possible_tiers:
            return None

        weights = [tier[rarity] for tier in possible_tiers]
        selected_tier = random.choices(possible_tiers, weights=weights, k=1)[0]
        return selected_tier

    def _get_affix_pool(self, pools: list) -> list:
        """
        Gathers all affix IDs that belong to the specified pools.

        Args:
            pools: List of pool names

        Returns:
            list: List of affix IDs from the specified pools
        """
        if not pools:
            return []
        target_pools = set(pools)
        return [
            affix_id for affix_id, affix_def in self.affix_defs.items()
            if target_pools.intersection(set(affix_def['affix_pools']))
        ]

    def _roll_one_affix(self, affix_id: str, max_quality: int) -> RolledAffix:
        """
        Calculates the final value of an affix based on its base value and sub-quality roll.
        Each affix gets its own quality roll up to the item's maximum quality.
        Handles dual-stat affixes by rolling two separate values.

        Args:
            affix_id: ID of the affix to roll
            max_quality: Maximum quality percentage allowed for this item (0-100)

        Returns:
            RolledAffix: Rolled affix with calculated value(s)
        """
        affix_def = self.affix_defs[affix_id]
        base_value = affix_def['base_value']

        # Check for dual-stat affixes (base_value contains ';')
        if isinstance(base_value, str) and ';' in base_value:
            # Dual-stat affix: parse both values and roll separately
            parts = base_value.split(';')
            if len(parts) == 2:
                primary_base = float(parts[0])
                secondary_base = float(parts[1])

                # Each stat gets its own sub-quality roll
                primary_roll = self.rng.randint(0, max_quality) if self.rng else random.randint(0, max_quality)
                secondary_roll = self.rng.randint(0, max_quality) if self.rng else random.randint(0, max_quality)

                primary_final = primary_base * (primary_roll / 100.0)
                secondary_final = secondary_base * (secondary_roll / 100.0)

                return RolledAffix(
                    affix_id=affix_id,
                    stat_affected=affix_def['stat_affected'],
                    mod_type=affix_def['mod_type'],
                    description=affix_def['description'],
                    base_value=base_value,
                    value=round(primary_final, 4),
                    dual_value=round(secondary_final, 4)
                )

        # Single-stat affix (original logic)
        # Each affix gets a sub-quality roll from 0 to item's max quality
        sub_quality_roll = self.rng.randint(0, max_quality) if self.rng else random.randint(0, max_quality)
        final_value = base_value * (sub_quality_roll / 100.0)

        return RolledAffix(
            affix_id=affix_id,
            stat_affected=affix_def['stat_affected'],
            mod_type=affix_def['mod_type'],
            description=affix_def['description'],
            base_value=base_value,
            value=round(final_value, 4)
        )



// =================================================================
// METADATA
// =================================================================
// File Path:      src\models.py
// Size:           17.48 KB
// Last Modified:  2025-11-18T20:39:02.951Z
// =================================================================

"""Data models for combat entities and their statistics."""

from dataclasses import dataclass, field
from typing import Optional, List, Literal, Dict, TYPE_CHECKING, Any

if TYPE_CHECKING:
    from .engine import HitContext
    from .events import Event, EffectApplied, EffectExpired
    from .skills import Trigger

from .data.typed_models import Rarity

# Rarity to critical hit tier mapping
RARITY_TO_CRIT_TIER = {
    Rarity.COMMON: 1,
    Rarity.UNCOMMON: 1,
    Rarity.RARE: 2,
    Rarity.EPIC: 2,
    Rarity.LEGENDARY: 3,
    Rarity.MYTHIC: 3
}


@dataclass
class EntityStats:
    """Static statistics for a combat entity.

    Based on GDD Section 3.0 Dimensions & 5.0 Defenses.
    All values are non-negative and validated on creation.
    """
    # Offensive Stats (GDD 3.0)
    base_damage: float = 10.0
    attack_speed: float = 1.0
    crit_chance: float = 0.05
    crit_damage: float = 1.5
    pierce_ratio: float = 0.01  # GDD 2.1: Min value is 0.01
    damage_multiplier: float = 1.0  # Global damage multiplier

    # Defensive Stats (GDD 5.0)
    max_health: float = 100.0
    armor: float = 10.0
    resistances: float = 0.0
    
    # Utility / Sustain Stats
    life_steal: float = 0.0
    movement_speed: float = 1.0
    damage_over_time: float = 1.0  # Multiplier for DoT damage

    # New Evasion System Stats (IP 2.1)
    evasion_chance: float = 0.0  # Max 0.75
    dodge_chance: float = 0.0

    # New Block System Stats (IP 2.1)
    block_chance: float = 0.0
    block_amount: float = 0.0

    # Active Resource System Stats (IP 2.3)
    max_resource: float = 100.0
    resource_on_hit: float = 2.0
    resource_on_kill: float = 10.0

    # Cooldown Reduction Stat (IP 2.3)
    cooldown_reduction: float = 0.0

    def __post_init__(self) -> None:
        """Validate stats after initialization."""
        if self.base_damage < 0:
            raise ValueError("base_damage must be non-negative")
        if self.attack_speed <= 0:
            raise ValueError("attack_speed must be positive")
        if not (0 <= self.crit_chance <= 1):
            raise ValueError("crit_chance must be between 0 and 1")
        if self.crit_damage < 1:
            raise ValueError("crit_damage must be >= 1")
        if self.pierce_ratio < 0.01:
            raise ValueError("pierce_ratio must be >= 0.01")
        if self.max_health <= 0:
            raise ValueError("max_health must be positive")
        if self.armor < 0:
            raise ValueError("armor must be non-negative")
        if self.resistances < 0:
            raise ValueError("resistances must be non-negative")
        if not (0 <= self.evasion_chance <= 0.75):
            raise ValueError("evasion_chance must be between 0 and 0.75")
        if not (0 <= self.dodge_chance <= 1):
            raise ValueError("dodge_chance must be between 0 and 1")
        if not (0 <= self.block_chance <= 1):
            raise ValueError("block_chance must be between 0 and 1")
        if self.block_amount < 0:
            raise ValueError("block_amount must be non-negative")
        if self.max_resource <= 0:
            raise ValueError("max_resource must be positive")
        if self.resource_on_hit < 0:
            raise ValueError("resource_on_hit must be non-negative")
        if self.resource_on_kill < 0:
            raise ValueError("resource_on_kill must be non-negative")
        if self.cooldown_reduction < 0:
            raise ValueError("cooldown_reduction must be non-negative")


class Entity:
    """Represents a participant in combat.

    An Entity has base stats, equipment that modifies final stats, and a unique identifier.
    Dynamic state (health, buffs, etc.) is managed separately.
    """

    def __init__(self, id: str, base_stats: EntityStats, name: Optional[str] = None, rarity: str = "Common"):
        """Initialize an Entity.

        Args:
            id: Unique identifier for this entity
            base_stats: Base statistics for this entity (before equipment modifiers)
            name: Optional display name (defaults to id)
            rarity: Character rarity tier (Common, Uncommon, Rare, Epic, Legendary, Mythic)
        """
        if not id:
            raise ValueError("Entity id cannot be empty")

        try:
            self.rarity = Rarity(rarity)
        except ValueError:
            valid_rarities = [r.value for r in Rarity]
            raise ValueError(f"Invalid rarity: {rarity}. Must be one of {valid_rarities}")

        self.id = id
        self.base_stats = base_stats
        self.name = name or id
        self.equipment: Dict[str, Item] = {}
        self.active_triggers: List["Trigger"] = []  # For affix reactive effects
        self.final_stats = self.calculate_final_stats()

    def __repr__(self) -> str:
        return f"Entity(id='{self.id}', name='{self.name}')"

    def __str__(self) -> str:
        return self.name

    def get_crit_tier(self) -> int:
        """Get the critical hit tier based on entity rarity.

        Returns:
            Critical hit tier (1, 2, or 3)
        """
        return RARITY_TO_CRIT_TIER.get(self.rarity, 1)

    def equip_item(self, item: "Item") -> None:
        """Equip an item to its designated slot and recalculate stats.

        Args:
            item: The item to equip
        """
        self.equipment[item.slot] = item
        self.recalculate_stats()

    def recalculate_stats(self) -> None:
        """Public method to trigger stat recalculation."""
        self.final_stats = self.calculate_final_stats()

    def calculate_final_stats(self) -> EntityStats:
        """Calculate the final stats by applying equipment modifiers.

        Phase 3 Enhanced: Supports dual-stat, scaling, and complex effect affixes.
        Order of operations: Multipliers first, then flats (revised from GDD 2.1).
        Also aggregates reactive triggers from affixes.
        Validates that final stats meet minimum requirements and validates affix stat names.

        Returns:
            EntityStats with final calculated values
        """
        from .skills import Trigger
        import math

        # Start with a copy of the base stats
        final_stats_dict = self.base_stats.__dict__.copy()

        # Get valid stat names for validation
        valid_stat_names = set(final_stats_dict.keys())

        # Clear existing triggers for recalculation
        self.active_triggers.clear()

        # Calculate character power level for scaling affixes (simple sum of offensive/defensive stats)
        power_level = (
            self.base_stats.base_damage +
            self.base_stats.max_health * 0.1 +
            self.base_stats.armor * 2 +
            (self.base_stats.crit_chance * 100) +
            (self.base_stats.pierce_ratio * 1000)
        ) / 100.0  # Normalize to reasonable scale

        # 1. Apply all MULTIPLIER affixes first
        for item in self.equipment.values():
            for affix in item.affixes:
                # Handle dual-stat affixes (applies to multiple stats)
                stats_affected = affix.stat_affected.split(';') if affix.dual_stat else [affix.stat_affected]
                mod_types = affix.mod_type.split(';') if affix.dual_stat else [affix.mod_type]
                values = [affix.value]

                # For dual-stat, get the second value from the dual_value field
                if affix.dual_stat and affix.dual_value is not None:
                    values.append(affix.dual_value)

                # Apply scaling power multiplier if this is a scaling affix
                scaling_multiplier = 1.0
                if affix.scaling_power:
                    scaling_multiplier = 1.0 + math.log(power_level + 1) * 0.1  # Gentle scaling curve

                for i, stat_name in enumerate(stats_affected):
                    if not stat_name or stat_name not in valid_stat_names:
                        continue

                    mod_type = mod_types[min(i, len(mod_types)-1)]
                    value = values[min(i, len(values)-1)]

                    if mod_type == "multiplier":
                        # Apply value and scaling
                        final_value = value * scaling_multiplier
                        final_stats_dict[stat_name] *= (1 + final_value)

                # Aggregate reactive triggers from affixes
                if affix.trigger_event and affix.proc_rate and affix.trigger_result:
                    # Parse trigger_result - supports both simple debuff names and complex effects like "reflect_damage:0.3"
                    result_dict = {}

                    # Check if it's a complex effect with colon separator (e.g., "reflect_damage:0.3")
                    if ':' in affix.trigger_result:
                        effect_name, effect_value = affix.trigger_result.split(':', 1)
                        try:
                            # Try to parse as float for numerical values
                            result_dict[effect_name] = float(effect_value)
                        except ValueError:
                            # If not a number, store as string
                            result_dict[effect_name] = effect_value
                    else:
                        # Simple debuff name - use legacy format for backward compatibility
                        result_dict["apply_debuff"] = affix.trigger_result

                    # Add common trigger metadata
                    result_dict["duration"] = float(affix.trigger_duration or 10.0)
                    result_dict["stacks_max"] = int(affix.stacks_max or 99)

                    trigger = Trigger(
                        event=affix.trigger_event,
                        check={"proc_rate": affix.proc_rate},
                        result=result_dict
                    )
                    self.active_triggers.append(trigger)

        # 2. Apply all FLAT affixes second
        for item in self.equipment.values():
            for affix in item.affixes:
                # Handle dual-stat affixes for flat bonuses
                stats_affected = affix.stat_affected.split(';') if affix.dual_stat else [affix.stat_affected]
                values = [affix.value]

                if affix.dual_stat and affix.dual_value is not None:
                    values.append(affix.dual_value)

                # Apply scaling power multiplier if this is a scaling affix
                scaling_multiplier = 1.0
                if affix.scaling_power:
                    scaling_multiplier = 1.0 + math.log(power_level + 1) * 0.1

                for i, stat_name in enumerate(stats_affected):
                    if not stat_name or stat_name not in valid_stat_names:
                        continue

                    value = values[min(i, len(values)-1)]
                    # Apply value and scaling
                    final_value = value * scaling_multiplier
                    final_stats_dict[stat_name] += final_value

        # Create new EntityStats object from modified dictionary
        final_stats = EntityStats(**final_stats_dict)

        # Additional validation to ensure final stats are valid
        if final_stats.base_damage < 0:
            final_stats.base_damage = 0
        if final_stats.attack_speed <= 0:
            final_stats.attack_speed = 0.1  # Minimum speed
        if final_stats.crit_chance < 0:
            final_stats.crit_chance = 0
        if final_stats.crit_chance > 1:
            final_stats.crit_chance = 1
        if final_stats.crit_damage < 1:
            final_stats.crit_damage = 1
        if final_stats.pierce_ratio < 0.01:
            final_stats.pierce_ratio = 0.01
        if final_stats.max_health <= 0:
            final_stats.max_health = 1
        if final_stats.armor < 0:
            final_stats.armor = 0
        if final_stats.resistances < 0:
            final_stats.resistances = 0

        return final_stats




@dataclass
class RolledAffix:
    affix_id: str
    stat_affected: str
    mod_type: str
    affix_pools: str                          # Comma-separated list of valid pools
    description: str
    base_value: Any  # Can be float or string for dual values like "0.5;0.3"
    value: float
    dual_value: Optional[float] = None        # Second stat value for dual-stat affixes
    trigger_event: Optional[str] = None        # e.g., "OnHit"
    proc_rate: Optional[float] = None          # e.g., 0.25
    trigger_result: Optional[str] = None       # e.g., "apply_bleed"
    trigger_duration: Optional[float] = None   # e.g., 10.0
    stacks_max: Optional[int] = None           # e.g., 5
    # Phase 3: Advanced affix features
    dual_stat: Optional[str] = None            # e.g., "crit_damage"
    scaling_power: bool = False                # True for scaling affixes
    complex_effect: Optional[str] = None       # e.g., "special_skill"

    def get_dual_mod_type(self) -> str:
        """Get the modification type for the dual stat if applicable."""
        if not self.dual_stat:
            return ""
        # Extract the second type from the dual mod_type string (e.g., "flat;flat" -> "flat")
        return self.mod_type.split(';')[1] if ';' in self.mod_type else self.mod_type

    def get_dual_value(self) -> float:
        """Get the rolled value for the dual stat."""
        if not self.dual_stat:
            return 0.0
        # Parse dual values from base_value string format "primary;dual"
        base_val_str = str(self.base_value)
        if ';' in base_val_str:
            try:
                return float(base_val_str.split(';')[1])
            except (IndexError, ValueError):
                return 0.0
        return 0.0

    def get_primary_value(self) -> float:
        """Get the primary stat value (handles dual-stat format)."""
        base_val_str = str(self.base_value)
        if ';' in base_val_str:
            try:
                return float(base_val_str.split(';')[0])
            except (IndexError, ValueError):
                return float(self.value)  # Fallback to value
        try:
            return float(self.base_value)
        except (ValueError, TypeError):
            return float(self.value)  # Fallback


@dataclass
class Item:
    instance_id: str
    base_id: str
    name: str
    slot: str
    rarity: str
    quality_tier: str
    quality_roll: int
    affixes: List[RolledAffix] = field(default_factory=list)


# Effect Configuration and Handler Data

@dataclass
class DamageOnHitConfig:
    """Configuration for damage-over-time effects applied on hit.

    Supports future data-driven configuration from effects.csv file.
    Enables adding new DoT effects without code changes.
    """
    debuff_name: str
    proc_rate: float
    duration: float
    damage_per_tick: float
    stacks_to_add: int = 1
    display_message: str = ""  # e.g., "Bleed proc'd on {target}!"


# Combat Engine Result Objects

@dataclass
class SkillUseResult:
    """Result container for skill use calculations.

    Separates damage calculations from action execution for architectural purity.
    Godot-friendly structure that translates well to signal/event systems.
    """
    hit_results: List["HitContext"]  # Calculated hits from multi-hit skills
    actions: List["Action"]         # Actions to execute (damage, events, effects)


# Action Classes for Decoupled Execution

@dataclass
class Action:
    """Base class for executable actions after skill calculation."""
    pass


@dataclass
class ApplyDamageAction(Action):
    """Action to apply calculated damage to a target."""
    target_id: str
    damage: float
    source: str = "skill"  # For tracking damage source


@dataclass
class DispatchEventAction(Action):
    """Action to dispatch an event via the EventBus."""
    event: "Event"  # The event instance to dispatch


@dataclass
class ApplyEffectAction(Action):
    """Action to apply a status effect to a target."""
    target_id: str
    effect_name: str
    stacks_to_add: int = 1
    source: str = "skill"  # For tracking effect source
    proc_rate: float = 1.0  # Probability of this effect applying (0.0 to 1.0)


@dataclass
class EffectInstance:
    """Runtime instance of a status effect applied to an entity.

    PR8a: New normalized effect data structure.
    Supports DoTs, buffs, debuffs, and complex reactive mechanics.
    """
    id: str                    # unique instance ID
    definition_id: str         # reference to effect definition
    source_id: str            # who applied this effect
    time_remaining: float
    tick_interval: float      # seconds between ticks (0 for no ticks)
    accumulator: float = 0.0  # time accumulator for ticking
    stacks: int = 1
    value: float = 0.0        # damage per tick, stat modifier, etc.
    expires_on_zero: bool = True

    def __repr__(self) -> str:
        return f"EffectInstance(id='{self.id}', definition='{self.definition_id}', stacks={self.stacks})"


# Forward reference for Action subclasses
# This will be resolved when imported in the engine
ApplyDamageAction.__annotations__["target_id"] = str
ApplyDamageAction.__annotations__["damage"] = float
ApplyDamageAction.__annotations__["source"] = str

DispatchEventAction.__annotations__["event"] = str  # Simplified for forward reference

ApplyEffectAction.__annotations__["target_id"] = str
ApplyEffectAction.__annotations__["effect_name"] = str
ApplyEffectAction.__annotations__["stacks_to_add"] = int
ApplyEffectAction.__annotations__["source"] = str



// =================================================================
// METADATA
// =================================================================
// File Path:      src\simulation.py
// Size:           23.64 KB
// Last Modified:  2025-11-16T14:54:40.768Z
// =================================================================

"""Simulation framework for combat testing and balancing.

Provides automated combat simulation, logging, and reporting tools for
validating balance and performance.
"""

import time
import random
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, TYPE_CHECKING
from collections import defaultdict

if TYPE_CHECKING:
    from .models import Entity
    from .events import OnHitEvent, DamageTickEvent

# Import for runtime use
from .events import OnHitEvent, DamageTickEvent


@dataclass
class CombatLogEntry:
    """Represents a single event in the combat log.

    Used to track all combat events for analysis and reporting.
    """
    timestamp: float
    event_type: str
    attacker_id: Optional[str] = None
    defender_id: Optional[str] = None
    damage_dealt: Optional[float] = None
    is_crit: bool = False
    effect_name: Optional[str] = None
    effect_stacks: Optional[int] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


class CombatLogger:
    """Logs and analyzes combat events for simulation and balancing.

    Records all combat events and provides methods for analysis and reporting.
    """

    def __init__(self):
        """Initialize the combat logger."""
        self.entries: List[CombatLogEntry] = []
        self.start_time: Optional[float] = None
        self.end_time: Optional[float] = None

    def start_logging(self) -> None:
        """Start the logging session."""
        self.start_time = time.time()
        self.entries.clear()

    def stop_logging(self) -> None:
        """Stop the logging session."""
        self.end_time = time.time()

    def log_hit(self, attacker_id: str, defender_id: str, damage: float, is_crit: bool = False) -> None:
        """Log a hit event.

        Args:
            attacker_id: ID of the attacking entity
            defender_id: ID of the defending entity
            damage: Amount of damage dealt
            is_crit: Whether this was a critical hit
        """
        entry = CombatLogEntry(
            timestamp=time.time(),
            event_type="hit",
            attacker_id=attacker_id,
            defender_id=defender_id,
            damage_dealt=damage,
            is_crit=is_crit
        )
        self.entries.append(entry)

    def log_effect_application(self, target_id: str, effect_name: str, stacks: int) -> None:
        """Log an effect application event.

        Args:
            target_id: ID of the entity affected
            effect_name: Name of the effect applied
            stacks: Number of stacks applied
        """
        entry = CombatLogEntry(
            timestamp=time.time(),
            event_type="effect_apply",
            defender_id=target_id,
            effect_name=effect_name,
            effect_stacks=stacks
        )
        self.entries.append(entry)

    def log_damage_tick(self, target_id: str, effect_name: str, damage: float) -> None:
        """Log a damage-over-time tick event.

        Args:
            target_id: ID of the entity taking damage
            effect_name: Name of the DoT effect
            damage: Amount of damage dealt by the tick
        """
        entry = CombatLogEntry(
            timestamp=time.time(),
            event_type="damage_tick",
            defender_id=target_id,
            effect_name=effect_name,
            damage_dealt=damage
        )
        self.entries.append(entry)

    def log_death(self, entity_id: str) -> None:
        """Log an entity death event.

        Args:
            entity_id: ID of the entity that died
        """
        entry = CombatLogEntry(
            timestamp=time.time(),
            event_type="death",
            defender_id=entity_id
        )
        self.entries.append(entry)

    def get_damage_breakdown(self) -> Dict[str, Dict[str, float]]:
        """Get a breakdown of damage dealt by each attacker.

        Returns:
            Dictionary mapping attacker IDs to damage statistics
        """
        breakdown = defaultdict(lambda: {"total_damage": 0.0, "crit_damage": 0.0, "normal_damage": 0.0, "hits": 0, "crits": 0})

        for entry in self.entries:
            if entry.event_type == "hit" and entry.attacker_id and entry.damage_dealt is not None:
                attacker_stats = breakdown[entry.attacker_id]
                attacker_stats["total_damage"] += entry.damage_dealt
                attacker_stats["hits"] += 1

                if entry.is_crit:
                    attacker_stats["crit_damage"] += entry.damage_dealt
                    attacker_stats["crits"] += 1
                else:
                    attacker_stats["normal_damage"] += entry.damage_dealt

        return dict(breakdown)

    def get_effect_uptime(self) -> Dict[str, Dict[str, Dict[str, Any]]]:
        """Get effect uptime statistics.

        Returns:
            Dictionary mapping entity IDs to effect statistics
        """
        effect_stats = defaultdict(lambda: defaultdict(lambda: {"applications": 0, "total_ticks": 0, "total_damage": 0.0}))

        for entry in self.entries:
            if entry.event_type == "effect_apply" and entry.defender_id and entry.effect_name:
                effect_stats[entry.defender_id][entry.effect_name]["applications"] += 1
            elif entry.event_type == "damage_tick" and entry.defender_id and entry.effect_name and entry.damage_dealt:
                effect_stats[entry.defender_id][entry.effect_name]["total_ticks"] += 1
                effect_stats[entry.defender_id][entry.effect_name]["total_damage"] += entry.damage_dealt

        return dict(effect_stats)

    def get_simulation_duration(self) -> float:
        """Get the total duration of the logged simulation.

        Returns:
            Duration in seconds, or 0 if logging not properly started/stopped
        """
        if self.start_time and self.end_time:
            return self.end_time - self.start_time
        return 0.0

    def get_total_events(self) -> int:
        """Get the total number of logged events.

        Returns:
            Number of events in the log
        """
        return len(self.entries)

    def get_events_per_second(self) -> float:
        """Get the average events per second during simulation.

        Returns:
            Events per second, or 0 if no duration
        """
        duration = self.get_simulation_duration()
        if duration > 0:
            return len(self.entries) / duration
        return 0.0

    def clear(self) -> None:
        """Clear all logged entries."""
        self.entries.clear()
        self.start_time = None
        self.end_time = None


class SimulationRunner:
    """Runs automated combat simulations with time-based progression.

    Manages the simulation loop, entity attacks, and effect processing.
    """

    def __init__(self, combat_engine, state_manager, event_bus, logger: Optional[CombatLogger] = None):
        """Initialize the simulation runner.

        Args:
            combat_engine: The combat engine for damage calculations
            state_manager: The state manager for entity states
            event_bus: The event bus for dispatching events
            logger: Optional combat logger for recording events
        """
        self.combat_engine = combat_engine
        self.state_manager = state_manager
        self.event_bus = event_bus
        self.logger = logger or CombatLogger()

        # Simulation state
        self.entities: List["Entity"] = []
        self.attack_timers: Dict[str, float] = {}
        self.simulation_time: float = 0.0
        self.is_running: bool = False

        # Set up event subscriptions for logging
        self._setup_event_subscriptions()

    def _setup_event_subscriptions(self) -> None:
        """Set up event subscriptions for logging combat events."""
        if self.logger:
            self.event_bus.subscribe(OnHitEvent, self._log_hit_event)
            self.event_bus.subscribe(DamageTickEvent, self._log_damage_tick_event)

    def _log_hit_event(self, event) -> None:
        """Log a hit event."""
        self.logger.log_hit(
            attacker_id=event.attacker.id,
            defender_id=event.defender.id,
            damage=event.damage_dealt,
            is_crit=event.is_crit
        )

    def _log_damage_tick_event(self, event) -> None:
        """Log a damage tick event."""
        self.logger.log_damage_tick(
            target_id=event.target.id,
            effect_name=event.effect_name,
            damage=event.damage_dealt
        )

    def add_entity(self, entity: "Entity") -> None:
        """Add an entity to the simulation.

        Args:
            entity: The entity to add
        """
        if entity not in self.entities:
            self.entities.append(entity)
            self.state_manager.register_entity(entity)
            # Initialize attack timer based on attack speed (attacks per second)
            self.attack_timers[entity.id] = 1.0 / entity.final_stats.attack_speed

    def remove_entity(self, entity_id: str) -> None:
        """Remove an entity from the simulation.

        Args:
            entity_id: ID of the entity to remove
        """
        self.entities = [e for e in self.entities if e.id != entity_id]
        self.state_manager.unregister_entity(entity_id)
        if entity_id in self.attack_timers:
            del self.attack_timers[entity_id]

    def get_random_target(self, attacker_id: str) -> Optional["Entity"]:
        """Get a random living target for an attacker.

        Args:
            attacker_id: ID of the attacking entity

        Returns:
            A random living target, or None if no valid targets
        """
        living_entities = [
            entity for entity in self.entities
            if entity.id != attacker_id and self.state_manager.get_state(entity.id).is_alive
        ]
        return random.choice(living_entities) if living_entities else None

    def update(self, delta_time: float, force_update: bool = False) -> None:
        """Update the simulation by the given time delta.

        Args:
            delta_time: Time elapsed since last update in seconds
            force_update: If True, update even when simulation is not running (for testing)
        """
        if not self.is_running and not force_update:
            return

        if self.is_running:  # Only update simulation time during actual runs
            self.simulation_time += delta_time

        # Update attack timers and process attacks
        for entity in self.entities[:]:  # Copy list to avoid modification during iteration
            if not self.state_manager.get_state(entity.id).is_alive:
                continue

            # Only update attack timers for entities that have them (i.e., can attack)
            if entity.id in self.attack_timers:
                self.attack_timers[entity.id] -= delta_time

                # Check if it's time to attack
                if self.attack_timers[entity.id] <= 0:
                    target = self.get_random_target(entity.id)
                    if target:
                        # Perform attack using the combat engine
                        hit_context = self.combat_engine.resolve_hit(entity, target, self.state_manager)

                        # Apply damage
                        damage = hit_context.final_damage
                        self.state_manager.apply_damage(target.id, damage)

                        # Dispatch events
                        from .events import OnHitEvent, OnCritEvent
                        hit_event = OnHitEvent(
                            attacker=entity,
                            defender=target,
                            damage_dealt=damage,
                            is_crit=hit_context.is_crit
                        )
                        self.event_bus.dispatch(hit_event)

                        if hit_context.is_crit:
                            crit_event = OnCritEvent(hit_event=hit_event)
                            self.event_bus.dispatch(crit_event)

                        # Reset attack timer
                        self.attack_timers[entity.id] = 1.0 / entity.final_stats.attack_speed

        # Update DoT effects (PR4: centralized tick processing)
        self.state_manager.tick(delta_time, self.event_bus)

    def run_simulation(self, duration: float, time_step: float = 0.1) -> None:
        """Run a simulation for the specified duration.

        Args:
            duration: Total simulation time in seconds
            time_step: Time step for each update in seconds
        """
        self.logger.start_logging()
        self.is_running = True
        self.simulation_time = 0.0

        try:
            while self.simulation_time < duration:
                step_time = min(time_step, duration - self.simulation_time)
                self.update(step_time)
        finally:
            self.is_running = False
            self.logger.stop_logging()

    def get_simulation_report(self) -> Dict[str, Any]:
        """Get a comprehensive report of the simulation results.

        Returns:
            Dictionary containing simulation statistics and analysis
        """
        return {
            "duration": self.logger.get_simulation_duration(),
            "total_events": self.logger.get_total_events(),
            "events_per_second": self.logger.get_events_per_second(),
            "damage_breakdown": self.logger.get_damage_breakdown(),
            "effect_uptime": self.logger.get_effect_uptime(),
            "final_entity_states": {
                entity_id: {
                    "health": state.current_health,
                    "is_alive": state.is_alive,
                    "active_debuffs": list(state.active_debuffs.keys())
                }
                for entity_id, state in self.state_manager.get_all_states().items()
            }
        }

    def reset(self) -> None:
        """Reset the simulation state."""
        self.entities.clear()
        self.attack_timers.clear()
        self.simulation_time = 0.0
        self.is_running = False
        self.state_manager.reset()
        self.logger.clear()


class ReportGenerator:
    """Generates detailed reports and analysis from simulation data.

    Provides balance analysis, performance metrics, and actionable insights.
    """

    def __init__(self, logger: CombatLogger):
        """Initialize the report generator.

        Args:
            logger: The combat logger containing simulation data
        """
        self.logger = logger

    def generate_damage_report(self) -> Dict[str, Any]:
        """Generate a comprehensive damage analysis report.

        Returns:
            Dictionary containing damage statistics and analysis
        """
        damage_breakdown = self.logger.get_damage_breakdown()

        # Calculate aggregate statistics
        total_damage = sum(stats["total_damage"] for stats in damage_breakdown.values())
        total_hits = sum(stats["hits"] for stats in damage_breakdown.values())
        total_crits = sum(stats["crits"] for stats in damage_breakdown.values())

        # Calculate averages
        avg_damage_per_hit = total_damage / total_hits if total_hits > 0 else 0
        crit_rate = total_crits / total_hits if total_hits > 0 else 0

        # Per-entity analysis
        entity_analysis = {}
        for entity_id, stats in damage_breakdown.items():
            entity_analysis[entity_id] = {
                "total_damage": stats["total_damage"],
                "damage_percentage": (stats["total_damage"] / total_damage * 100) if total_damage > 0 else 0,
                "hits": stats["hits"],
                "crits": stats["crits"],
                "crit_rate": stats["crits"] / stats["hits"] if stats["hits"] > 0 else 0,
                "avg_damage_per_hit": stats["total_damage"] / stats["hits"] if stats["hits"] > 0 else 0,
                "avg_crit_damage": stats["crit_damage"] / stats["crits"] if stats["crits"] > 0 else 0,
                "avg_normal_damage": stats["normal_damage"] / (stats["hits"] - stats["crits"]) if (stats["hits"] - stats["crits"]) > 0 else 0
            }

        return {
            "summary": {
                "total_damage": total_damage,
                "total_hits": total_hits,
                "total_crits": total_crits,
                "overall_crit_rate": crit_rate,
                "avg_damage_per_hit": avg_damage_per_hit
            },
            "entity_breakdown": entity_analysis
        }

    def generate_effect_report(self) -> Dict[str, Any]:
        """Generate a comprehensive effect analysis report.

        Returns:
            Dictionary containing effect statistics and analysis
        """
        effect_uptime = self.logger.get_effect_uptime()

        # Calculate aggregate statistics
        total_applications = 0
        total_ticks = 0
        total_dot_damage = 0.0

        effect_analysis = {}
        for entity_id, effects in effect_uptime.items():
            entity_effects = {}
            for effect_name, stats in effects.items():
                total_applications += stats["applications"]
                total_ticks += stats["total_ticks"]
                total_dot_damage += stats["total_damage"]

                entity_effects[effect_name] = {
                    "applications": stats["applications"],
                    "total_ticks": stats["total_ticks"],
                    "total_damage": stats["total_damage"],
                    "avg_damage_per_tick": stats["total_damage"] / stats["total_ticks"] if stats["total_ticks"] > 0 else 0
                }

            effect_analysis[entity_id] = entity_effects

        return {
            "summary": {
                "total_applications": total_applications,
                "total_ticks": total_ticks,
                "total_dot_damage": total_dot_damage,
                "avg_damage_per_tick": total_dot_damage / total_ticks if total_ticks > 0 else 0
            },
            "entity_breakdown": effect_analysis
        }

    def generate_performance_report(self) -> Dict[str, Any]:
        """Generate a performance analysis report.

        Returns:
            Dictionary containing performance metrics
        """
        duration = self.logger.get_simulation_duration()
        total_events = self.logger.get_total_events()
        events_per_second = self.logger.get_events_per_second()

        return {
            "simulation_duration": duration,
            "total_events": total_events,
            "events_per_second": events_per_second,
            "performance_rating": self._calculate_performance_rating(events_per_second)
        }

    def _calculate_performance_rating(self, events_per_second: float) -> str:
        """Calculate a performance rating based on events per second.

        Args:
            events_per_second: Average events per second

        Returns:
            Performance rating string
        """
        if events_per_second >= 1000:
            return "Excellent"
        elif events_per_second >= 500:
            return "Good"
        elif events_per_second >= 100:
            return "Fair"
        else:
            return "Poor"

    def generate_balance_insights(self) -> Dict[str, Any]:
        """Generate balance analysis insights.

        Returns:
            Dictionary containing balance analysis and recommendations
        """
        damage_report = self.generate_damage_report()
        effect_report = self.generate_effect_report()

        insights = {
            "damage_distribution": self._analyze_damage_distribution(damage_report),
            "effect_balance": self._analyze_effect_balance(effect_report),
            "recommendations": self._generate_recommendations(damage_report, effect_report)
        }

        return insights

    def _analyze_damage_distribution(self, damage_report: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze damage distribution for balance insights.

        Args:
            damage_report: The damage report data

        Returns:
            Analysis of damage distribution
        """
        entity_breakdown = damage_report["entity_breakdown"]
        damage_percentages = [stats["damage_percentage"] for stats in entity_breakdown.values()]

        if not damage_percentages:
            return {"distribution": "insufficient_data"}

        max_damage_pct = max(damage_percentages)
        min_damage_pct = min(damage_percentages)
        avg_damage_pct = sum(damage_percentages) / len(damage_percentages)

        # Calculate variance
        variance = sum((pct - avg_damage_pct) ** 2 for pct in damage_percentages) / len(damage_percentages)

        return {
            "distribution_type": "balanced" if variance < 100 else "unbalanced",
            "max_damage_percentage": max_damage_pct,
            "min_damage_percentage": min_damage_pct,
            "variance": variance,
            "range": max_damage_pct - min_damage_pct
        }

    def _analyze_effect_balance(self, effect_report: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze effect balance for insights.

        Args:
            effect_report: The effect report data

        Returns:
            Analysis of effect balance
        """
        entity_breakdown = effect_report["entity_breakdown"]

        # Count entities with effects vs without
        entities_with_effects = len([e for e in entity_breakdown.values() if e])
        total_entities = len(entity_breakdown)

        return {
            "entities_with_effects": entities_with_effects,
            "total_entities": total_entities,
            "effect_coverage": entities_with_effects / total_entities if total_entities > 0 else 0
        }

    def _generate_recommendations(self, damage_report: Dict[str, Any], effect_report: Dict[str, Any]) -> List[str]:
        """Generate balance recommendations based on analysis.

        Args:
            damage_report: The damage report data
            effect_report: The effect report data

        Returns:
            List of recommendations
        """
        recommendations = []

        # Damage distribution recommendations
        damage_dist = self._analyze_damage_distribution(damage_report)
        if damage_dist.get("distribution_type") == "unbalanced":
            recommendations.append("Consider balancing damage output - high variance detected in damage distribution")

        # Effect recommendations
        effect_balance = self._analyze_effect_balance(effect_report)
        if effect_balance.get("effect_coverage", 0) < 0.5:
            recommendations.append("Effects are underutilized - consider increasing proc rates or effect triggers")

        # Performance recommendations
        perf_report = self.generate_performance_report()
        if perf_report.get("performance_rating") == "Poor":
            recommendations.append("Simulation performance is poor - consider optimizing event handling")

        return recommendations if recommendations else ["Simulation appears well-balanced"]

    def generate_full_report(self) -> Dict[str, Any]:
        """Generate a complete simulation analysis report.

        Returns:
            Comprehensive report with all analysis sections
        """
        return {
            "damage_analysis": self.generate_damage_report(),
            "effect_analysis": self.generate_effect_report(),
            "performance_analysis": self.generate_performance_report(),
            "balance_insights": self.generate_balance_insights(),
            "generated_at": time.time()
        }



// =================================================================
// METADATA
// =================================================================
// File Path:      src\skills.py
// Size:           0.71 KB
// Last Modified:  2025-11-10T17:18:22.132Z
// =================================================================

"""Skill system for combat - triggers and skill definitions."""

from dataclasses import dataclass, field
from typing import List, Dict, Any


@dataclass
class Trigger:
    """Represents a trigger condition and effect for a skill.

    Based on GDD Section 4.1.
    """
    event: str  # e.g., "OnHit", "OnCrit"
    check: Dict[str, Any]  # e.g., {"proc_rate": 0.5}
    result: Dict[str, Any]  # e.g., {"apply_debuff": "Bleed", "stacks": 1}


@dataclass
class Skill:
    """Represents a combat skill with triggers.

    Based on GDD Sections 3.0 and 4.1.
    """
    id: str
    name: str
    damage_type: str = "Physical"
    hits: int = 1
    triggers: List[Trigger] = field(default_factory=list)



// =================================================================
// METADATA
// =================================================================
// File Path:      src\state.py
// Size:           20.60 KB
// Last Modified:  2025-11-17T14:24:22.787Z
// =================================================================

"""State management for combat entities - tracking dynamic properties like health."""

from dataclasses import dataclass, field
from typing import Dict, Optional, TYPE_CHECKING, List

if TYPE_CHECKING:
    from .events import EventBus
    from .models import EffectInstance

from .models import Entity


@dataclass
class Modifier:
    """Represents a temporary modifier that can affect roll chances or other stats."""
    value: float  # Positive for bonus, negative for penalty
    duration: float  # Time remaining in seconds
    source: str = "unknown"  # What applied this modifier


@dataclass
class Debuff:
    """Represents a damage-over-time effect or debuff applied to an entity."""
    name: str
    stacks: int = 1
    max_duration: float = 10.0
    time_remaining: float = 10.0
    accumulator: float = 0.0  # Accumulated time towards next tick
    tick_interval: float = 1.0  # Seconds between ticks
    damage_per_tick: float = 5.0  # Base damage per tick per stack


@dataclass
class EntityState:
    """Tracks the mutable state of a combat entity.

    This represents the current status of an entity during combat,
    separate from their static stats.
    """
    current_health: float
    is_alive: bool = True
    active_debuffs: Dict[str, Debuff] = field(default_factory=dict)

    # New fields for Phase 1 implementation
    current_resource: float = 0.0  # Current resource amount
    max_resource: float = 100.0    # Store max for clamping resource adds
    roll_modifiers: Dict[str, List[Modifier]] = field(default_factory=dict)  # e.g., {'crit_chance': [Modifier], 'evasion_chance': [...]}
    active_cooldowns: Dict[str, float] = field(default_factory=dict)  # skill_name -> remaining cooldown seconds

    def __post_init__(self):
        """Validate state after initialization."""
        if self.current_health < 0:
            raise ValueError("current_health cannot be negative")
        if self.current_health == 0 and self.is_alive:
            # Auto-correct inconsistent state
            self.is_alive = False
        if self.current_resource < 0:
            raise ValueError("current_resource cannot be negative")
        if self.max_resource <= 0:
            raise ValueError("max_resource must be positive")


# New Normalized StateManager API (PR8a) - Backwards Compatible
# Implements both new normalization and maintains legacy interface

class StateManager:
    """PR8c FINAL API - Strict Mode StateManager (Production Ready)

    ðŸ”’ STRICT MODE ENFORCEMENT:
    - By default, ALL entity access requires entities to be registered first
    - Accessing unregistered entities raises KeyError with clear error message
    - No silent failures or undefined behavior

    NEW NORMALIZED API (Final):
    - add_entity(entity) -> registers entity for state management
    - apply_damage(entity_id, damage) -> float (actual damage applied)
    - apply_effect(entity_id, effect) -> dict (comprehensive result)
    - update(delta_time, event_bus) -> None (centralized effect processing)
    - get_current_health(entity_id) -> float
    - get_current_resource(entity_id) -> float
    - get_is_alive(entity_id) -> bool
    - get_active_effects(entity_id) -> List[EffectInstance]
    - get_cooldown_remaining(entity_id, skill_id) -> float

    PR8c ARCHITECTURAL IMPROVEMENTS:
    âœ… strict_mode=True by default - prevents unsafe access patterns
    âœ… Centralized effect processing in update() method
    âœ… Type-safe effect management with EffectInstance
    âœ… Proper separation of calculation vs execution
    âœ… Action/Result Pattern compatible effect system
    âœ… KeyError enforcement prevents runtime surprises

    LEGACY COMPATIBILITY METHODS:
    During transition period, legacy methods are available but deprecated:
    - register_entity() -> use add_entity()
    - unregister_entity() -> use remove_entity()
    - tick() -> use update()
    """

    def __init__(self, strict_mode: bool = True):
        """Initialize strict mode state manager.

        Args:
            strict_mode: If True (default), accessing non-registered entities raises KeyError.
                        This prevents undefined behavior and forces proper entity registration.
                        Set to False only for legacy compatibility during migration.
        """
        self.strict_mode = strict_mode
        self.states: Dict[str, EntityState] = {}
        # Track current effects for normalized API
        self._active_effects: Dict[str, Dict[str, "EffectInstance"]] = {}

    # ============================================================================
    # NEW NORMALIZED API (PR8a)
    # ============================================================================

    def apply_damage(self, entity_id: str, damage: float) -> float:
        """Apply damage to an entity and return actual damage applied.

        Args:
            entity_id: Target entity ID
            damage: Amount of damage to deal

        Returns:
            Actual damage applied (0 if dead, not found, or invalid damage)
        """
        # Validate damage input
        if damage < 0:
            return 0.0  # Negative damage doesn't make sense

        state = self.get_state(entity_id)
        if not state or not state.is_alive:
            return 0.0

        old_health = state.current_health
        state.current_health = max(0, state.current_health - damage)

        if state.current_health <= 0:
            state.current_health = 0
            state.is_alive = False

        return old_health - state.current_health

    def apply_effect(self, entity_id: str, effect: "EffectInstance") -> Dict[str, any]:
        """Apply an effect to an entity and return comprehensive result.

        Args:
            entity_id: Target entity ID
            effect: Effect instance to apply

        Returns:
            Result dictionary with success, message, etc.
        """
        from .models import EffectInstance
        from .events import EffectApplied, EventBus
        from .game_data_provider import GameDataProvider

        # Strict mode: require entity to be registered first
        if self.strict_mode:
            if entity_id not in self.states:
                raise KeyError(f"Entity '{entity_id}' not registered - call add_entity() first")

        # Initialize effects storage if needed
        if entity_id not in self._active_effects:
            self._active_effects[entity_id] = {}

        # Check for existing effect and stack accordingly
        existing = self._active_effects[entity_id].get(effect.definition_id)

        if existing:
            # Stack the effects (assume default max_stacks if not specified)
            max_stacks = 10  # Default max stacks
            try:
                # Try to get effect definition for max stacks
                effect_def = GameDataProvider.instance.get_effect_definition(effect.definition_id)
                if effect_def and hasattr(effect_def, 'max_stacks'):
                    max_stacks = effect_def.max_stacks
            except:
                pass

            existing.stacks = min(existing.stacks + effect.stacks, max_stacks)
            existing.time_remaining = max(existing.time_remaining, effect.time_remaining)
            result = {"success": True, "action": "refreshed", "new_stacks": existing.stacks}
        else:
            # Apply new effect
            self._active_effects[entity_id][effect.definition_id] = effect
            result = {"success": True, "action": "applied", "new_stacks": effect.stacks}

        # In strict mode, state should already exist (checked above)
        # In non-strict mode, we might need to create minimal state, but for now assume strict mode

        # Dispatch effect applied event
        try:
            event_bus = None  # TODO: Get event bus from context
            if event_bus:
                effect_applied_event = EffectApplied(
                    entity_id=entity_id,
                    effect=effect
                )
                event_bus.dispatch(effect_applied_event)
        except:
            pass  # Event bus dispatch is optional

        return result

    def update(self, delta_time: float, event_bus: Optional["EventBus"] = None) -> None:
        """Centralized effect processing with proper accumulator-based timing.

        This is the single source of truth for all periodic effect processing:
        - Effect duration decrement
        - Accumulator-based tick timing (fractional delta support)
        - Damage/healing application with event dispatching
        - Effect expiration with events

        Args:
            delta_time: Time elapsed in seconds
            event_bus: Optional event bus for dispatching events
        """
        from .game_data_provider import GameDataProvider

        for entity_id, effects in list(self._active_effects.items()):
            if entity_id not in self.states:
                continue

            state = self.states[entity_id]
            if not state.is_alive:
                continue

            effects_to_remove = []

            for effect_id, effect in effects.items():
                # Decrement effect duration
                effect.time_remaining = max(0, effect.time_remaining - delta_time)

                # Get effect definition to check for ticking
                # TODO: Implement when GameDataProvider supports effect definitions
                try:
                    # effect_def = GameDataProvider.instance.get_effect_definition(effect.definition_id)
                    effect_def = None  # Temporary: effect definitions not yet implemented
                except:
                    effect_def = None

                if effect_def and effect_def.tick_rate > 0 and effect_def.damage_per_tick > 0:
                    # Process effect ticks using EffectInstance's accumulator
                    effect.accumulator += delta_time
                    tick_interval = 1.0 / effect_def.tick_rate

                    while effect.accumulator >= tick_interval:
                        effect.accumulator -= tick_interval

                        # Apply tick damage
                        damage = effect_def.damage_per_tick * effect.stacks
                        if damage > 0:
                            actual_damage = self.apply_damage(entity_id, damage)

                            # Dispatch EffectTick event
                            try:
                                if event_bus and actual_damage > 0:
                                    from .events import EffectTick
                                    tick_event = EffectTick(
                                        entity_id=entity_id,
                                        effect=effect,
                                        damage_applied=actual_damage,
                                        stacks=effect.stacks
                                    )
                                    event_bus.dispatch(tick_event)
                            except:
                                pass  # Event dispatch is optional

                # Process stat modifications (ongoing effects) - placeholder for future features
                # This is where buff/debuff stat modifications would be applied
                # For now, this is a no-op but maintains the structure for future expansion

                # Check for expiration
                if effect.time_remaining <= 0:
                    effects_to_remove.append(effect_id)

                    # Dispatch effect expired event
                    try:
                        if event_bus:
                            from .events import EffectExpired
                            expired_event = EffectExpired(
                                entity_id=entity_id,
                                effect=effect
                            )
                            event_bus.dispatch(expired_event)
                    except:
                        pass  # Event dispatch is optional

            # Remove expired effects
            for effect_id in effects_to_remove:
                del effects[effect_id]

        # Clean up empty entity entries
        empty_entities = [eid for eid, effects in self._active_effects.items() if not effects]
        for eid in empty_entities:
            del self._active_effects[eid]

    def get_current_health(self, entity_id: str) -> float:
        """Get current health of an entity."""
        state = self.get_state(entity_id)
        return state.current_health if state else 0.0

    def get_current_resource(self, entity_id: str) -> float:
        """Get current resource of an entity."""
        state = self.get_state(entity_id)
        return state.current_resource if state else 0.0

    def get_is_alive(self, entity_id: str) -> bool:
        """Check if an entity is alive."""
        state = self.get_state(entity_id)
        return state.is_alive if state else False

    def get_active_effects(self, entity_id: str) -> List["EffectInstance"]:
        """Get all active effects on an entity."""
        return list(self._active_effects.get(entity_id, {}).values())

    def get_cooldown_remaining(self, entity_id: str, skill_id: str) -> float:
        """Get remaining cooldown time for a skill."""
        state = self.get_state(entity_id)
        if not state:
            return 0.0
        return state.active_cooldowns.get(skill_id, 0.0)

    def get_effect_stacks(self, entity_id: str, effect_id: str) -> int:
        """Get current stacks of a specific effect on an entity."""
        effects = self._active_effects.get(entity_id, {})
        effect = effects.get(effect_id)
        return effect.stacks if effect else 0

    def remove_effect(self, entity_id: str, effect_id: str) -> bool:
        """Remove a specific effect from an entity.

        Returns:
            True if effect was found and removed, False otherwise
        """
        if entity_id in self._active_effects and effect_id in self._active_effects[entity_id]:
            del self._active_effects[entity_id][effect_id]
            return True
        return False

    def clear_all_effects(self, entity_id: str) -> int:
        """Clear all effects from an entity.

        Returns:
            Number of effects removed
        """
        if entity_id in self._active_effects:
            count = len(self._active_effects[entity_id])
            del self._active_effects[entity_id]
            return count
        return 0

    # ============================================================================
    # PR8c FINAL API METHODS - No Legacy Compatibility
    # ============================================================================

    def add_entity(self, entity: Entity) -> None:
        """PR8c: Add an entity to state management."""
        if entity.id in self.states:
            raise ValueError(f"Entity '{entity.id}' is already registered")

        self.states[entity.id] = EntityState(
            current_health=entity.final_stats.max_health,
            current_resource=entity.final_stats.max_resource,
            max_resource=entity.final_stats.max_resource
        )

    def remove_entity(self, entity_id: str) -> None:
        """PR8c: Remove an entity from state management."""
        if entity_id not in self.states:
            raise KeyError(f"Entity '{entity_id}' is not registered")
        del self.states[entity_id]
        if entity_id in self._active_effects:
            del self._active_effects[entity_id]

    def get_state(self, entity_id: str) -> EntityState:
        """Get entity state - requires entity to exist."""
        state = self.states.get(entity_id)
        if state is None:
            raise KeyError(f"Entity '{entity_id}' not registered - call add_entity() first")
        return state

    def is_registered(self, entity_id: str) -> bool:
        """Check if entity is registered."""
        return entity_id in self.states

    def set_health(self, entity_id: str, health: float) -> None:
        """PR8c: Directly set entity health."""
        state = self.get_state(entity_id)
        if health < 0:
            health = 0
        state.current_health = health
        state.is_alive = health > 0

    def set_resource(self, entity_id: str, amount: float) -> None:
        """PR8c: Directly set entity resource."""
        state = self.get_state(entity_id)
        state.current_resource = max(0, min(amount, state.max_resource))

    def set_cooldown(self, entity_id: str, skill_name: str, cooldown_seconds: float) -> None:
        """Set skill cooldown."""
        state = self.get_state(entity_id)
        state.active_cooldowns[skill_name] = cooldown_seconds

    def iter_effects(self, entity_id: str) -> List["EffectInstance"]:
        """PR8c: Iterator for entity's active effects (replaces direct dict access)."""
        if self.strict_mode and entity_id not in self.states:
            raise KeyError(f"Entity '{entity_id}' not registered - call add_entity() first")
        return list(self._active_effects.get(entity_id, {}).values())

    def reset_system(self) -> None:
        """PR8c: Clear all states and effects."""
        self.states.clear()
        self._active_effects.clear()

    # ============================================================================
    # PR8C LEGACY COMPATIBILITY METHODS (remove after transition)
    # ============================================================================

    def apply_debuff(self, entity_id: str, debuff_name: str, stacks_to_add: int = 1, max_duration: float = 10.0) -> None:
        """PR8c: Legacy compatibility method - converts debuff to effect and applies it."""
        from .models import EffectInstance
        import uuid

        # Create a proper effect instance from debuff parameters
        effect = EffectInstance(
            id=str(uuid.uuid4()),  # Generate unique instance ID
            definition_id=debuff_name,  # Use debuff name as definition ID
            source_id="legacy_debuff",  # Generic source for legacy compatibility
            time_remaining=max_duration,
            tick_interval=1.0,  # Default tick interval
            stacks=stacks_to_add,
            value=5.0  # Default damage value for debuffs
        )

        self.apply_effect(entity_id, effect)

    def add_or_refresh_debuff(self, entity_id: str, debuff_name: str, stacks_to_add: int = 1) -> None:
        """PR8c: Legacy compatibility method - stack or refresh existing debuff."""
        self.apply_debuff(entity_id, debuff_name, stacks_to_add)

    def register_entity(self, entity: Entity) -> None:
        """PR8c: Legacy compatibility method for register_entity."""
        self.add_entity(entity)

    def unregister_entity(self, entity_id: str) -> None:
        """PR8c: Legacy compatibility method for unregister_entity."""
        self.remove_entity(entity_id)

    def tick(self, delta_time: float, event_bus: Optional["EventBus"] = None) -> None:
        """PR8c: Legacy compatibility method for tick (delegates to update)."""
        self.update(delta_time, event_bus)

    def get_all_states(self) -> Dict[str, EntityState]:
        """PR8c: Legacy compatibility method for get_all_states."""
        return self.states

    # ============================================================================
    # CLEANUP METHODS - Remove after transition period
    # ============================================================================

    def cleanup_expired_entities(self) -> int:
        """Remove entities with no health and no effects.

        Returns:
            Number of entities cleaned up
        """
        expired_entities = []
        for entity_id, state in self.states.items():
            has_effects = entity_id in self._active_effects and self._active_effects[entity_id]
            if not state.is_alive and not has_effects:
                expired_entities.append(entity_id)

        for entity_id in expired_entities:
            del self.states[entity_id]
            if entity_id in self._active_effects:
                del self._active_effects[entity_id]

        return len(expired_entities)

    # ============================================================================
    # OPERATOR OVERLOADS
    # ============================================================================

    def __len__(self) -> int:
        """Return number of registered entities."""
        return len(self.states)

    def __contains__(self, entity_id: str) -> bool:
        """Check if entity is registered."""
        return entity_id in self.states



// =================================================================
// METADATA
// =================================================================
// File Path:      src\__init__.py
// Size:           0.09 KB
// Last Modified:  2025-11-09T18:07:51.936Z
// =================================================================

"""Combat Engine - Core combat system for dungeon crawler RPG"""

__version__ = "0.2.0"



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\fixtures.py
// Size:           5.12 KB
// Last Modified:  2025-11-17T11:36:41.217Z
// =================================================================

"""Test fixtures and helper functions for Combat Engine tests."""

import random
from typing import Optional
from src.models import Entity, EntityStats
from src.state import StateManager


def make_rng(seed: int = 42) -> random.Random:
    """Create a deterministic random number generator for testing.

    Args:
        seed: Random seed for reproducible results

    Returns:
        Configured Random instance
    """
    rng = random.Random()
    rng.seed(seed)
    return rng


def make_entity(
    entity_id: str,
    name: Optional[str] = None,
    base_damage: float = 100.0,
    armor: float = 50.0,
    crit_chance: float = 0.1,
    crit_damage: float = 1.5,
    pierce_ratio: float = 0.1,
    max_health: float = 1000.0,
    evasion_chance: float = 0.0,
    dodge_chance: float = 0.0,
    block_chance: float = 0.0,
    block_amount: float = 0.0,
    rarity: str = "Common"
) -> Entity:
    """Create a test entity with common default values.

    Args:
        entity_id: Unique identifier for the entity
        name: Display name (defaults to entity_id if None)
        base_damage: Base damage stat
        armor: Armor stat
        crit_chance: Critical hit chance (0.0 to 1.0)
        crit_damage: Critical hit damage multiplier
        pierce_ratio: Armor pierce ratio
        max_health: Maximum health
        rarity: Entity rarity tier

    Returns:
        Configured Entity instance
    """
    stats = EntityStats(
        base_damage=base_damage,
        armor=armor,
        crit_chance=crit_chance,
        crit_damage=crit_damage,
        pierce_ratio=pierce_ratio,
        max_health=max_health,
        evasion_chance=evasion_chance,
        dodge_chance=dodge_chance,
        block_chance=block_chance,
        block_amount=block_amount
    )
    return Entity(
        id=entity_id,
        base_stats=stats,
        name=name or entity_id,
        rarity=rarity
    )


def make_attacker(
    base_damage: float = 100.0,
    crit_chance: float = 0.1,
    crit_damage: float = 1.5,
    pierce_ratio: float = 0.1,
    rarity: str = "Common"
) -> Entity:
    """Create a test attacker entity with offensive-focused stats.

    Args:
        base_damage: Attack damage
        crit_chance: Critical hit chance
        crit_damage: Critical hit multiplier
        pierce_ratio: Armor pierce ratio
        rarity: Entity rarity

    Returns:
        Configured attacker Entity
    """
    return make_entity(
        entity_id="attacker",
        name="Test Attacker",
        base_damage=base_damage,
        armor=10.0,  # Low armor for attackers
        crit_chance=crit_chance,
        crit_damage=crit_damage,
        pierce_ratio=pierce_ratio,
        max_health=800.0,
        rarity=rarity
    )


def make_defender(
    armor: float = 50.0,
    max_health: float = 1000.0,
    pierce_ratio: float = 0.05,
    evasion_chance: float = 0.0,
    dodge_chance: float = 0.0,
    block_chance: float = 0.0,
    block_amount: float = 0.0
) -> Entity:
    """Create a test defender entity with defensive-focused stats.

    Args:
        armor: Armor value
        max_health: Health pool
        pierce_ratio: Armor pierce ratio (typically low for defenders)

    Returns:
        Configured defender Entity
    """
    return make_entity(
        entity_id="defender",
        name="Test Defender",
        base_damage=50.0,  # Low damage for defenders
        armor=armor,
        crit_chance=0.05,  # Low crit chance
        crit_damage=1.2,   # Low crit damage
        pierce_ratio=pierce_ratio,
        max_health=max_health,
        rarity="Common"
    )


def make_high_armor_defender() -> Entity:
    """Create a defender with very high armor for pierce testing."""
    return make_defender(armor=150.0, max_health=1200.0)


def make_glass_cannon_attacker() -> Entity:
    """Create an attacker with high damage but low survivability."""
    return make_entity(
        entity_id="glass_cannon",
        name="Glass Cannon",
        base_damage=200.0,
        armor=5.0,
        crit_chance=0.3,
        crit_damage=2.5,
        pierce_ratio=0.2,
        max_health=400.0,
        rarity="Rare"
    )


def make_tank_defender() -> Entity:
    """Create a defender with high armor and health."""
    return make_entity(
        entity_id="tank",
        name="Tank Defender",
        base_damage=30.0,
        armor=100.0,
        crit_chance=0.02,
        crit_damage=1.1,
        pierce_ratio=0.02,
        max_health=2000.0,
        rarity="Common"
    )


def make_state_manager(attacker: Optional[Entity] = None, defender: Optional[Entity] = None) -> StateManager:
    """Create a state manager pre-registered with test entities.

    Args:
        attacker: Optional attacker entity to register
        defender: Optional defender entity to register

    Returns:
        Configured StateManager instance
    """
    state_manager = StateManager()

    if attacker:
        state_manager.register_entity(attacker)

    if defender:
        state_manager.register_entity(defender)

    return state_manager



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_combat_math.py
// Size:           7.34 KB
// Last Modified:  2025-11-17T20:12:08.277Z
// =================================================================

"""Test suite for combat_math.py pure functions."""

import pytest
from random import Random
from src.combat_math import (
    roll_chance,
    resolve_crit,
    evade_dodge_or_normal,
    apply_block_damage,
    apply_glancing_damage,
    apply_pierce_to_armor,
    apply_armor_mitigation,
    calculate_pierce_damage_formula,
    clamp_min_damage,
    calculate_skill_effect_proc
)


class TestRollChance:
    """Test the roll_chance function."""

    def test_chance_zero_never_procs(self, seeded_rng):
        """Chance of 0 should never proc."""
        for _ in range(100):
            assert roll_chance(seeded_rng, 0.0) is False

    def test_chance_one_always_procs(self, seeded_rng):
        """Chance of 1 should always proc."""
        for _ in range(100):
            assert roll_chance(seeded_rng, 1.0) is True

    def test_deterministic_with_seed(self):
        """Same seed should give consistent results."""
        rng1 = Random(123)
        rng2 = Random(123)

        result1 = roll_chance(rng1, 0.5)
        result2 = roll_chance(rng2, 0.5)

        assert result1 == result2


class TestResolveCrit:
    """Test the resolve_crit function."""

    def test_crit_deterministic_with_seed(self):
        """Crit resolution should be deterministic with seeded RNG."""
        rng = Random(1)
        is_crit, mult = resolve_crit(rng, 1.0, 3.0)
        assert is_crit is True
        assert mult == 3.0

    def test_no_crit_when_zero_chance(self):
        """Zero crit chance should never result in crit."""
        rng = Random(1)
        for _ in range(10):
            is_crit, mult = resolve_crit(rng, 0.0, 2.0)
            assert is_crit is False
            assert mult == 1.0

    def test_crit_mult_normal_when_no_crit(self):
        """Non-crit hits should have multiplier of 1.0."""
        rng = Random(1)
        # Using a very low crit chance to ensure no crit
        is_crit, mult = resolve_crit(rng, 0.001, 2.0)
        assert is_crit is False
        assert mult == 1.0


class TestEvadeDodgeOrNormal:
    """Test the evade_dodge_or_normal function."""

    def test_returns_valid_results(self, seeded_rng):
        """Function should only return 'dodge', 'evade', or 'normal'."""
        for _ in range(100):
            result = evade_dodge_or_normal(seeded_rng, 0.1, 0.2)
            assert result in ['dodge', 'evade', 'normal']

    def test_deterministic_with_seed(self):
        """Same seed should produce consistent results."""
        rng1 = Random(42)
        rng2 = Random(42)

        result1 = evade_dodge_or_normal(rng1, 0.5, 0.3)
        result2 = evade_dodge_or_normal(rng2, 0.5, 0.3)

        assert result1 == result2

    def test_zero_chances_always_normal(self):
        """Zero evade/dodge chances should always result in normal."""
        rng = Random(123)
        for _ in range(50):
            result = evade_dodge_or_normal(rng, 0.0, 0.0)
            assert result == 'normal'


class TestApplyBlockDamage:
    """Test the apply_block_damage function."""

    def test_block_reduces_damage(self):
        """Blocking should reduce damage but not below minimum."""
        assert apply_block_damage(100, 50) == 50
        assert apply_block_damage(50, 60) == 1  # Minimum of 1
        assert apply_block_damage(10, 5) == 5

    def test_minimum_damage_one(self):
        """Damage should never drop below 1."""
        assert apply_block_damage(0.5, 0.5) == 1
        assert apply_block_damage(0, 100) == 1


class TestApplyGlancingDamage:
    """Test the apply_glancing_damage function."""

    def test_applies_multiplier(self):
        """Glancing should apply damage multiplier."""
        assert apply_glancing_damage(100, 0.5) == 50.0
        assert apply_glancing_damage(200, 0.25) == 50.0

    def test_zero_multiplier_no_damage(self):
        """Zero multiplier should result in no damage (0% of original)."""
        assert apply_glancing_damage(100, 0.0) == 0  # 0% glancing means 0 damage


class TestApplyPierceToArmor:
    """Test the apply_pierce_to_armor function."""

    def test_pierce_reduces_armor(self):
        """Pierce should reduce effective armor."""
        assert apply_pierce_to_armor(100, 0.5) == 50.0
        assert apply_pierce_to_armor(200, 0.25) == 150.0

    def test_full_pierce_zero_armor(self):
        """100% pierce should result in zero armor."""
        assert apply_pierce_to_armor(100, 1.0) == 0.0

    def test_zero_pierce_full_armor(self):
        """0% pierce should leave armor unchanged."""
        assert apply_pierce_to_armor(100, 0.0) == 100.0


class TestApplyArmorMitigation:
    """Test the apply_armor_mitigation function."""

    def test_armor_reduces_damage(self):
        """Armor should reduce damage but not below zero."""
        assert apply_armor_mitigation(100, 50) == 50.0
        assert apply_armor_mitigation(50, 100) == 0.0

    def test_zero_armor_full_damage(self):
        """Zero armor should leave damage unchanged."""
        assert apply_armor_mitigation(100, 0) == 100.0


class TestCalculatePierceDamageFormula:
    """Test the calculate_pierce_damage_formula function."""

    def test_uses_max_formula(self):
        """Formula should use max(pre_pierce_damage, pierced_damage)."""
        # pre_pierce_damage = 100 - 50 = 50
        # pierced_damage = 100 (assuming current_damage = 100)
        assert calculate_pierce_damage_formula(50, 100) == 100

        # Test case where normal damage is higher
        assert calculate_pierce_damage_formula(80, 40) == 80

    def test_never_negative(self):
        """Result should never be negative."""
        assert calculate_pierce_damage_formula(-10, -5) == 0
        assert calculate_pierce_damage_formula(0, 0) == 0


class TestClampMinDamage:
    """Test the clamp_min_damage function."""

    def test_enforces_minimum(self):
        """Should enforce minimum damage."""
        assert clamp_min_damage(5, 1) == 5
        assert clamp_min_damage(0, 1) == 1
        assert clamp_min_damage(-1, 0) == 0

    def test_zero_minimum_allows_zero(self):
        """Zero minimum should allow zero damage."""
        assert clamp_min_damage(0, 0) == 0
        assert clamp_min_damage(-5, 0) == 0


class TestCalculateSkillEffectProc:
    """Test the calculate_skill_effect_proc function."""

    def test_wrapper_around_roll_chance(self):
        """Function should wrap roll_chance."""
        rng = Random(123)
        # Test deterministic result
        rng = Random(1)
        result1 = calculate_skill_effect_proc(rng, 0.5)
        # Reset and try again
        rng = Random(1)
        result2 = calculate_skill_effect_proc(rng, 0.5)
        assert result1 == result2

    def test_high_proc_rate_always_procs(self):
        """High proc rate should always proc (for seeded RNG)."""
        rng = Random(123)
        # Depending on seed, this will be deterministic
        result = calculate_skill_effect_proc(rng, 0.99)
        assert isinstance(result, bool)

    def test_zero_proc_rate_never_procs(self):
        """Zero proc rate should never proc."""
        rng = Random(123)
        for _ in range(10):
            assert calculate_skill_effect_proc(rng, 0.0) is False


# Fixtures
@pytest.fixture
def seeded_rng():
    """Provide a seeded RNG for deterministic tests."""
    return Random(42)



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_cross_reference_validation.py
// Size:           9.08 KB
// Last Modified:  2025-11-18T20:46:34.054Z
// =================================================================

"""Tests for cross-reference validation in PR-P1S3."""

import pytest
import tempfile
import os
import shutil
from unittest.mock import patch

from src.data.typed_models import DataValidationError, Rarity, ItemSlot, DamageType, EffectType, TriggerEvent
from src.game_data_provider import GameDataProvider


class TestCrossReferenceValidation:
    """Test suite for data cross-reference validation."""

    def setup_method(self):
        """Set up test environment."""
        self.temp_dir = tempfile.mkdtemp()
        # Reset singleton instance between tests
        GameDataProvider._instance = None

    def teardown_method(self):
        """Clean up test environment."""
        GameDataProvider._instance = None
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def create_test_csv_files(self, custom_data=None):
        """Create test CSV files with minimal valid data."""
        # Use real-world example data but make it valid
        base_data = {
            'affixes.csv': """affix_id,stat_affected,mod_type,base_value,description,affix_pools
damage_flat,base_damage,flat,5.0,"+5 Base Damage",weapon
health_flat,max_health,flat,20.0,"+20 Health",armor""",

            'items.csv': """item_id,name,slot,rarity,affix_pools,num_random_affixes
test_sword,Test Sword,Weapon,Rare,weapon,2
test_armor,Test Armor,Chest,Epic,armor,1""",

            'quality_tiers.csv': """quality_id,tier_name,min_range,max_range,Common,Uncommon,Rare,Epic,Legendary,Mythic
1,Low,1,25,50,30,15,4,1,0
2,Medium,26,50,20,40,25,10,4,1""",

            'effects.csv': """effect_id,name,type,description,max_stacks,tick_rate,damage_per_tick,stat_multiplier,stat_add,visual_effect,duration
bleed,Bleeding,DoT,"Target takes damage over time from bleeding",3,1.0,5.0,0.0,0.0,blood,10.0
burn,Burning,DoT,"Target burns from fire damage",5,0.5,3.0,0.0,0.0,flames,8.0
healing_over_time,Healing Over Time,HoT,"Target regenerates health over time",1,2.0,0.0,0.0,5.0,glow,12.0""",

            'skills.csv': """skill_id,name,damage_type,hits,description,resource_cost,cooldown,trigger_event,proc_rate,trigger_result,trigger_duration,stacks_max
basic_slash,Basic Slash,Physical,1,"Basic physical attack that deals moderate damage.",0,1.0,,,0.0,0
bleed_strike,Bleed Strike,Physical,1,"Slash that causes bleeding DoT on critical hits.",15,3.0,OnCrit,0.8,bleed,8.0,3
burn_attack,Burn Attack,Fire,1,"Fire attack that burns enemies.",20,4.0,OnHit,0.7,burn,6.0,5
heal_skill,Heal Skill,Physical,1,"Skill that provides healing over time.",30,5.0,OnSkillUsed,1.0,healing_over_time,10.0,1"""
        }

        if custom_data:
            base_data.update(custom_data)

        for filename, content in base_data.items():
            with open(os.path.join(self.temp_dir, filename), 'w') as f:
                f.write(content)

        return self.temp_dir

    def test_valid_cross_references(self):
        """Test that valid cross-references pass validation."""
        data_dir = self.create_test_csv_files()

        with patch('src.game_data_provider.os.path.dirname', return_value=data_dir), \
             patch('src.game_data_provider.os.path.join', side_effect=os.path.join):
            provider = GameDataProvider()
            # This should not raise any exceptions
            provider._validate_cross_references()

    def test_invalid_skill_effect_reference(self):
        """Test that invalid skill effect references would be caught."""
        # This test demonstrates the validation error structure
        # In real usage, the validation is tested by the actual data loading

        error = DataValidationError(
            "Skill 'invalid_skill' references non-existent effect ID 'non_existent_effect'",
            data_type="SkillDefinition",
            field_name="trigger_result",
            invalid_id="non_existent_effect",
            suggestions=["bleed", "burn", "healing_over_time"]
        )

        assert "non_existent_effect" in str(error)
        assert error.data_type == "SkillDefinition"
        assert error.field_name == "trigger_result"
        assert "bleed" in error.suggestions

    def test_invalid_item_implicit_affix_reference(self):
        """Test that invalid item implicit affix references would be caught."""
        error = DataValidationError(
            "Item 'test_armor' references non-existent implicit affix ID 'non_existent_affix'",
            data_type="ItemTemplate",
            field_name="implicit_affixes",
            invalid_id="non_existent_affix",
            suggestions=["damage_flat", "health_flat"]
        )

        assert "non_existent_affix" in str(error)
        assert error.data_type == "ItemTemplate"
        assert error.field_name == "implicit_affixes"
        assert "damage_flat" in error.suggestions

    def test_invalid_stat_names(self):
        """Test that invalid stat names would be caught."""
        error = DataValidationError(
            "Invalid stat name 'made_up_stat'",
            data_type="EntityStats",
            field_name="stat_affected",
            invalid_id="made_up_stat",
            suggestions=["base_damage", "max_health", "attack_speed"]
        )

        assert "made_up_stat" in str(error)
        assert error.data_type == "EntityStats"
        assert error.field_name == "stat_affected"
        assert "base_damage" in error.suggestions

    def test_negative_quality_rarity_probabilities(self):
        """Test that negative quality probabilities would be caught."""
        error = DataValidationError(
            "Quality tier 'Low' has negative probability for rarity 'Rare'",
            data_type="QualityTier",
            field_name="rare",
            invalid_id="-15"
        )

        assert "negative probability" in str(error).lower()
        assert "Quality tier 'Low'" in str(error)

    def test_multiple_validation_errors(self):
        """Test that multiple validation errors would be caught."""
        # Test demonstrates that validation catches first error encountered
        error = DataValidationError(
            "Skill 'invalid_skill' references non-existent effect ID 'non_existent_effect'",
            data_type="SkillDefinition",
            field_name="trigger_result",
            invalid_id="non_existent_effect",
            suggestions=["bleed", "burn", "healing_over_time"]
        )

        assert "non_existent_effect" in str(error)
        assert error.data_type == "SkillDefinition"

    def test_valid_dual_stat_affixes(self):
        """Test that dual stat affixes are supported."""
        # Integration test - this validates that real data loading handles dual stats
        provider = GameDataProvider()
        affixes = provider.get_affixes()

        # Check for a dual-stat affix (like swiftslayer)
        dual_stat_affix_found = False
        for affix in affixes.values():
            if affix.dual_stat and ";" in affix.stat_affected:
                dual_stat_affix_found = True
                break

        assert dual_stat_affix_found, "Expected to find at least one dual-stat affix in loaded data"

    def test_skill_without_trigger_result_is_valid(self):
        """Test that skills without trigger_result are handled correctly."""
        provider = GameDataProvider()
        skills = provider.get_skills()

        # Find skills without trigger_result
        skills_without_trigger = [skill for skill in skills.values() if not skill.trigger_result]

        # Should have at least some skills without trigger results
        assert len(skills_without_trigger) > 0, "Expected to find skills without trigger results"

    def test_item_without_implicit_affixes_is_valid(self):
        """Test that items without implicit affixes are handled correctly."""
        provider = GameDataProvider()
        items = provider.get_items()

        # Find items without implicit affixes
        items_without_implicits = [item for item in items.values() if not item.implicit_affixes]

        # Should have at least some items without implicit affixes
        assert len(items_without_implicits) > 0, "Expected to find items without implicit affixes"


class TestDataValidationError:
    """Test the DataValidationError exception class."""

    def test_error_message_formatting(self):
        """Test that error messages are properly formatted."""
        error = DataValidationError(
            "Test error message",
            data_type="TestType",
            field_name="test_field",
            invalid_id="invalid_123",
            suggestions=["valid_1", "valid_2"]
        )

        message = str(error)
        assert "Test error message" in message
        assert "Suggestions: valid_1, valid_2" in message

    def test_error_without_suggestions(self):
        """Test error formatting without suggestions."""
        error = DataValidationError(
            "Simple error",
            data_type="SimpleType",
            field_name="simple_field",
            invalid_id="wrong_id"
        )

        message = str(error)
        assert "Simple error" in message
        assert "Suggestions:" not in message



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_data_parser.py
// Size:           28.66 KB
// Last Modified:  2025-11-18T20:52:53.978Z
// =================================================================

"""Tests for data_parser module with CSV schema validation."""

import pytest
import tempfile
import os
from pathlib import Path
import csv

from src.data.data_parser import parse_csv, parse_all_csvs
from src.data.schemas import (
    AFFIX_SCHEMA,
    ITEM_SCHEMA,
    QUALITY_TIERS_SCHEMA,
    EFFECTS_SCHEMA,
    SKILLS_SCHEMA
)


class TestCSVParseSchema:

    def test_parse_csv_missing_required_column(self):
        """Test CSV parse fails when required columns are missing."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            f.write("name,value\n")
            f.write("Test Item,10\n")
            temp_file = f.name

        try:
            with pytest.raises(ValueError) as exc_info:
                parse_csv(temp_file, ITEM_SCHEMA)
            assert "Missing required columns" in str(exc_info.value)
            assert "item_id" in str(exc_info.value)
        finally:
            os.unlink(temp_file)

    def test_parse_csv_bad_float_value(self):
        """Test CSV parse fails with invalid float."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            writer = csv.writer(f)
            writer.writerow(["item_id", "name", "slot", "rarity", "num_random_affixes"])
            writer.writerow(["test_item", "Test Item", "Weapon", "Common", "not-a-number"])
            temp_file = f.name

        try:
            with pytest.raises(ValueError) as exc_info:
                parse_csv(temp_file, ITEM_SCHEMA)
            assert "Invalid integer value" in str(exc_info.value)
        finally:
            os.unlink(temp_file)

    def test_parse_csv_invalid_positive_float(self):
        """Test CSV parse fails with non-positive float."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            writer = csv.writer(f)
            writer.writerow(["effect_id", "name", "type", "description", "tick_rate"])
            writer.writerow(["bleed", "Bleed", "DoT", "Deals damage", "-1.0"])
            temp_file = f.name

        try:
            with pytest.raises(ValueError) as exc_info:
                parse_csv(temp_file, EFFECTS_SCHEMA)
            assert "Value must be >= 0" in str(exc_info.value)
        finally:
            os.unlink(temp_file)

    def test_parse_csv_valid_data(self):
        """Test CSV parse succeeds with valid data."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            writer = csv.writer(f)
            writer.writerow(["item_id", "name", "slot", "rarity", "num_random_affixes"])
            writer.writerow(["iron_sword", "Iron Sword", "Weapon", "Common", "2"])
            writer.writerow(["leather_armor", "Leather Armor", "Chest", "Common", "0"])
            temp_file = f.name

        try:
            rows = parse_csv(temp_file, ITEM_SCHEMA)
            assert len(rows) == 2
            assert rows[0]["item_id"] == "iron_sword"
            assert rows[0]["name"] == "Iron Sword"
            assert rows[0]["num_random_affixes"] == 2
            assert rows[1]["item_id"] == "leather_armor"
            assert rows[1]["num_random_affixes"] == 0
        finally:
            os.unlink(temp_file)

    def test_parse_csv_with_empty_optional_fields(self):
        """Test CSV parse handles empty optional fields."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            writer = csv.writer(f)
            writer.writerow(["affix_id", "stat_affected", "mod_type", "base_value", "description"])
            writer.writerow(["sharp", "damage", "flat", "15.5", "+{value} Damage"])
            temp_file = f.name

        try:
            rows = parse_csv(temp_file, AFFIX_SCHEMA)
            assert len(rows) == 1
            assert rows[0]["affix_id"] == "sharp"
            assert rows[0]["affix_pools"] == []  # Empty field defaults to empty list
            assert rows[0]["stacks_max"] == 1  # Default value
        finally:
            os.unlink(temp_file)

    def test_parse_csv_affix_pools_validator(self):
        """Test affix pools validator parses pipe-separated values."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            writer = csv.writer(f)
            writer.writerow(["item_id", "name", "slot", "rarity", "affix_pools", "num_random_affixes"])
            writer.writerow(["magic_sword", "Magic Sword", "Weapon", "Rare", "weapon_pool|magic_pool|rare_pool", "3"])
            temp_file = f.name

        try:
            rows = parse_csv(temp_file, ITEM_SCHEMA)
            assert rows[0]["affix_pools"] == ["weapon_pool", "magic_pool", "rare_pool"]
        finally:
            os.unlink(temp_file)

    def test_parse_csv_duplicate_id_detection(self):
        """Test that duplicate IDs are not handled automatically (this would require additional logic)."""
        # This test documents current behavior - duplicate IDs would just overwrite
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            writer = csv.writer(f)
            writer.writerow(["item_id", "name", "slot", "rarity", "num_random_affixes"])
            writer.writerow(["sword", "Iron Sword", "Weapon", "Common", "2"])
            writer.writerow(["sword", "Steel Sword", "Weapon", "Common", "1"])  # Duplicate ID
            temp_file = f.name

        try:
            rows = parse_csv(temp_file, ITEM_SCHEMA)
            # Currently allows duplicates, last one wins
            assert len(rows) == 2
            assert rows[0]["name"] == "Iron Sword"
            assert rows[1]["name"] == "Steel Sword"
        finally:
            os.unlink(temp_file)

    def test_parse_all_csvs_quality_tier_range_validation(self):
        """Test that parse_all_csvs validates quality tier min_range < max_range."""
        with tempfile.TemporaryDirectory() as tmp_dir:
            # Create a valid quality tiers CSV with invalid range
            csv_file = os.path.join(tmp_dir, "quality_tiers.csv")
            with open(csv_file, 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(["quality_id", "tier_name", "min_range", "max_range"])
                writer.writerow(["1", "Low", "5", "3"])  # Invalid range: min > max

            with pytest.raises(ValueError) as exc_info:
                parse_all_csvs(tmp_dir)
            error_msg = str(exc_info.value)
            # Should catch the min >= max validation error in parse_all_csvs
            assert "min_range" in error_msg.lower() or "max_range" in error_msg.lower()


class TestParseAllCSVs:

    def test_parse_all_csvs_with_project_data(self, tmp_path):
        """Test parsing all CSVs in a directory structure similar to the project."""
        # Copy project CSV files to temp dir
        import os
        src_data_dir = Path(__file__).parent.parent / "data"
        if not src_data_dir.exists():
            pytest.skip("Project data directory not found")

        for csv_file in src_data_dir.glob("*.csv"):
            # Create minimal test CSVs with required columns
            if "affixes" in csv_file.name:
                self._create_test_affix_csv(tmp_path / csv_file.name)
            elif "items" in csv_file.name:
                self._create_test_item_csv(tmp_path / csv_file.name)
            elif "effects" in csv_file.name:
                self._create_test_effect_csv(tmp_path / csv_file.name)
            elif "skills" in csv_file.name:
                self._create_test_skill_csv(tmp_path / csv_file.name)
            elif "quality_tiers" in csv_file.name:
                self._create_test_quality_tiers_csv(tmp_path / csv_file.name)

        # Parse all CSVs
        result = parse_all_csvs(str(tmp_path))

        # Verify structure
        assert "affixes" in result
        assert "items" in result
        assert "effects" in result
        assert "skills" in result
        assert "quality_tiers" in result

        # Verify data types
        assert isinstance(result["affixes"], dict)
        assert isinstance(result["items"], dict)
        assert isinstance(result["effects"], dict)
        assert isinstance(result["skills"], dict)
        assert isinstance(result["quality_tiers"], list)

    def _create_test_affix_csv(self, filepath):
        """Create a test affixes CSV."""
        with open(filepath, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["affix_id", "stat_affected", "mod_type", "base_value", "description"])
            writer.writerow(["test_affix", "damage", "flat", "10", "Test affix"])
            writer.writerow(["fire_affix", "fire_damage", "percent", "25", "Fire damage"])

    def _create_test_item_csv(self, filepath):
        """Create a test items CSV."""
        with open(filepath, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["item_id", "name", "slot", "rarity", "num_random_affixes"])
            writer.writerow(["sword1", "Iron Sword", "Weapon", "Common", "2"])
            writer.writerow(["armor1", "Leather Armor", "Chest", "Common", "1"])

    def _create_test_effect_csv(self, filepath):
        """Create a test effects CSV."""
        with open(filepath, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["effect_id", "name", "type", "description"])
            writer.writerow(["bleeding", "Bleed", "DoT", "Deals damage over time"])

    def _create_test_skill_csv(self, filepath):
        """Create a test skills CSV."""
        with open(filepath, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["skill_id", "name", "damage_type"])
            writer.writerow(["fireball", "Fireball", "Fire"])

    def _create_test_quality_tiers_csv(self, filepath):
        """Create a test quality tiers CSV."""
        with open(filepath, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["quality_id", "tier_name", "min_range", "max_range"])
            writer.writerow(["1", "Poor", "0", "10"])


class TestSchemasValidators:

    def test_str_validator_handles_various_inputs(self):
        """Test string validator handles various input types."""
        from src.data.schemas import str_validator

        assert str_validator("hello") == "hello"
        assert str_validator(str(123)) == "123"  # Convert to str for typing
        # These won't actually be passed None or int directly in the CSV parser
        assert str_validator("") == ""

    def test_int_validator_rejects_invalid_values(self):
        """Test integer validator rejects invalid inputs."""
        from src.data.schemas import int_validator

        assert int_validator("123") == 123
        assert int_validator("1.0") == 1  # Handles float strings

        with pytest.raises(ValueError):
            int_validator("not-a-number")
        with pytest.raises(ValueError):
            int_validator("")

    def test_float_validator_range(self):
        """Test float validator accepts various numeric formats."""
        from src.data.schemas import float_validator

        assert float_validator("1.5") == 1.5
        assert float_validator("2") == 2.0
        assert float_validator("-5.0") == -5.0

        with pytest.raises(ValueError):
            float_validator("not-a-float")


class TestComprehensiveSchemaValidators:
    """Comprehensive tests for all schema validators."""

    def test_affix_pools_validator_edge_cases(self):
        """Test affix_pools_validator handles various edge cases."""
        from src.data.schemas import affix_pools_validator

        # Empty string
        assert affix_pools_validator("") == []
        assert affix_pools_validator("   ") == []

        # Single pool
        assert affix_pools_validator("weapon_pool") == ["weapon_pool"]

        # Multiple pools with spaces
        assert affix_pools_validator("weapon_pool | armor_pool") == ["weapon_pool", "armor_pool"]
        assert affix_pools_validator("  weapon_pool  |  armor_pool  ") == ["weapon_pool", "armor_pool"]

        # Empty segments
        assert affix_pools_validator("weapon_pool||armor_pool") == ["weapon_pool", "armor_pool"]
        assert affix_pools_validator("|weapon_pool|") == ["weapon_pool"]

    def test_tier_probabilities_validator_edge_cases(self):
        """Test tier_probabilities_validator edge cases."""
        from src.data.schemas import tier_probabilities_validator

        # Empty values become 0
        assert tier_probabilities_validator("") == 0
        assert tier_probabilities_validator("0") == 0
        # Note: None would cause a TypeError in actual CSV parsing, but this documents fallback behavior

        # Valid positive integers
        assert tier_probabilities_validator("42") == 42

        # Invalid negative values
        with pytest.raises(ValueError):
            tier_probabilities_validator("-1")

    def test_tier_range_validator(self):
        """Test tier_range_validator functionality."""
        from src.data.schemas import tier_range_validator

        # Valid ranges
        assert tier_range_validator("1", "10") == (1, 10)
        assert tier_range_validator("50", "100") == (50, 100)

        # Invalid ranges (min >= max)
        with pytest.raises(ValueError):
            tier_range_validator("10", "10")  # equal
        with pytest.raises(ValueError):
            tier_range_validator("20", "10")  # min > max

        # Invalid integer values
        with pytest.raises(ValueError):
            tier_range_validator("not-a-number", "10")
        with pytest.raises(ValueError):
            tier_range_validator("1", "not-a-number")

    def test_quality_id_validator(self):
        """Test quality_id_validator ensures >= 1."""
        from src.data.schemas import quality_id_validator

        assert quality_id_validator("1") == 1
        assert quality_id_validator("100") == 100

        # Invalid values
        with pytest.raises(ValueError):
            quality_id_validator("0")
        with pytest.raises(ValueError):
            quality_id_validator("-1")
        with pytest.raises(ValueError):
            quality_id_validator("not-a-number")


class TestSchemaValidationIntegration:
    """Test schema validation in complete parsing scenarios."""

    def test_affix_schema_complex_values(self):
        """Test affix schema with complex values like dual stats."""
        from src.data.schemas import AFFIX_SCHEMA

        # Test case similar to actual data: dual stat affix
        row_data = {
"affix_id": "swiftslayer",
"stat_affected": "attack_speed;cooldown_reduction",
"mod_type": "multiplier;flat",
"affix_pools": "weapon_pool",
"base_value": "0.25;0.08",
"description": "{value}% Attack Speed & {dual_value}% CD Reduction",
"dual_stat": "TRUE",
"stacks_max": "",
"proc_rate": "",
"trigger_duration": "",
"scaling_power": "",
"trigger_event": "",
"trigger_result": "",
"complex_effect": ""
        }

        # Validate all columns
        validated = {}
        for col, validator in AFFIX_SCHEMA["columns"].items():
            raw_value = row_data.get(col, "")
            validated[col] = validator(raw_value)

        # Check results
        assert validated["affix_id"] == "swiftslayer"
        assert validated["stat_affected"] == "attack_speed;cooldown_reduction"
        assert validated["dual_stat"] == True  # "TRUE" in CSV becomes boolean True
        assert validated["stacks_max"] == 1  # Default value
        assert validated["proc_rate"] == 0.0  # Default value
        assert validated["scaling_power"] == 0.0  # Default value

    def test_effects_schema_tick_rate_defaults(self):
        """Test effects schema with tick_rate defaulting."""
        from src.data.schemas import EFFECTS_SCHEMA

        # Effect without tick_rate specified should default to 1.0
        row_data = {
            "effect_id": "quick_effect",
            "name": "Quick Effect",
            "type": "buff",
            "description": "A quick effect",
            "max_stacks": "",
            "tick_rate": "",
            "damage_per_tick": "",
            "stat_multiplier": "",
            "stat_add": "",
            "visual_effect": "",
            "duration": ""
        }

        validated = {}
        for col, validator in EFFECTS_SCHEMA["columns"].items():
            raw_value = row_data.get(col, "")
            validated[col] = validator(raw_value)

        # Check defaults
        assert validated["max_stacks"] == 1
        assert validated["tick_rate"] == 1.0
        assert validated["duration"] == 10.0  # Explicit default in schema

    def test_skills_schema_defaults(self):
        """Test skills schema default values."""
        from src.data.schemas import SKILLS_SCHEMA

        row_data = {
            "skill_id": "basic_attack",
            "name": "Basic Attack",
            "damage_type": "",
            "hits": "",
            "description": "",
            "resource_cost": "",
            "cooldown": "",
            "trigger_event": "",
            "proc_rate": "",
            "trigger_result": "",
            "trigger_duration": "",
            "stacks_max": ""
        }

        validated = {}
        for col, validator in SKILLS_SCHEMA["columns"].items():
            raw_value = row_data.get(col, "")
            validated[col] = validator(raw_value)

        # Check defaults
        assert validated["hits"] == 1
        assert validated["resource_cost"] == 0.0
        assert validated["cooldown"] == 0.0
        assert validated["proc_rate"] == 0.0


class TestSchemaValidatorFactory:
    """Test the get_schema_validator function."""

    def test_get_schema_validator_affixes(self):
        """Test schema detection for affixes.csv."""
        from src.data.schemas import get_schema_validator

        schema = get_schema_validator("/path/to/affixes.csv")
        assert "required" in schema
        assert "affix_id" in schema["required"]

    def test_get_schema_validator_items(self):
        """Test schema detection for items.csv."""
        from src.data.schemas import get_schema_validator

        schema = get_schema_validator("items.csv")
        assert "required" in schema
        assert "item_id" in schema["required"]

    def test_get_schema_validator_unknown(self):
        """Test schema detection fails for unknown CSV files."""
        from src.data.schemas import get_schema_validator

        with pytest.raises(ValueError) as exc_info:
            get_schema_validator("unknown.csv")
        assert "No schema found" in str(exc_info.value)

    def test_get_schema_validator_quality_tiers(self):
        """Test schema detection for quality_tiers.csv."""
        from src.data.schemas import get_schema_validator

        schema = get_schema_validator("my_quality_tiers.csv")
        assert "required" in schema
        assert "quality_id" in schema["required"]

    def test_get_schema_validator_effects(self):
        """Test schema detection for effects.csv."""
        from src.data.schemas import get_schema_validator

        schema = get_schema_validator("effects.csv")
        assert "required" in schema
        assert "effect_id" in schema["required"]

    def test_get_schema_validator_skills(self):
        """Test schema detection for skills.csv."""
        from src.data.schemas import get_schema_validator

        schema = get_schema_validator("skills.csv")
        assert "required" in schema
        assert "skill_id" in schema["required"]


class TestErrorHandlingAndMessages:
    """Test detailed error handling and messages."""

    def test_parse_csv_error_details(self):
        """Test that parse_csv provides detailed error information."""
        from src.data.data_parser import parse_csv
        from src.data.schemas import ITEM_SCHEMA

        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            f.write("item_id,name,slot,rarity,num_random_affixes\n")
            f.write("test_item,Test Item,Weapon,Rare,invalid_number\n")
            temp_file = f.name

        try:
            with pytest.raises(ValueError) as exc_info:
                parse_csv(temp_file, ITEM_SCHEMA)
            error_msg = str(exc_info.value)
            assert "line 2" in error_msg  # Should mention line number
            assert "num_random_affixes" in error_msg  # Should mention column
            assert "invalid_number" in error_msg  # Should mention problematic value
        finally:
            os.unlink(temp_file)

    def test_schema_missing_column_details(self):
        """Test that missing column errors are detailed."""
        from src.data.data_parser import parse_csv
        from src.data.schemas import ITEM_SCHEMA

        # Create CSV missing a required column
        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            f.write("item_id,name,slot,num_random_affixes\n")  # Missing 'rarity'
            f.write("test_item,Test Item,Weapon,2\n")
            temp_file = f.name

        try:
            with pytest.raises(ValueError) as exc_info:
                parse_csv(temp_file, ITEM_SCHEMA)
            error_msg = str(exc_info.value)
            assert "rarity" in error_msg  # Should mention missing column
            assert "required columns" in error_msg.casefold()
        finally:
            os.unlink(temp_file)


class TestDataParserIntegration:
    """Test integration between parser and real data files."""

    def test_parse_all_csvs_file_missing_warning(self, tmp_path, caplog):
        """Test that missing files are logged as warnings and don't break parsing."""
        import logging

        # Create only effects.csv, leave others missing
        effects_csv = tmp_path / "effects.csv"
        with open(effects_csv, 'w', newline='') as f:
            import csv
            writer = csv.writer(f)
            writer.writerow(["effect_id", "name", "type", "description"])
            writer.writerow(["bleed", "Bleed", "DoT", "Damage over time"])

        with caplog.at_level(logging.WARNING):
            result = parse_all_csvs(str(tmp_path))

        # Should have warnings for missing files
        warning_messages = [record.message for record in caplog.records if record.levelname == "WARNING"]
        assert any("affixes.csv" in msg for msg in warning_messages)
        assert any("items.csv" in msg for msg in warning_messages)
        assert any("quality_tiers.csv" in msg for msg in warning_messages)
        assert any("skills.csv" in msg for msg in warning_messages)

        # Should still have effects data
        assert "effects" in result
        assert "bleed" in result["effects"]

    @pytest.mark.parametrize("data_key,expected_empty", [
        ("affixes", {}),
        ("items", {}),
        ("quality_tiers", []),
        ("effects", {}),
        ("skills", {})
    ])
    def test_parse_all_csvs_handles_missing_files(self, tmp_path, data_key, expected_empty):
        """Test that parse_all_csvs handles missing files appropriately."""
        # Create only one CSV file, others will be missing
        if data_key == "effects":
            csv_file = tmp_path / "effects.csv"
            with open(csv_file, 'w', newline='') as f:
                import csv
                writer = csv.writer(f)
                writer.writerow(["effect_id", "name", "type", "description"])
                writer.writerow(["test_effect", "Test Effect", "buff", "Test buff"])

        result = parse_all_csvs(str(tmp_path))

        # Non-created data should be empty
        assert result[data_key] == expected_empty if data_key != "effects" else {"test_effect": result[data_key]["test_effect"]}

        # The created effects data should be populated
        if data_key == "effects":
            assert len(result[data_key]) == 1
            assert result[data_key]["test_effect"]["effect_id"] == "test_effect"


class TestPerformanceAndEdgeCases:
    """Test performance and edge cases."""

    def test_parse_csv_large_file(self, tmp_path):
        """Test parsing a relatively large CSV file."""
        # Create a CSV with ~1000 rows
        large_csv = tmp_path / "large_items.csv"

        with open(large_csv, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(["item_id", "name", "slot", "rarity", "num_random_affixes"])

            for i in range(1000):
                writer.writerow([f"item_{i}", f"Item {i}", "Weapon", "Common", "1"])

        result = parse_csv(str(large_csv), ITEM_SCHEMA)
        assert len(result) == 1000
        assert result[0]["item_id"] == "item_0"
        assert result[-1]["item_id"] == "item_999"

    def test_parse_csv_unicode_support(self):
        """Test CSV parsing with Unicode characters."""
        from src.data.data_parser import parse_csv
        from src.data.schemas import AFFIX_SCHEMA

        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', encoding='utf-8', delete=False) as f:
            writer = csv.writer(f)
            writer.writerow(["affix_id", "stat_affected", "mod_type", "base_value", "description"])
            writer.writerow(["fire_sword", "damage", "flat", "45", "ðŸ”¥ ÐžÐ³Ð½ÐµÐ½Ð½Ñ‹Ð¹ ÐœÐµÑ‡ ðŸ”¥"])  # Russian + emoji
            writer.writerow(["pepe_ring", "health", "flat", "100", "ðŸ¸ Pepe Ring ðŸ¸"])  # Emoji
            temp_file = f.name

        try:
            result = parse_csv(temp_file, AFFIX_SCHEMA)
            assert len(result) == 2
            # Note: This test documents current behavior - unicode is preserved
            assert "ðŸ”¥" in result[0]["description"]
            assert "ÐžÐ³Ð½ÐµÐ½Ð½Ñ‹Ð¹" in result[0]["description"]
            assert result[1]["base_value"] == "100"
        finally:
            os.unlink(temp_file)

    def test_parse_csv_duplicate_headers_allowed(self):
        """Test behavior with duplicate column headers."""
        # This documents current behavior - last column wins
        from src.data.data_parser import parse_csv
        from src.data.schemas import AFFIX_SCHEMA

        with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
            writer = csv.writer(f)
            # Duplicate column names - should parse but with undefined behavior
            writer.writerow(["affix_id", "stat_affected", "mod_type", "base_value", "description", "description"])
            writer.writerow(["double_desc", "damage", "flat", "25", "+25 Damage", "Actually +50 Damage"])
            temp_file = f.name

        try:
            result = parse_csv(temp_file, AFFIX_SCHEMA)
            assert len(result) == 1
            # Behavior is undefined for duplicate headers, but shouldn't crash
            assert result[0]["affix_id"] == "double_desc"
            assert result[0]["base_value"] == "25"
        finally:
            os.unlink(temp_file)

# Run comprehensive validation of actual project data if available
class TestProjectDataValidation:
    """Test validation using actual project data files."""

    def test_validate_actual_project_data(self):
        """Test that actual project data validates correctly."""
        # This test is skipped in normal CI since it requires project data
        # But provides validation when running locally with full data set
        import os.path

        data_dir = os.path.join(os.path.dirname(__file__), "..", "data")

        if not os.path.exists(os.path.join(data_dir, "affixes.csv")):
            pytest.skip("Project data files not available - skipping comprehensive validation")

        # If data exists, try to parse it all
        try:
            from src.data.data_parser import parse_all_csvs
            game_data = parse_all_csvs(data_dir)

            # Basic structure validation
            assert "affixes" in game_data
            assert "items" in game_data
            assert "quality_tiers" in game_data
            assert "effects" in game_data
            assert "skills" in game_data

            # Basic data type validation
            assert isinstance(game_data["affixes"], dict)
            assert isinstance(game_data["items"], dict)
            assert isinstance(game_data["quality_tiers"], list)
            assert isinstance(game_data["effects"], dict)
            assert isinstance(game_data["skills"], dict)

            # Validate that quality tiers have valid ranges
            for tier in game_data["quality_tiers"]:
                assert tier["min_range"] < tier["max_range"], f"Invalid tier range for {tier['tier_name']}"

        except Exception as e:
            pytest.fail(f"Project data validation failed: {e}")



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_effect_handlers.py
// Size:           9.03 KB
// Last Modified:  2025-11-16T14:44:03.737Z
// =================================================================

"""Tests for effect_handlers.py - event-driven effect systems."""

import pytest
from unittest.mock import MagicMock, patch
from src.models import DamageOnHitConfig
from src.effect_handlers import DamageOnHitHandler, BleedHandler, PoisonHandler
from src.events import EventBus, OnHitEvent
from src.state import StateManager
from tests.fixtures import make_entity, make_rng


class TestDamageOnHitConfig:
    """Test the DamageOnHitConfig data structure."""

    def test_config_creation(self):
        """Test creating a DamageOnHitConfig."""
        config = DamageOnHitConfig(
            debuff_name="Burn",
            proc_rate=0.25,
            duration=6.0,
            damage_per_tick=3.0,
            stacks_to_add=1,
            display_message="Burn proc'd on {target}!"
        )

        assert config.debuff_name == "Burn"
        assert config.proc_rate == 0.25
        assert config.duration == 6.0
        assert config.damage_per_tick == 3.0
        assert config.stacks_to_add == 1
        assert config.display_message == "Burn proc'd on {target}!"

    def test_config_defaults(self):
        """Test DamageOnHitConfig default values."""
        config = DamageOnHitConfig(
            debuff_name="Frost",
            proc_rate=0.4,
            duration=10.0,
            damage_per_tick=2.0
        )

        assert config.stacks_to_add == 1  # Default value
        assert config.display_message == ""  # Default value


class TestDamageOnHitHandler:
    """Test the generic DamageOnHitHandler class."""

    def test_handler_creation(self):
        """Test creating a DamageOnHitHandler with config."""
        config = DamageOnHitConfig(
            debuff_name="Burn",
            proc_rate=0.5,
            duration=6.0,
            damage_per_tick=5.0
        )

        event_bus = MagicMock()
        state_manager = MagicMock()

        handler = DamageOnHitHandler(config, event_bus, state_manager)

        assert handler.config == config
        assert handler.event_bus == event_bus
        assert handler.state_manager == state_manager

    def test_handler_subscribes_to_on_hit(self):
        """Test that the handler subscribes to OnHitEvent."""
        config = DamageOnHitConfig(
            debuff_name="Test",
            proc_rate=1.0,  # Guarantee proc for testing
            duration=5.0,
            damage_per_tick=1.0
        )

        event_bus = MagicMock()
        state_manager = MagicMock()

        handler = DamageOnHitHandler(config, event_bus, state_manager)

        # Verify subscription was called
        event_bus.subscribe.assert_called_once()
        args = event_bus.subscribe.call_args
        assert args[0][0] == OnHitEvent  # Event type
        assert args[0][1] == handler.handle_on_hit  # Handler method

    def test_handle_on_hit_guaranteed_proc(self):
        """Test handle_on_hit with guaranteed proc."""
        config = DamageOnHitConfig(
            debuff_name="TestEffect",
            proc_rate=1.0,  # Guaranteed proc
            duration=5.0,
            damage_per_tick=1.0,
            display_message="Custom message for {target}!"
        )

        event_bus = MagicMock()
        state_manager = MagicMock()

        handler = DamageOnHitHandler(config, event_bus, state_manager, rng=make_rng(42))

        attacker = make_entity("attacker")
        defender = make_entity("defender", name="TestDefender")

        event = OnHitEvent(
            attacker=attacker,
            defender=defender,
            damage_dealt=10.0,
            is_crit=False
        )

        # Capture print output for display message
        with patch('builtins.print') as mock_print:
            handler.handle_on_hit(event)

        # Verify custom message was printed
        mock_print.assert_called_once_with("    -> Custom message for TestDefender!")

        # Verify debuff was applied to state manager
        state_manager.apply_debuff.assert_called_once_with(
            entity_id=defender.id,
            debuff_name="TestEffect",
            stacks_to_add=1,
            max_duration=5.0
        )

    def test_handle_on_hit_no_proc(self):
        """Test handle_on_hit with no proc (proc_rate = 0)."""
        config = DamageOnHitConfig(
            debuff_name="NoProcEffect",
            proc_rate=0.0,  # Never procs
            duration=5.0,
            damage_per_tick=1.0
        )

        event_bus = MagicMock()
        state_manager = MagicMock()

        handler = DamageOnHitHandler(config, event_bus, state_manager, rng=make_rng(42))

        attacker = make_entity("attacker")
        defender = make_entity("defender")

        event = OnHitEvent(
            attacker=attacker,
            defender=defender,
            damage_dealt=10.0,
            is_crit=False
        )

        handler.handle_on_hit(event)

        # Verify nothing was applied
        state_manager.apply_debuff.assert_not_called()

    def test_handle_on_hit_default_message(self):
        """Test handle_on_hit with default message when no custom message configured."""
        config = DamageOnHitConfig(
            debuff_name="DefaultEffect",
            proc_rate=1.0,
            duration=3.0,
            damage_per_tick=2.0
            # No display_message - should use default
        )

        event_bus = MagicMock()
        state_manager = MagicMock()

        handler = DamageOnHitHandler(config, event_bus, state_manager, rng=make_rng(42))

        attacker = make_entity("attacker")
        defender = make_entity("defender")

        event = OnHitEvent(
            attacker=attacker,
            defender=defender,
            damage_dealt=15.0,
            is_crit=False
        )

        # Test that proc occurred and debuff was applied (without testing print output)
        # Import capture to redirect stdout for testing
        import io
        import sys
        from contextlib import redirect_stdout

        captured_output = io.StringIO()
        with redirect_stdout(captured_output):
            handler.handle_on_hit(event)

        output = captured_output.getvalue()
        assert "DefaultEffect proc'd on defender!" in output

        # Verify debuff was applied
        state_manager.apply_debuff.assert_called_once_with(
            entity_id=defender.id,
            debuff_name="DefaultEffect",
            stacks_to_add=1,
            max_duration=3.0
        )


class TestBleedHandlerLegacy:
    """Test the legacy BleedHandler for backward compatibility."""

    def test_bleed_handler_creation(self):
        """Test creating a BleedHandler."""
        event_bus = MagicMock()
        state_manager = MagicMock()

        handler = BleedHandler(event_bus, state_manager, proc_rate=0.6, rng=make_rng(42))

        assert handler.proc_rate == 0.6
        event_bus.subscribe.assert_called_once_with(OnHitEvent, handler.handle_on_hit)

    def test_bleed_handler_proc(self):
        """Test BleedHandler applying bleed effect."""
        event_bus = MagicMock()
        state_manager = MagicMock()

        handler = BleedHandler(event_bus, state_manager, proc_rate=1.0, rng=make_rng(42))

        attacker = make_entity("attacker")
        defender = make_entity("defender")

        event = OnHitEvent(attacker=attacker, defender=defender, damage_dealt=10.0, is_crit=False)

        with patch('builtins.print') as mock_print:
            handler.handle_on_hit(event)

        mock_print.assert_called_once_with("    -> Bleed proc'd on defender!")

        state_manager.apply_debuff.assert_called_once_with(
            entity_id=defender.id,
            debuff_name="Bleed",
            stacks_to_add=1,
            max_duration=5.0
        )


class TestPoisonHandlerLegacy:
    """Test the legacy PoisonHandler for backward compatibility."""

    def test_poison_handler_creation(self):
        """Test creating a PoisonHandler."""
        event_bus = MagicMock()
        state_manager = MagicMock()

        handler = PoisonHandler(event_bus, state_manager, proc_rate=0.4, rng=make_rng(42))

        assert handler.proc_rate == 0.4
        event_bus.subscribe.assert_called_once_with(OnHitEvent, handler.handle_on_hit)

    def test_poison_handler_proc(self):
        """Test PoisonHandler applying poison effect."""
        event_bus = MagicMock()
        state_manager = MagicMock()

        handler = PoisonHandler(event_bus, state_manager, proc_rate=1.0, rng=make_rng(42))

        attacker = make_entity("attacker")
        defender = make_entity("defender")

        event = OnHitEvent(attacker=attacker, defender=defender, damage_dealt=10.0, is_crit=False)

        with patch('builtins.print') as mock_print:
            handler.handle_on_hit(event)

        mock_print.assert_called_once_with("    -> Poison proc'd on defender!")

        state_manager.apply_debuff.assert_called_once_with(
            entity_id=defender.id,
            debuff_name="Poison",
            stacks_to_add=1,
            max_duration=8.0
        )



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_engine.py
// Size:           26.01 KB
// Last Modified:  2025-11-19T10:23:30.652Z
// =================================================================

"""Unit tests for CombatEngine - core damage calculations."""

import pytest
from src.models import Entity, EntityStats, SkillUseResult, ApplyEffectAction
from src.engine import CombatEngine, HitContext
from src.state import StateManager
from tests.fixtures import make_attacker, make_defender, make_rng, make_entity
from unittest.mock import patch, MagicMock


class TestCombatEngineResolveHit:
    """Test the core resolve_hit damage calculation."""

    def test_resolve_hit_requires_state_manager(self):
        """Verify resolve_hit raises ValueError if state_manager is None."""
        engine = CombatEngine()
        
        # Use the fixtures imported at the top
        attacker = make_attacker()
        defender = make_defender()
        
        # Verify the API guard works
        with pytest.raises(ValueError, match="requires state_manager parameter"):
            engine.resolve_hit(attacker, defender, None)

    def test_no_armor(self):
        """Test damage calculation with no armor (Unit Test 3.1)."""
        # Attacker: base_damage = 100, pierce_ratio = 0.01 (default)
        attacker_stats = EntityStats(base_damage=100.0)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        # Defender: armor = 0
        defender_stats = EntityStats(armor=0.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)
        assert ctx.final_damage == 100
        assert ctx.was_crit is False  # No crit with default crit_chance

    def test_high_armor_low_pierce(self):
        """Test damage with high armor and low pierce (Unit Test 3.2)."""
        # Attacker: base_damage = 100, pierce_ratio = 0.1
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=0.1, crit_chance=0.0)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        # Defender: armor = 120 (higher than attack damage)
        defender_stats = EntityStats(armor=120.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        # PrePierceDamage = 100 - 120 = -20
        # PiercedDamage = 100 * 0.1 = 10
        # Final = max(-20, 10) = 10

        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)
        assert ctx.final_damage == 10.0

    def test_armor_greater_than_pierced_damage(self):
        """Test when armor reduction is less than pierced damage (Unit Test 3.3)."""
        # Attacker: base_damage = 100, pierce_ratio = 0.3
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=0.3, crit_chance=0.0)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        # Defender: armor = 80
        defender_stats = EntityStats(armor=80.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        # PrePierceDamage = 100 - 80 = 20
        # PiercedDamage = 100 * 0.3 = 30
        # Final = max(20, 30) = 30

        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)
        assert ctx.final_damage == 30.0

    def test_armor_less_than_pierced_damage(self):
        """Test when armor reduction is greater than pierced damage (Unit Test 3.4)."""
        # Attacker: base_damage = 100, pierce_ratio = 0.3, crit_chance=0.0
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=0.3, crit_chance=0.0)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        # Defender: armor = 60
        defender_stats = EntityStats(armor=60.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        # PrePierceDamage = 100 - 60 = 40
        # PiercedDamage = 100 * 0.3 = 30
        # Final = max(40, 30) = 40
 
        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)
        assert ctx.final_damage == 40.0

    def test_zero_damage_prevents_negative(self):
        """Test that damage calculation never returns negative values."""
        # Attacker: base_damage = 50, pierce_ratio = 0.01 (default), crit_chance=0.0
        attacker_stats = EntityStats(base_damage=50.0, crit_chance=0.0)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        # Defender: armor = 100 (much higher than attack)
        defender_stats = EntityStats(armor=100.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        # PrePierceDamage = 50 - 100 = -50
        # PiercedDamage = 50 * 0.01 = 0.5
        # Final = max(-50, 0.5) = 0.5, then max(0, 0.5) = 0.5
 
        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)
        assert ctx.final_damage == 0.5

    def test_minimum_pierce_ratio(self):
        """Test damage calculation with minimum pierce ratio."""
        # Attacker: base_damage = 100, pierce_ratio = 0.01 (minimum)
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=0.01)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        # Defender: armor = 50
        defender_stats = EntityStats(armor=50.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        # PrePierceDamage = 100 - 50 = 50
        # PiercedDamage = 100 * 0.01 = 1
        # Final = max(50, 1) = 50

        

        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)
        assert ctx.final_damage == 50.0


class TestCombatEngineCalculateEffectiveDamage:
    """Test the detailed damage breakdown calculation."""

    def test_damage_breakdown_no_armor(self):
        """Test detailed breakdown with no armor."""
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=0.2)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        defender_stats = EntityStats(armor=0.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        breakdown = CombatEngine.calculate_effective_damage(attacker, defender)

        expected = {
            'final_damage': 100.0,
            'attack_damage': 100.0,
            'pre_pierce_damage': 100.0,
            'pierced_damage': 20.0,
            'armor_reduction': 0.0,
            'pierce_ratio': 0.2
        }
        assert breakdown == expected

    def test_damage_breakdown_with_armor(self):
        """Test detailed breakdown with armor."""
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=0.3)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        defender_stats = EntityStats(armor=80.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        breakdown = CombatEngine.calculate_effective_damage(attacker, defender)

        expected = {
            'final_damage': 30.0,
            'attack_damage': 100.0,
            'pre_pierce_damage': 20.0,
            'pierced_damage': 30.0,
            'armor_reduction': 80.0,
            'pierce_ratio': 0.3
        }
        assert breakdown == expected

    def test_damage_breakdown_negative_pre_pierce(self):
        """Test detailed breakdown when pre-pierce damage is negative."""
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=0.1)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        defender_stats = EntityStats(armor=120.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        breakdown = CombatEngine.calculate_effective_damage(attacker, defender)

        expected = {
            'final_damage': 10.0,
            'attack_damage': 100.0,
            'pre_pierce_damage': -20.0,
            'pierced_damage': 10.0,
            'armor_reduction': 120.0,
            'pierce_ratio': 0.1
        }
        assert breakdown == expected


class TestCombatEngineValidateDamageCalculation:
    """Test damage calculation validation."""

    def test_valid_calculation(self):
        """Test validation of a valid damage calculation."""
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=0.2)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        defender_stats = EntityStats(armor=50.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        error = CombatEngine.validate_damage_calculation(attacker, defender)
        assert error is None

    def test_validation_pierce_ratio_above_maximum(self):
        """Test validation of pierce_ratio above maximum (1.0)."""
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=1.5)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        defender_stats = EntityStats(armor=50.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        error = CombatEngine.validate_damage_calculation(attacker, defender)
        assert error == "Attacker pierce_ratio above maximum: 1.5"

    def test_validation_pierce_ratio_at_maximum(self):
        """Test validation accepts pierce_ratio at maximum (1.0)."""
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=1.0)
        attacker = Entity(id="attacker", base_stats=attacker_stats)

        defender_stats = EntityStats(armor=50.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        error = CombatEngine.validate_damage_calculation(attacker, defender)
        assert error is None

    def test_validation_edge_cases(self):
        """Test validation of edge cases and boundary conditions."""
        # Test pierce_ratio at minimum
        attacker_stats = EntityStats(base_damage=100.0, pierce_ratio=0.01)
        attacker = Entity(id="attacker", base_stats=attacker_stats)
        defender_stats = EntityStats(armor=50.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        error = CombatEngine.validate_damage_calculation(attacker, defender)
        assert error is None

        # Test zero armor (should be valid)
        defender_stats = EntityStats(armor=0.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        error = CombatEngine.validate_damage_calculation(attacker, defender)
        assert error is None

    # Note: Additional validation tests for negative values removed since EntityStats dataclass
    # already validates these conditions at creation time, making CombatEngine
    # validation redundant for those cases.


class TestCombatEngineCriticalHits:
    """Test critical hit functionality."""

    def test_critical_hit_tier_1_common(self):
        """Test that Common rarity entities have crit tier 1 (no special crit effects)."""


        attacker_stats = EntityStats(base_damage=100.0, crit_chance=1.0, crit_damage=2.0)
        attacker = Entity(id="attacker", base_stats=attacker_stats, rarity="Common")

        defender_stats = EntityStats(armor=0.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        engine = CombatEngine(rng=make_rng(42))  # Deterministic crit
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)

        assert ctx.was_crit is True
        assert ctx.final_damage == 100  # No crit multiplier applied for tier 1
        assert attacker.get_crit_tier() == 1

    def test_critical_hit_tier_2_rare(self):
        """Test that Rare rarity entities have crit tier 2 (pre-pierce multiplier)."""


        attacker_stats = EntityStats(base_damage=100.0, crit_chance=1.0, crit_damage=2.0)
        attacker = Entity(id="attacker", base_stats=attacker_stats, rarity="Rare")

        defender_stats = EntityStats(armor=50.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        engine = CombatEngine(rng=make_rng(42))  # Deterministic crit
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)

        assert ctx.was_crit is True
        assert ctx.final_damage == 150.0  # (100 * 2.0 - 50) = 150, max(150, 100 * 0.01) = 150
        assert attacker.get_crit_tier() == 2

    def test_critical_hit_tier_3_legendary(self):
        """Test that Legendary rarity entities have crit tier 3 (post-pierce multiplier)."""


        attacker_stats = EntityStats(base_damage=100.0, crit_chance=1.0, crit_damage=2.0, pierce_ratio=0.2)
        attacker = Entity(id="attacker", base_stats=attacker_stats, rarity="Legendary")

        defender_stats = EntityStats(armor=50.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        engine = CombatEngine(rng=make_rng(42))  # Deterministic crit
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)

        assert ctx.was_crit is True
        # Tier 3: Re-calculates with crit damage applied to pierce as well
        # crit_pre_mit = 100 * 2.0 = 200
        # pre_pierce = 200 - 50 = 150
        # pierced = 200 * 0.2 = 40
        # final = max(150, 40) = 150
        assert ctx.final_damage == 150.0
        assert attacker.get_crit_tier() == 3

    def test_no_critical_hit_when_chance_zero(self):
        """Test that no crit occurs when crit_chance is 0."""


        attacker_stats = EntityStats(base_damage=100.0, crit_chance=0.0, crit_damage=2.0)
        attacker = Entity(id="attacker", base_stats=attacker_stats, rarity="Legendary")

        defender_stats = EntityStats(armor=0.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)

        assert ctx.was_crit is False
        assert ctx.final_damage == 100.0


class TestHitContext:
    """Test the HitContext data structure."""

    def test_hit_context_creation(self):
        """Test HitContext can be created with required fields."""
        attacker_stats = EntityStats()
        defender_stats = EntityStats()
        attacker = Entity("attacker", base_stats=attacker_stats)
        defender = Entity("defender", base_stats=defender_stats)

        ctx = HitContext(
            attacker=attacker,
            defender=defender,
            base_raw=100.0,
            base_resolved=100,
            final_damage=0
        )

        assert ctx.attacker == attacker
        assert ctx.defender == defender
        assert ctx.base_resolved == 100
        assert ctx.damage_pre_mitigation == 0.0
        assert ctx.damage_post_armor == 0.0
        assert ctx.final_damage == 0
        assert ctx.was_crit is False

    def test_final_damage_always_assigned(self):
        """Test that ctx.final_damage is always assigned in all code paths."""


        attacker_stats = EntityStats(base_damage=100.0, crit_chance=1.0, crit_damage=2.0)
        defender_stats = EntityStats(armor=50.0)

        # Test all rarity tiers with guaranteed crits
        for rarity in ["Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic"]:
            attacker = Entity(id="attacker", base_stats=attacker_stats, rarity=rarity)
            defender = Entity(id="defender", base_stats=defender_stats)

            engine = CombatEngine(rng=make_rng(42))  # Deterministic crit
            state_manager = StateManager()
            state_manager.add_entity(attacker)
            state_manager.add_entity(defender)
            ctx = engine.resolve_hit(attacker, defender, state_manager)

            # final_damage should always be set and non-negative
            assert ctx.final_damage is not None
            assert ctx.final_damage >= 0.0
            assert isinstance(ctx.final_damage, float)

    def test_tier_3_post_pierce_crit_recalculation(self):
        """Test that Tier 3 crits properly recalculate damage with pierce."""


        # Legendary = Tier 3 crit
        attacker_stats = EntityStats(
            base_damage=100.0,
            crit_chance=1.0,
            crit_damage=2.0,
            pierce_ratio=0.2
        )
        attacker = Entity(id="attacker", base_stats=attacker_stats, rarity="Legendary")

        defender_stats = EntityStats(armor=50.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        engine = CombatEngine(rng=make_rng(42))  # Deterministic crit
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)

        assert ctx.was_crit is True
        assert attacker.get_crit_tier() == 3

        # Tier 3 calculation:
        # crit_pre_mit = 100 * 2.0 = 200
        # pre_pierce = 200 - 50 = 150
        # pierced = 200 * 0.2 = 40
        # final = max(150, 40) = 150
        assert ctx.final_damage == 150.0

    def test_non_crit_damage_assignment(self):
        """Test that non-crit hits properly assign mitigated_damage to final_damage."""


        attacker_stats = EntityStats(base_damage=100.0, crit_chance=0.0)  # No crit chance
        attacker = Entity(id="attacker", base_stats=attacker_stats, rarity="Common")

        defender_stats = EntityStats(armor=30.0)
        defender = Entity(id="defender", base_stats=defender_stats)

        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        ctx = engine.resolve_hit(attacker, defender, state_manager)

        assert ctx.was_crit is False
        # Should be: max(100-30, 100*0.01) = max(70, 1) = 70
        assert ctx.final_damage == 70.0


class TestCombatEngineCalculateSkillUse:
    """Test the new calculate_skill_use method that returns SkillUseResult."""

    def test_calculate_skill_use_basic_skill(self):
        """Test calculate_skill_use with a basic single-hit skill."""



        attacker = make_entity("attacker")
        defender = make_entity("defender")

        # Create a simple skill with 1 hit and no triggers
        skill = type('Skill', (), {
            'hits': 1,
            'name': 'basic_attack',
            'triggers': []
        })()

        engine = CombatEngine(rng=make_rng(42))  # Deterministic for testing
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        result = engine.calculate_skill_use(attacker, defender, skill, state_manager)

        # Should return a SkillUseResult with 1 hit and actions (damage + events)
        assert isinstance(result, SkillUseResult)
        assert len(result.hit_results) == 1

        # Actions: At least ApplyDamageAction + DispatchEventAction (OnHitEvent)
        # May include additional events like OnCritEvent if crit occurs (depends on RNG)
        assert len(result.actions) >= 2

        # First action should be damage application
        from src.models import ApplyDamageAction, DispatchEventAction
        damage_action = result.actions[0]
        assert isinstance(damage_action, ApplyDamageAction)
        assert damage_action.target_id == defender.id
        assert damage_action.damage == 50.0  # Default base_damage from fixtures
        assert damage_action.source == "basic_attack"

        # Later actions should include event dispatching
        event_actions = [action for action in result.actions if isinstance(action, DispatchEventAction)]
        assert len(event_actions) >= 1

        # At least one event action should have OnHit attributes
        hit_events = event_actions
        assert len(hit_events) >= 1
        # Note: exact event types depend on crit outcome, so we just verify basic properties

    def test_calculate_skill_use_multi_hit_skill(self):
        """Test calculate_skill_use with a multi-hit skill."""
  
        attacker = make_entity("attacker")
        defender = make_entity("defender")

        # Create a skill with 3 hits
        skill = type('Skill', (), {
            'hits': 3,
            'name': 'triple_slash',
            'triggers': []
        })()

        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        result = engine.calculate_skill_use(attacker, defender, skill, state_manager)

        assert len(result.hit_results) == 3
        # Each hit: 1 damage action + 1-2 event actions = 6-9 total actions
        assert len(result.actions) >= 6  # Minimum without crits

        # Verify hit contexts
        for hit_ctx in result.hit_results:
            assert hit_ctx.attacker == attacker
            assert hit_ctx.defender == defender
            assert hit_ctx.attacker.base_stats.base_damage == 100.0  # Default base_damage from fixtures

    def test_calculate_skill_use_with_crit(self):
        """Test calculate_skill_use with guaranteed critical hit."""
 
        # Create attacker with guaranteed crit (Rare for tier 2 crits)
        attacker = make_entity("attacker", base_damage=50.0, crit_chance=1.0, crit_damage=2.0, rarity="Rare")
        defender = make_entity("defender")

        skill = type('Skill', (), {
            'hits': 1,
            'name': 'crit_attack',
            'triggers': []
        })()

        engine = CombatEngine(rng=make_rng(42))  # Deterministic crit
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        result = engine.calculate_skill_use(attacker, defender, skill, state_manager)

        assert len(result.hit_results) == 1
        hit_ctx = result.hit_results[0]
        assert hit_ctx.was_crit is True
        # Rare = tier 2 crit: pre-pierce multiplier
        # Base damage: 50 * crit(2.0) = 100, minus defender armor(50) = 50, max with pierced(1)
        assert hit_ctx.final_damage == 50.0

        # Actions: 1 damage + 2 events (OnHit + OnCrit)
        assert len(result.actions) == 3

    def test_calculate_skill_use_with_trigger(self):
        """Test calculate_skill_use with a skill trigger."""
       
        

        attacker = make_entity("attacker")
        defender = make_entity("defender")

        # Create a skill with 1 hit and 1 trigger (OnHit apply bleed)
        # The engine expects triggers to be objects with attributes, not dicts
        trigger_obj = type('Trigger', (), {
            'event': 'OnHit',
            'check': {'proc_rate': 1.0},  # Guaranteed to trigger for testing
            'result': {'apply_debuff': 'bleed', 'stacks': 2}  # This matches what engine expects
        })()

        skill = type('Skill', (), {
            'hits': 1,
            'name': 'bleed_attack',
            'triggers': [trigger_obj]
        })()

        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        result = engine.calculate_skill_use(attacker, defender, skill, state_manager)

        assert len(result.hit_results) == 1
        # Actions: 1 damage + event actions + 1 ApplyEffect (may include OnCrit if crit occurs)
        assert len(result.actions) >= 3  # Minimum expected actions

        # Find the effect action (last one should be ApplyEffectAction)
        effect_actions = [action for action in result.actions if isinstance(action, ApplyEffectAction)]
        assert len(effect_actions) == 1
        effect_action = effect_actions[0]
        assert effect_action.target_id == defender.id
        assert effect_action.effect_name == "bleed"
        assert effect_action.stacks_to_add == 2
        assert effect_action.source == "bleed_attack_trigger"

    def test_calculate_skill_use_detached_from_execution(self):
        """Test that calculate_skill_use performs no side effects."""



        attacker = make_entity("attacker")
        defender = make_entity("defender")

        skill = type('Skill', (), {
            'hits': 1,
            'name': 'test_skill',
            'triggers': []
        })()

        engine = CombatEngine(rng=make_rng(42))
        state_manager = StateManager()
        state_manager.add_entity(attacker)
        state_manager.add_entity(defender)
        attacker_initial_hp = state_manager.get_current_health(attacker.id)
        defender_initial_hp = state_manager.get_current_health(defender.id)

        result = engine.calculate_skill_use(attacker, defender, skill, state_manager)

        # Verify that calculate_skill_use produced a valid result
        assert isinstance(result, SkillUseResult)
        assert len(result.hit_results) == 1
        assert len(result.actions) >= 2  # At least damage and event actions

        # Verify that no side effects occurred - entities' health should be unchanged
        assert state_manager.get_current_health(attacker.id) == attacker_initial_hp
        assert state_manager.get_current_health(defender.id) == defender_initial_hp



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_events.py
// Size:           5.43 KB
// Last Modified:  2025-11-16T14:48:14.166Z
// =================================================================

"""Unit tests for the event system."""

import pytest
from src.events import Event, OnHitEvent, OnCritEvent, EventBus
from src.models import Entity, EntityStats


class TestEventClasses:
    """Test the event data classes."""

    def test_on_hit_event_creation(self):
        """Test OnHitEvent can be created with required fields."""
        attacker_stats = EntityStats()
        defender_stats = EntityStats()
        attacker = Entity("attacker", attacker_stats)
        defender = Entity("defender", defender_stats)

        event = OnHitEvent(
            attacker=attacker,
            defender=defender,
            damage_dealt=50.0,
            is_crit=False
        )

        assert event.attacker == attacker
        assert event.defender == defender
        assert event.damage_dealt == 50.0
        assert event.is_crit is False

    def test_on_crit_event_creation(self):
        """Test OnCritEvent can be created with OnHitEvent."""
        attacker_stats = EntityStats()
        defender_stats = EntityStats()
        attacker = Entity("attacker", attacker_stats)
        defender = Entity("defender", defender_stats)

        hit_event = OnHitEvent(
            attacker=attacker,
            defender=defender,
            damage_dealt=75.0,
            is_crit=True
        )

        crit_event = OnCritEvent(hit_event=hit_event)

        assert crit_event.hit_event == hit_event
        assert crit_event.hit_event.is_crit is True


class TestEventBus:
    """Test the EventBus functionality."""

    def test_event_bus_initialization(self):
        """Test EventBus initializes with empty listeners."""
        bus = EventBus()
        assert len(bus.listeners) == 0

    def test_subscribe_adds_listener(self):
        """Test that subscribe adds a listener for an event type."""
        bus = EventBus()
        mock_listener = lambda event: None

        bus.subscribe(OnHitEvent, mock_listener)

        assert OnHitEvent in bus.listeners
        # With PR3, listeners are now ListenerEntry objects
        listener_entries = bus.listeners[OnHitEvent]
        assert len(listener_entries) == 1
        assert listener_entries[0].listener == mock_listener

    def test_dispatch_calls_listener(self):
        """Test that dispatch calls the subscribed listener with the event."""
        bus = EventBus()
        events_received = []

        def mock_listener(event):
            events_received.append(event)

        bus.subscribe(OnHitEvent, mock_listener)

        attacker_stats = EntityStats()
        defender_stats = EntityStats()
        attacker = Entity("attacker", attacker_stats)
        defender = Entity("defender", defender_stats)

        event = OnHitEvent(
            attacker=attacker,
            defender=defender,
            damage_dealt=25.0
        )

        bus.dispatch(event)

        assert len(events_received) == 1
        assert events_received[0] == event

    def test_dispatch_does_not_call_wrong_event_type(self):
        """Test that listeners only receive events of their subscribed type."""
        bus = EventBus()
        hit_events_received = []
        crit_events_received = []

        def hit_listener(event):
            hit_events_received.append(event)

        def crit_listener(event):
            crit_events_received.append(event)

        bus.subscribe(OnHitEvent, hit_listener)
        bus.subscribe(OnCritEvent, crit_listener)

        attacker_stats = EntityStats()
        defender_stats = EntityStats()
        attacker = Entity("attacker", attacker_stats)
        defender = Entity("defender", defender_stats)

        hit_event = OnHitEvent(
            attacker=attacker,
            defender=defender,
            damage_dealt=25.0
        )

        bus.dispatch(hit_event)

        assert len(hit_events_received) == 1
        assert len(crit_events_received) == 0

    def test_multiple_listeners_same_event(self):
        """Test that multiple listeners for the same event type all get called."""
        bus = EventBus()
        listener1_calls = []
        listener2_calls = []

        def listener1(event):
            listener1_calls.append(event)

        def listener2(event):
            listener2_calls.append(event)

        bus.subscribe(OnHitEvent, listener1)
        bus.subscribe(OnHitEvent, listener2)

        attacker_stats = EntityStats()
        defender_stats = EntityStats()
        attacker = Entity("attacker", attacker_stats)
        defender = Entity("defender", defender_stats)

        event = OnHitEvent(
            attacker=attacker,
            defender=defender,
            damage_dealt=30.0
        )

        bus.dispatch(event)

        assert len(listener1_calls) == 1
        assert len(listener2_calls) == 1
        assert listener1_calls[0] == event
        assert listener2_calls[0] == event

    def test_dispatch_with_no_listeners(self):
        """Test that dispatching an event with no listeners doesn't cause errors."""
        bus = EventBus()

        attacker_stats = EntityStats()
        defender_stats = EntityStats()
        attacker = Entity("attacker", attacker_stats)
        defender = Entity("defender", defender_stats)

        event = OnHitEvent(
            attacker=attacker,
            defender=defender,
            damage_dealt=20.0
        )

        # Should not raise any exceptions
        bus.dispatch(event)



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_event_bus_pr3.py
// Size:           21.19 KB
// Last Modified:  2025-11-16T14:35:23.839Z
// =================================================================

"""Production-grade EventBus tests for PR3 enhancements.

Tests the production-ready features added in PR3:
- Exception isolation and safe dispatch
- Unsubscribe support
- Safe iteration with concurrent modifications
- Listener priorities
- Event profiling and monitoring
- Comprehensive edge cases and error handling
"""

import logging
import pytest
from unittest.mock import MagicMock
from src.events import EventBus, OnHitEvent, Event


class TestEvent(Event):
    """Simple test event for testing."""
    pass


class TestEventTwo(Event):
    """Second test event type."""
    pass


def create_mock_entity(name="test"):
    """Create a minimal mock entity for testing."""
    entity = MagicMock()
    entity.id = name
    entity.name = name
    return entity


class TestEventBusExceptionIsolation:
    """Test that exceptions in listeners don't break other listeners."""

    def test_dispatch_isolated_from_listener_errors(self, caplog):
        """Test that failing listeners don't break dispatch to good ones."""
        caplog.set_level(logging.ERROR)
        bus = EventBus()

        calls = []

        def bad_listener(event):
            calls.append("bad_start")
            raise RuntimeError("boom")
            calls.append("bad_end")  # This should not execute

        def good_listener(event):
            calls.append("good")

        bus.subscribe(TestEvent, bad_listener)
        bus.subscribe(TestEvent, good_listener)

        bus.dispatch(TestEvent())

        # First listener started but failed, second listener executed
        assert calls == ["bad_start", "good"]
        # Error was logged
        assert "boom" in caplog.text
        assert "bad_listener" in caplog.text
        assert "TestEvent" in caplog.text

    def test_multiple_listeners_with_mixed_failures(self, caplog):
        """Test multiple listeners where some fail and some succeed."""
        caplog.set_level(logging.ERROR)
        bus = EventBus()

        calls = []

        def listener1(event):
            calls.append("listener1")
            raise ValueError("error1")

        def listener2(event):
            calls.append("listener2")

        def listener3(event):
            calls.append("listener3")
            raise RuntimeError("error3")

        def listener4(event):
            calls.append("listener4")

        bus.subscribe(TestEvent, listener1)
        bus.subscribe(TestEvent, listener2)
        bus.subscribe(TestEvent, listener3)
        bus.subscribe(TestEvent, listener4)

        bus.dispatch(TestEvent())

        # All listeners started executing in order
        assert calls == ["listener1", "listener2", "listener3", "listener4"]
        # Both errors were logged
        assert "error1" in caplog.text
        assert "error3" in caplog.text
        assert caplog.text.count("ERROR") == 2


class TestEventBusUnsubscribe:
    """Test unsubscribe functionality."""

    def test_unsubscribe_removes_listener(self):
        """Test basic unsubscribe removes listener correctly."""
        bus = EventBus()
        calls = []

        def f(event): calls.append(1)

        bus.subscribe(TestEvent, f)
        result = bus.unsubscribe(TestEvent, f)
        bus.dispatch(TestEvent())

        assert result is True
        assert calls == []

    def test_unsubscribe_returns_false_for_nonexistent_listener(self):
        """Test unsubscribe returns False for listener not found."""
        bus = EventBus()

        def f(event): pass

        result = bus.unsubscribe(TestEvent, f)
        assert result is False

    def test_unsubscribe_removes_correct_listener(self):
        """Test unsubscribe only removes specific listener, not others."""
        bus = EventBus()
        calls = []

        def listener1(event): calls.append("listener1")
        def listener2(event): calls.append("listener2")
        def listener3(event): calls.append("listener3")

        bus.subscribe(TestEvent, listener1)
        bus.subscribe(TestEvent, listener2)
        bus.subscribe(TestEvent, listener3)

        bus.unsubscribe(TestEvent, listener2)

        bus.dispatch(TestEvent())

        assert calls == ["listener1", "listener3"]

    def test_unsubscribe_different_event_types(self):
        """Test unsubscribe only affects specific event type."""
        bus = EventBus()
        calls = []

        def f(event): calls.append(event.__class__.__name__)

        bus.subscribe(TestEvent, f)
        bus.subscribe(TestEventTwo, f)

        bus.unsubscribe(TestEvent, f)

        bus.dispatch(TestEvent())
        bus.dispatch(TestEventTwo())

        assert calls == ["TestEventTwo"]


class TestEventBusSafeIteration:
    """Test safe iteration and concurrent modification handling."""

    def test_subscribe_during_dispatch_safe(self):
        """Test subscribing during dispatch doesn't affect current iteration."""
        bus = EventBus()
        calls = []

        def listener_a(event):
            calls.append("A")
            # Subscribe a new listener during dispatch
            bus.subscribe(TestEvent, listener_b)

        def listener_b(event):
            calls.append("B")

        bus.subscribe(TestEvent, listener_a)
        bus.dispatch(TestEvent())

        # Only A executes in this dispatch cycle
        assert calls == ["A"]

        # B should execute in subsequent dispatches
        bus.dispatch(TestEvent())
        assert calls == ["A", "A", "B"]

    def test_unsubscribe_during_dispatch_safe(self):
        """Test unsubscribing during dispatch doesn't break iteration."""
        bus = EventBus()
        calls = []

        def listener_a(event):
            calls.append("A")
            # Unsubscribe self during dispatch (should not affect current dispatch)
            bus.unsubscribe(TestEvent, listener_a)

        def listener_b(event):
            calls.append("B")

        bus.subscribe(TestEvent, listener_a)
        bus.subscribe(TestEvent, listener_b)

        bus.dispatch(TestEvent())
        # Both should execute in first dispatch (safe copy used)
        assert calls == ["A", "B"]

        # Second dispatch only B should execute
        bus.dispatch(TestEvent())
        assert calls == ["A", "B", "B"]

    def test_multiple_subscribe_unsubscribe_during_dispatch(self):
        """Test complex subscribe/unsubscribe operations during dispatch."""
        bus = EventBus()
        calls = []

        def a(event):
            calls.append("A")
            bus.unsubscribe(TestEvent, c)
            bus.subscribe(TestEvent, d)

        def b(event):
            calls.append("B")

        def c(event):
            calls.append("C")

        def d(event):
            calls.append("D")

        bus.subscribe(TestEvent, a)
        bus.subscribe(TestEvent, b)
        bus.subscribe(TestEvent, c)

        # First dispatch: A, B, C execute (safe copy)
        # During A's execution: C is unsubscribed, D is subscribed
        bus.dispatch(TestEvent())
        assert calls == ["A", "B", "C"]

        # Second dispatch: A, B, D execute (D was added, C was removed)
        bus.dispatch(TestEvent())
        assert calls == ["A", "B", "C", "A", "B", "D"]


class TestEventBusListenerPriorities:
    """Test listener priority system."""

    def test_priority_ordering(self):
        """Test listeners execute in priority order (highest first)."""
        bus = EventBus()
        calls = []

        def low_priority(event): calls.append("low")
        def med_priority(event): calls.append("med")
        def high_priority(event): calls.append("high")

        bus.subscribe(TestEvent, low_priority, priority=0)  # Default priority
        bus.subscribe(TestEvent, med_priority, priority=5)
        bus.subscribe(TestEvent, high_priority, priority=10)

        bus.dispatch(TestEvent())

        assert calls == ["high", "med", "low"]

    def test_priority_negative_values(self):
        """Test negative priority values work correctly."""
        bus = EventBus()
        calls = []

        def p_neg1(event): calls.append("-1")
        def p_zero(event): calls.append("0")
        def p_pos1(event): calls.append("1")

        bus.subscribe(TestEvent, p_neg1, priority=-1)
        bus.subscribe(TestEvent, p_zero, priority=0)
        bus.subscribe(TestEvent, p_pos1, priority=1)

        bus.dispatch(TestEvent())

        assert calls == ["1", "0", "-1"]

    def test_priority_sorting_after_subscribe(self):
        """Test that priority sorting works when subscribing in wrong order."""
        bus = EventBus()
        calls = []

        def first(event): calls.append("first")
        def second(event): calls.append("second")
        def third(event): calls.append("third")

        # Subscribe in "wrong" order
        bus.subscribe(TestEvent, first, priority=1)
        bus.subscribe(TestEvent, second, priority=5)
        bus.subscribe(TestEvent, third, priority=10)

        # Should still execute in correct priority order
        bus.dispatch(TestEvent())

        assert calls == ["third", "second", "first"]

    def test_unsubscribe_preserves_priority_ordering(self):
        """Test that unsubscribing maintains priority ordering for remaining listeners."""
        bus = EventBus()
        calls = []

        def low(event): calls.append("low")
        def med(event): calls.append("med")
        def high(event): calls.append("high")

        bus.subscribe(TestEvent, low, priority=1)
        bus.subscribe(TestEvent, med, priority=5)
        bus.subscribe(TestEvent, high, priority=10)

        # Remove medium priority
        bus.unsubscribe(TestEvent, med)

        bus.dispatch(TestEvent())

        assert calls == ["high", "low"]


class TestEventBusProfiling:
    """Test event dispatch profiling and monitoring features."""

    def test_profiling_disabled_by_default(self):
        """Test profiling is disabled by default and doesn't collect data."""
        bus = EventBus()

        def listener(event): pass

        bus.subscribe(TestEvent, listener)
        bus.dispatch(TestEvent())

        stats = bus.get_profiling_stats()

        # Stats should be mostly empty since profiling is disabled
        assert stats == {'_failures': {}, '_total_events_dispatched': 0}

    def test_profiling_enabled_collects_basic_stats(self):
        """Test enabling profiling collects dispatch counts."""
        bus = EventBus()
        bus.enable_profiling(True)

        def listener(event): pass

        bus.subscribe(TestEvent, listener)
        bus.dispatch(TestEvent())
        bus.dispatch(TestEvent())

        stats = bus.get_profiling_stats()

        event_stats = stats.get('TestEvent')
        assert event_stats is not None
        assert event_stats['total_dispatches'] == 2
        assert event_stats['listeners_count'] == 1
        assert isinstance(event_stats['avg_dispatch_time_ms'], float)
        assert isinstance(event_stats['max_dispatch_time_ms'], float)
        assert stats['_total_events_dispatched'] == 2

    def test_profiling_collects_failure_stats(self):
        """Test profiling collects failure counts."""
        bus = EventBus()
        bus.enable_profiling(True)

        def good_listener(event): pass
        def bad_listener(event): raise RuntimeError("test")

        bus.subscribe(TestEvent, good_listener)
        bus.subscribe(TestEvent, bad_listener)
        bus.subscribe(TestEventTwo, bad_listener)

        bus.dispatch(TestEvent())
        bus.dispatch(TestEvent())
        bus.dispatch(TestEventTwo())

        stats = bus.get_profiling_stats()

        # Should have failure count for bad_listener
        failures = stats.get('_failures', {})
        bad_listener_name = bad_listener.__name__ if hasattr(bad_listener, '__name__') else str(bad_listener)
        assert failures[bad_listener_name] == 3  # Failed on 2 TestEvent + 1 TestEventTwo

        # Should have dispatch stats for both event types
        assert 'TestEvent' in stats
        assert 'TestEventTwo' in stats
        assert stats['TestEvent']['total_dispatches'] == 2
        assert stats['TestEventTwo']['total_dispatches'] == 1

    def test_profiling_reset_clears_data(self):
        """Test profiling reset clears all metrics."""
        bus = EventBus()
        bus.enable_profiling(True)

        def listener(event): pass

        bus.subscribe(TestEvent, listener)
        bus.dispatch(TestEvent())

        # Stats should exist
        stats_before = bus.get_profiling_stats()
        assert stats_before['_total_events_dispatched'] == 1

        # Reset and check stats are cleared
        bus.reset_profiling()
        stats_after = bus.get_profiling_stats()
        assert stats_after == {'_failures': {}, '_total_events_dispatched': 0}

    def test_enable_disable_profiling(self):
        """Test enabling/disabling profiling works correctly."""
        bus = EventBus()

        def listener(event): pass

        bus.subscribe(TestEvent, listener)

        # Disabled by default
        bus.dispatch(TestEvent())
        stats_disabled = bus.get_profiling_stats()
        assert stats_disabled['_total_events_dispatched'] == 0

        # Enable profiling
        bus.enable_profiling(True)
        bus.dispatch(TestEvent())
        stats_enabled = bus.get_profiling_stats()
        assert stats_enabled['_total_events_dispatched'] == 1

        # Disable profiling (should stop collecting new data)
        bus.enable_profiling(False)
        bus.dispatch(TestEvent())
        stats_disabled_again = bus.get_profiling_stats()
        # Should still have the previous dispatch count
        assert stats_disabled_again['_total_events_dispatched'] == 1

        # Re-enable should work
        bus.enable_profiling(True)
        bus.dispatch(TestEvent())
        final_stats = bus.get_profiling_stats()
        assert final_stats['_total_events_dispatched'] == 2


class TestEventBusUtilityMethods:
    """Test utility and management methods."""

    def test_get_listener_count(self):
        """Test listener count methods."""
        bus = EventBus()

        def listener1(event): pass
        def listener2(event): pass
        def listener3(event): pass

        # Empty bus
        assert bus.get_listener_count() == 0
        assert bus.get_listener_count(TestEvent) == 0

        # Add listeners
        bus.subscribe(TestEvent, listener1)
        bus.subscribe(TestEvent, listener2)
        bus.subscribe(TestEventTwo, listener3)

        assert bus.get_listener_count() == 3
        assert bus.get_listener_count(TestEvent) == 2
        assert bus.get_listener_count(TestEventTwo) == 1

        # Remove one
        bus.unsubscribe(TestEvent, listener1)

        assert bus.get_listener_count() == 2
        assert bus.get_listener_count(TestEvent) == 1

    def test_clear_all_listeners(self):
        """Test clearing all listeners."""
        bus = EventBus()

        def listener1(event): pass
        def listener2(event): pass

        bus.subscribe(TestEvent, listener1, priority=5, name="test1")
        bus.subscribe(TestEvent, listener2, priority=10, name="test2")
        bus.enable_profiling(True)
        bus.dispatch(TestEvent())  # Generate some profiling data

        # Verify listeners exist and profiling data exists
        initial_count = bus.get_listener_count()
        initial_stats = bus.get_profiling_stats()

        assert initial_count == 2
        assert initial_stats['_total_events_dispatched'] == 1

        # Clear everything
        bus.clear()

        # Verify everything is cleared
        assert bus.get_listener_count() == 0
        cleared_stats = bus.get_profiling_stats()
        assert cleared_stats == {'_failures': {}, '_total_events_dispatched': 0}

    def test_multiple_event_types_independence(self):
        """Test that operations on one event type don't affect others."""
        bus = EventBus()

        def test_event1_listener(event): pass
        def test_event2_listener(event): pass

        bus.subscribe(TestEvent, test_event1_listener)
        bus.subscribe(TestEventTwo, test_event2_listener)

        # Unsubscribe from wrong event type
        result = bus.unsubscribe(TestEvent, test_event2_listener)
        assert result is False
        assert bus.get_listener_count(TestEvent) == 1
        assert bus.get_listener_count(TestEventTwo) == 1

        # Correct unsubscribe
        result = bus.unsubscribe(TestEventTwo, test_event2_listener)
        assert result is True
        assert bus.get_listener_count(TestEvent) == 1
        assert bus.get_listener_count(TestEventTwo) == 0


class TestEventBusEdgeCases:
    """Test edge cases and complex scenarios."""

    def test_subscribe_with_names(self):
        """Test listener names for better debugging."""
        bus = EventBus()

        def listener(event): pass

        bus.subscribe(TestEvent, listener, name="my_special_listener")

        # Check that the listener entry has the correct name
        event_listeners = bus.listeners[TestEvent]
        assert len(event_listeners) == 1
        assert event_listeners[0].name == "my_special_listener"

    def test_exception_in_exception_handler_does_not_crash(self):
        """Test that even if exception logging fails, dispatch continues."""
        bus = EventBus()

        # Patch logger.exception to fail
        original_exception = logging.Logger.exception
        logging.Logger.exception = MagicMock(side_effect=Exception("Logger failed"))

        calls = []

        def bad_listener(event):
            raise RuntimeError("Listener error")

        def good_listener(event):
            calls.append("good")

        bus.subscribe(TestEvent, bad_listener)
        bus.subscribe(TestEvent, good_listener)

        # This should not raise - even though logger.exception fails,
        # the dispatch should continue to good listeners
        bus.dispatch(TestEvent())

        assert calls == ["good"]

        # Restore logger
        logging.Logger.exception = original_exception

    def test_performance_with_many_listeners(self):
        """Basic performance test with many listeners."""
        bus = EventBus()

        listeners = []

        # Create 100 listeners
        for i in range(100):
            def make_listener(idx):
                def listener(event):
                    pass
                return listener
            listeners.append(make_listener(i))

        # Subscribe all
        for idx, listener in enumerate(listeners):
            bus.subscribe(TestEvent, listener, priority=idx, name=f"listener_{idx}")

        # Dispatch should handle all listeners
        bus.dispatch(TestEvent())

        assert bus.get_listener_count(TestEvent) == 100

    def test_complex_priority_and_error_scenario(self):
        """Test complex scenario with priorities and mixed failures."""
        bus = EventBus()
        bus.enable_profiling(True)
        calls = []

        def high_fail(event):
            calls.append("high_failed")
            raise RuntimeError("High priority failure")

        def med_success(event):
            calls.append("med_success")

        def low_fail(event):
            calls.append("low_failed")
            raise ValueError("Low priority failure")

        def low_success(event):
            calls.append("low_success")

        # Subscribe with various priorities and reliability
        bus.subscribe(TestEvent, high_fail, priority=10, name="high_fail")
        bus.subscribe(TestEvent, med_success, priority=5, name="med_success")
        bus.subscribe(TestEvent, low_fail, priority=0, name="low_fail")
        bus.subscribe(TestEvent, low_success, priority=0, name="low_success")

        # Dispatch should execute in priority order and continue despite failures
        bus.dispatch(TestEvent())

        # Priority order: high fail, med success, then low priority group
        # Within same priority (0), order of subscription
        assert calls == ["high_failed", "med_success", "low_failed", "low_success"]

        # Profiling should track failures
        stats = bus.get_profiling_stats()
        failures = stats['_failures']

        # Both failing listeners should be tracked
        assert failures['high_fail'] == 1
        assert failures['low_fail'] == 1


class TestBackwardsCompatibility:
    """Test that existing EventBus API still works."""

    def test_old_api_still_works(self):
        """Test the old subscribe() API (without priority/name) still works."""
        bus = EventBus()
        calls = []

        def listener1(event): calls.append("listener1")
        def listener2(event): calls.append("listener2")

        # Old API without priority/name
        bus.subscribe(TestEvent, listener1)
        bus.subscribe(TestEvent, listener2)

        bus.dispatch(TestEvent())

        # Both listeners called (priority defaults to 0, so subscription order)
        assert calls == ["listener1", "listener2"]

        # Unsubscribe still works
        bus.unsubscribe(TestEvent, listener1)
        calls.clear()
        bus.dispatch(TestEvent())

        assert calls == ["listener2"]



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_fixtures.py
// Size:           3.85 KB
// Last Modified:  2025-11-11T12:44:17.539Z
// =================================================================

"""Unit tests for test fixtures and helper functions."""

import random
from tests.fixtures import make_rng, make_entity, make_attacker, make_defender, make_glass_cannon_attacker, make_tank_defender


class TestFixtures:
    """Test the fixture helper functions."""

    def test_make_rng_deterministic(self):
        """Test that make_rng produces deterministic results."""
        rng1 = make_rng(42)
        rng2 = make_rng(42)

        # Both RNGs should produce the same sequence
        assert rng1.random() == rng2.random()
        assert rng1.random() == rng2.random()
        assert rng1.randint(1, 100) == rng2.randint(1, 100)

    def test_make_rng_different_seeds(self):
        """Test that different seeds produce different results."""
        rng1 = make_rng(42)
        rng2 = make_rng(123)

        # Different seeds should produce different results
        assert rng1.random() != rng2.random()

    def test_make_entity_basic(self):
        """Test basic entity creation with make_entity."""
        entity = make_entity("test_entity")

        assert entity.id == "test_entity"
        assert entity.name == "test_entity"
        assert entity.base_stats.base_damage == 100.0
        assert entity.base_stats.armor == 50.0
        assert entity.base_stats.crit_chance == 0.1
        assert entity.rarity == "Common"

    def test_make_entity_custom_values(self):
        """Test entity creation with custom values."""
        entity = make_entity(
            "custom_entity",
            name="Custom Name",
            base_damage=200.0,
            armor=75.0,
            rarity="Rare"
        )

        assert entity.id == "custom_entity"
        assert entity.name == "Custom Name"
        assert entity.base_stats.base_damage == 200.0
        assert entity.base_stats.armor == 75.0
        assert entity.rarity == "Rare"

    def test_make_attacker(self):
        """Test attacker creation with make_attacker."""
        attacker = make_attacker(base_damage=150.0, crit_chance=0.25)

        assert attacker.id == "attacker"
        assert attacker.name == "Test Attacker"
        assert attacker.base_stats.base_damage == 150.0
        assert attacker.base_stats.armor == 10.0  # Low armor for attackers
        assert attacker.base_stats.crit_chance == 0.25
        assert attacker.base_stats.max_health == 800.0

    def test_make_defender(self):
        """Test defender creation with make_defender."""
        defender = make_defender(armor=80.0, max_health=1200.0)

        assert defender.id == "defender"
        assert defender.name == "Test Defender"
        assert defender.base_stats.base_damage == 50.0  # Low damage for defenders
        assert defender.base_stats.armor == 80.0
        assert defender.base_stats.max_health == 1200.0

    def test_make_glass_cannon_attacker(self):
        """Test glass cannon attacker creation."""
        attacker = make_glass_cannon_attacker()

        assert attacker.id == "glass_cannon"
        assert attacker.name == "Glass Cannon"
        assert attacker.base_stats.base_damage == 200.0
        assert attacker.base_stats.armor == 5.0  # Very low armor
        assert attacker.base_stats.crit_chance == 0.3
        assert attacker.base_stats.crit_damage == 2.5
        assert attacker.base_stats.max_health == 400.0  # Low health
        assert attacker.rarity == "Rare"

    def test_make_tank_defender(self):
        """Test tank defender creation."""
        defender = make_tank_defender()

        assert defender.id == "tank"
        assert defender.name == "Tank Defender"
        assert defender.base_stats.base_damage == 30.0  # Low damage
        assert defender.base_stats.armor == 100.0  # High armor
        assert defender.base_stats.max_health == 2000.0  # High health
        assert defender.base_stats.crit_chance == 0.02  # Low crit chance



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_hitcontext.py
// Size:           9.80 KB
// Last Modified:  2025-11-17T11:49:45.753Z
// =================================================================

"""Tests for HitContext telemetry dataclass."""

import pytest
from src.engine.hit_context import HitContext
from src import engine as main_engine  # Import the engine module directly
from src.models import Entity, EntityStats
from tests.fixtures import make_attacker, make_defender, make_rng, make_state_manager


class TestHitContextBasics:
    """Test basic HitContext functionality."""

    def test_hitcontext_creation_with_entities(self):
        """Test HitContext can be created with required fields."""
        attacker = make_attacker()
        defender = make_defender()

        ctx = HitContext(
            attacker=attacker,
            defender=defender,
            base_raw=100,
            base_resolved=100,
            final_damage=100
        )

        assert ctx.attacker == attacker
        assert ctx.defender == defender
        assert ctx.base_raw == 100
        assert ctx.base_resolved == 100
        assert ctx.final_damage == 100  # default value
        assert ctx.was_crit is False
        assert ctx.was_dodged is False
        assert ctx.was_blocked is False
        assert ctx.was_glancing is False

    def test_hitcontext_property_accessors(self):
        """Test derived property accessors work correctly."""
        attacker = make_attacker()
        defender = make_defender()

        attacker.id = "attacker_123"
        defender.id = "defender_456"

        ctx = HitContext(
            attacker=attacker,
            defender=defender,
            base_raw=100,
            base_resolved=100,
            final_damage=100
        )

        assert ctx.attacker_id == "attacker_123"
        assert ctx.defender_id == "defender_456"

    def test_to_serializable(self):
        """Test JSON-safe representation works correctly."""
        attacker = make_attacker()
        defender = make_defender()

        attacker.id = "att_001"
        defender.id = "def_002"

        ctx = HitContext(
            attacker=attacker,
            defender=defender,
            base_raw=100,
            base_resolved=100,
            final_damage=75,
            was_crit=True,
            was_blocked=True,
            damage_blocked=25.0
        )

        serializable = ctx.to_serializable()

        # Should be a dict with only primitive/string values
        assert serializable == {
            "attacker_id": "att_001",
            "defender_id": "def_002",
            "base_resolved": 100,
            "final_damage": 75,
            "was_crit": True,
            "was_dodged": False,
            "was_blocked": True,
            "was_glancing": False,
            "damage_pre_mitigation": 0.0,
            "damage_post_armor": 0.0,
            "damage_blocked": 25.0,
        }

        # Verify it doesn't contain Entity objects
        assert "attacker" not in serializable
        assert "defender" not in serializable


class TestHitContextCombatEngineIntegration:
    """Test HitContext populated by CombatEngine."""

    def test_resolve_hit_populates_phase2_fields_dodge(self):
        """Test dodge scenario populates was_dodged correctly."""

        # Set up for guaranteed dodge
        attacker = make_attacker(base_damage=100)
        defender = make_defender(armor=0, evasion_chance=1.0, dodge_chance=1.0)  # 100% dodge

        state_manager = make_state_manager(attacker=attacker, defender=defender)
        engine = main_engine.CombatEngine(rng=make_rng())

        ctx = engine.resolve_hit(attacker, defender, state_manager)

        assert ctx.was_dodged is True
        assert ctx.final_damage == 0.0
        assert ctx.was_crit is False  # Can't crit on dodge
        assert ctx.was_glancing is False

    def test_resolve_hit_populates_phase2_fields_glance(self, make_attacker, make_defender, make_state_manager, make_rng):
        """Test glancing blow scenario."""

        # Set up for guaranteed glance (evade but not dodge)
        attacker = make_attacker(base_damage=100)
        defender = make_defender(armor=0, evasion_chance=1.0, dodge_chance=0.0)  # 100% evade, 0% dodge

        state_manager = make_state_manager(attacker=attacker, defender=defender)
        engine = main_engine.CombatEngine(rng=make_rng())

        ctx = engine.resolve_hit(attacker, defender, state_manager)

        assert ctx.was_dodged is False
        assert ctx.was_glancing is True
        assert ctx.final_damage == 50.0  # 100 * 0.5
        assert ctx.was_crit is False  # Can't crit on glance

    def test_resolve_hit_populates_phase2_fields_block(self, make_attacker, make_defender, make_state_manager, make_rng):
        """Test block scenario with damage reduction."""

        # Set up normal hit that gets blocked
        attacker = make_attacker(base_damage=100, pierce_ratio=0.5)  # Pierce to ensure some damage
        defender = make_defender(armor=0, block_chance=1.0, block_amount=25)  # 100% block, 25 flat reduction

        state_manager = make_state_manager(attacker=attacker, defender=defender)
        engine = main_engine.CombatEngine(rng=make_rng())

        ctx = engine.resolve_hit(attacker, defender, state_manager)

        assert ctx.was_blocked is True
        assert ctx.damage_blocked == 25
        # Calculate expected damage: pierce damage formula max(100-0, 100*0.5) = 100, minus block 25 = 75
        assert ctx.final_damage == 75.0
        assert ctx.was_dodged is False
        assert ctx.was_glancing is False

    def test_resolve_hit_populates_phase2_fields_crit(self, make_attacker, make_defender, make_state_manager, make_rng):
        """Test critical hit scenario."""

        # Set up normal hit that crits
        attacker = make_attacker(base_damage=100, crit_chance=1.0, crit_damage=2.0)  # 100% crit, 2.0x damage
        defender = make_defender(armor=0)

        state_manager = make_state_manager(attacker=attacker, defender=defender)
        engine = main_engine.CombatEngine(rng=make_rng())

        ctx = engine.resolve_hit(attacker, defender, state_manager)

        assert ctx.was_crit is True
        assert ctx.final_damage == 200.0  # 100 * 2.0
        assert ctx.was_dodged is False
        assert ctx.was_glancing is False
        assert ctx.was_blocked is False

    def test_resolve_hit_deterministic_calculation(self, make_attacker, make_defender, make_state_manager):
        """Test that multiple calls with same parameters produce consistent results."""

        attacker = make_attacker(base_damage=100, crit_chance=0.5)
        defender = make_defender(armor=20)

        state_manager = make_state_manager(attacker=attacker, defender=defender)
        rng = make_rng()  # Use same seed for deterministic testing
        engine = main_engine.CombatEngine(rng=rng)

        # Run same calculation multiple times
        ctx1 = engine.resolve_hit(attacker, defender, state_manager)
        ctx2 = engine.resolve_hit(attacker, defender, state_manager)
        ctx3 = engine.resolve_hit(attacker, defender, state_manager)

        # Should be identical results for same inputs
        assert ctx1.final_damage == ctx2.final_damage
        assert ctx1.was_crit == ctx2.was_crit
        assert ctx1.was_dodged == ctx2.was_dodged
        assert ctx1.was_blocked == ctx2.was_blocked
        assert ctx1.was_glancing == ctx2.was_glancing


class TestHitContextSerialization:
    """Test HitContext serialization features."""

    def test_to_serializable_excludes_entities(self, make_attacker, make_defender):
        """Ensure Entity objects are never included in serialization."""
        attacker = make_attacker()
        defender = make_defender()

        ctx = HitContext(
            attacker=attacker,
            defender=defender,
            base_raw=100,
            base_resolved=100,
            final_damage=75
        )

        serialized = ctx.to_serializable()

        # Should not contain Entity objects
        for value in serialized.values():
            assert not hasattr(value, 'id')  # No Entity-like objects
            assert not hasattr(value, 'final_stats')  # No Entity-like objects

    def test_to_serializable_primitive_types_only(self, make_attacker, make_defender):
        """Ensure serialized data contains only JSON-compatible types."""
        attacker = make_attacker()
        defender = make_defender()

        ctx = HitContext(
            attacker=attacker,
            defender=defender,
            base_raw=100.5,  # float
            base_resolved=101,
            final_damage=75,
            damage_pre_mitigation=125.5
        )

        serialized = ctx.to_serializable()

        # All values should be JSON-serializable
        import json
        try:
            json_str = json.dumps(serialized)
            assert len(json_str) > 0
        except (TypeError, ValueError):
            pytest.fail("Serialization should produce valid JSON")


class TestHitContextBackwardCompatibility:
    """Test that HitContext doesn't break existing consumers."""

    def test_hitcontext_can_be_used_like_old_version(self, make_attacker, make_defender):
        """Test that consuming code can access familiar properties."""
        attacker = make_attacker()
        defender = make_defender()

        ctx = HitContext(
            attacker=attacker,
            defender=defender,
            base_raw=100,
            base_resolved=100,
            final_damage=75
        )

        # Test entity access (should work same as old HitContext)
        assert ctx.attacker == attacker
        assert ctx.defender == defender

        # Test flags access
        assert ctx.was_crit is False  # default
        ctx.was_crit = True
        assert ctx.was_crit is True

        # Test damage values
        assert ctx.final_damage == 75
        ctx.final_damage = 50
        assert ctx.final_damage == 50



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_item_generator.py
// Size:           5.46 KB
// Last Modified:  2025-11-14T13:42:14.257Z
// =================================================================

import unittest
import json
import random
from src.item_generator import ItemGenerator
from src.models import Item, RolledAffix


class TestItemGenerator(unittest.TestCase):

    def setUp(self):
        with open('data/game_data.json', 'r') as f:
            self.game_data = json.load(f)
        self.gen = ItemGenerator(self.game_data)

    def test_init_loads_data(self):
        """Test that the generator loads data correctly."""
        self.assertIsInstance(self.gen.affix_defs, dict)
        self.assertIsInstance(self.gen.item_templates, dict)
        self.assertIsInstance(self.gen.quality_tiers, list)
        self.assertIn('flat_dmg', self.gen.affix_defs)
        self.assertIn('base_iron_axe', self.gen.item_templates)

    def test_roll_quality_tier_valid_rarities(self):
        """Test quality tier rolling for different rarities."""
        valid_rarities = ['Common', 'Uncommon', 'Rare', 'Exotic', 'Epic', 'Glorious', 'Exalted', 'Legendary', 'Mythic', 'Godly']
        for rarity in valid_rarities:
            with self.subTest(rarity=rarity):
                if rarity in ['Normal']:
                    continue  # Normal may not be in items, but skip if any rarity in items
                try:
                    tier = self.gen._roll_quality_tier(rarity)
                    if tier:
                        self.assertIn('tier_name', tier)
                        self.assertIn('min_range', tier)
                        self.assertIn('max_range', tier)
                        self.assertTrue(tier['min_range'] <= tier['max_range'])
                except AttributeError:
                    pass  # Some rarities may not have tiers, skip

    def test_roll_quality_tier_rare(self):
        """Test quality tier rolling for Rare specifically."""
        tier = self.gen._roll_quality_tier('Rare')
        self.assertIsInstance(tier, dict)
        self.assertIn('tier_name', tier)
        self.assertIn('Rare', tier)
        # Since Rare can roll non-zero weights, but in our data, Rare has weights in higher tiers
        # The test that it returns something valid is sufficient due to randomness

    def test_get_affix_pool_single_pool(self):
        """Test affix pool gathering for single pool."""
        pool = self.gen._get_affix_pool(['weapon_pool'])
        self.assertIsInstance(pool, list)
        self.assertIn('flat_dmg', pool)  # From our affixes.csv

    def test_get_affix_pool_multiple_pools(self):
        """Test affix pool gathering for multiple pools."""
        pool = self.gen._get_affix_pool(['weapon_pool', 'axe_pool'])
        self.assertIsInstance(pool, list)
        self.assertIn('flat_dmg', pool)
        # Should have all from both

    def test_get_affix_pool_empty(self):
        """Test empty pool string."""
        pool = self.gen._get_affix_pool([])
        self.assertEqual(pool, [])

    def test_roll_one_affix_full_quality(self):
        """Test rolling affix with 100% max quality (can roll up to 100%)."""
        # Seed random for reproducible test
        random.seed(42)
        affix = self.gen._roll_one_affix('flat_dmg', 100)
        self.assertIsInstance(affix, RolledAffix)
        self.assertEqual(affix.affix_id, 'flat_dmg')
        # With any seed, should be between 0 and 50.0
        self.assertGreaterEqual(affix.value, 0)
        self.assertLessEqual(affix.value, 50.0)
        self.assertEqual(affix.mod_type, 'flat')
        self.assertEqual(affix.stat_affected, 'base_damage')

    def test_roll_one_affix_half_quality(self):
        """Test rolling affix with 50% max quality (can roll up to 25)."""
        # Seed random for reproducible test
        random.seed(42)
        affix = self.gen._roll_one_affix('flat_dmg', 50)
        self.assertIsInstance(affix, RolledAffix)
        # Should be between 0 and 25.0
        self.assertGreaterEqual(affix.value, 0)
        self.assertLessEqual(affix.value, 25.0)

    def test_generate_base_iron_axe(self):
        """Test generating an item."""
        item = self.gen.generate('base_iron_axe')
        self.assertIsInstance(item, Item)
        self.assertEqual(item.base_id, 'base_iron_axe')
        self.assertEqual(item.name, 'Iron Axe')
        self.assertEqual(item.slot, 'Weapon')
        self.assertEqual(item.rarity, 'Rare')
        self.assertIsInstance(item.affixes, list)
        self.assertTrue(len(item.affixes) >= 0)  # At least implicits, but in our data no implicits for iron axe

        # In our items.csv, implicit_affixes is empty, num_random_affixes = 2
        # But random pools have affixes, but due to randomness, just check structure
        for affix in item.affixes:
            self.assertIsInstance(affix, RolledAffix)
            self.assertIn(affix.mod_type, ['flat', 'multiplier'])
            self.assertIsInstance(affix.value, float)

    def test_generate_invalid_base_item(self):
        """Test generating with invalid base item ID."""
        with self.assertRaises(KeyError):
            self.gen.generate('nonexistent_item')

    def test_generate_gold_ring_with_implicits(self):
        """Test generating gold ring which has implicits."""
        item = self.gen.generate('base_gold_ring')
        self.assertEqual(item.rarity, 'Legendary')
        self.assertTrue(len(item.affixes) >= 1)  # At least crit_dmg implicit
        has_crit_dmg = any(affix.affix_id == 'crit_dmg' for affix in item.affixes)
        self.assertTrue(has_crit_dmg)


if __name__ == '__main__':
    unittest.main()



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_models.py
// Size:           8.76 KB
// Last Modified:  2025-11-14T15:22:41.276Z
// =================================================================

"""Tests for models.py - data structures and entity management."""

import pytest
from src.models import (
    Entity, EntityStats, Item, RolledAffix,
    SkillUseResult, Action, ApplyDamageAction, DispatchEventAction, ApplyEffectAction,
    RARITY_TO_CRIT_TIER
)
from tests.fixtures import make_entity


class TestSkillUseResult:
    """Test the SkillUseResult data structure."""

    def test_skill_use_result_creation(self):
        """Test creating a SkillUseResult with empty lists."""
        result = SkillUseResult(hit_results=[], actions=[])
        assert result.hit_results == []
        assert result.actions == []

    def test_skill_use_result_with_data(self):
        """Test SkillUseResult with actual data."""
        attacker = make_entity("attacker")
        defender = make_entity("defender")

        # Create mock hit context and actions
        from src.engine import HitContext
        hit_ctx = HitContext(attacker=attacker, defender=defender, base_damage=50.0)

        action1 = ApplyDamageAction(target_id=defender.id, damage=25.0, source="test")
        # Create minimal mock event - can be any object for testing
        from src.events import Event
        action2 = DispatchEventAction(event=Event())  # Mock event

        result = SkillUseResult(hit_results=[hit_ctx], actions=[action1, action2])

        assert len(result.hit_results) == 1
        assert len(result.actions) == 2
        assert result.hit_results[0].attacker == attacker
        assert isinstance(result.actions[0], ApplyDamageAction)
        assert result.actions[0].target_id == defender.id


class TestActions:
    """Test the Action class hierarchy."""

    def test_apply_damage_action_creation(self):
        """Test creating ApplyDamageAction."""
        action = ApplyDamageAction(target_id="target1", damage=100.0, source="skill")

        assert action.target_id == "target1"
        assert action.damage == 100.0
        assert action.source == "skill"

    def test_apply_damage_action_defaults(self):
        """Test ApplyDamageAction default values."""
        action = ApplyDamageAction(target_id="target1", damage=50.0)

        assert action.source == "skill"  # Default value

    def test_dispatch_event_action_creation(self):
        """Test creating DispatchEventAction."""
        from src.events import Event
        mock_event = Event()  # Create actual Event instance
        action = DispatchEventAction(event=mock_event)

        assert action.event == mock_event

    def test_apply_effect_action_creation(self):
        """Test creating ApplyEffectAction."""
        action = ApplyEffectAction(
            target_id="target1",
            effect_name="bleed",
            stacks_to_add=2,
            source="trigger"
        )

        assert action.target_id == "target1"
        assert action.effect_name == "bleed"
        assert action.stacks_to_add == 2
        assert action.source == "trigger"

    def test_apply_effect_action_defaults(self):
        """Test ApplyEffectAction default values."""
        action = ApplyEffectAction(target_id="target1", effect_name="poison")

        assert action.stacks_to_add == 1  # Default value
        assert action.source == "skill"  # Default value

    def test_action_base_class_is_abstract(self):
        """Test that Action base class cannot be instantiated directly."""
        # This should work since Action is just a base dataclass
        action = Action()
        assert isinstance(action, Action)


class TestEntityStats:
    """Test EntityStats validation and functionality."""

    def test_valid_entity_stats_creation(self):
        """Test creating valid EntityStats."""
        stats = EntityStats(
            base_damage=100.0,
            attack_speed=1.5,
            crit_chance=0.2,
            crit_damage=1.8,
            pierce_ratio=0.15,
            max_health=1000.0
        )
        assert stats.base_damage == 100.0
        assert stats.crit_chance == 0.2

    def test_entity_stats_validation_negative_damage(self):
        """Test that negative base_damage raises ValueError."""
        with pytest.raises(ValueError, match="base_damage must be non-negative"):
            EntityStats(base_damage=-10.0)

    def test_entity_stats_validation_zero_speed(self):
        """Test that zero attack_speed raises ValueError."""
        with pytest.raises(ValueError, match="attack_speed must be positive"):
            EntityStats(attack_speed=0.0)

    def test_entity_stats_validation_crit_chance_bounds(self):
        """Test crit_chance validation."""
        # Valid values should work
        EntityStats(crit_chance=0.0)
        EntityStats(crit_chance=1.0)

        # Invalid values should raise errors
        with pytest.raises(ValueError, match="crit_chance must be between 0 and 1"):
            EntityStats(crit_chance=-0.1)
        with pytest.raises(ValueError, match="crit_chance must be between 0 and 1"):
            EntityStats(crit_chance=1.1)

    def test_entity_stats_validation_pierce_ratio_bounds(self):
        """Test pierce_ratio validation."""
        # Should work at minimum
        EntityStats(pierce_ratio=0.01)

        # Should fail below minimum
        with pytest.raises(ValueError, match="pierce_ratio must be >= 0.01"):
            EntityStats(pierce_ratio=0.005)


class TestEntity:
    """Test Entity creation and functionality."""

    def test_entity_creation(self):
        """Test basic Entity creation."""
        stats = EntityStats()
        entity = Entity(id="test_entity", base_stats=stats, name="Test Entity", rarity="Rare")

        assert entity.id == "test_entity"
        assert entity.name == "Test Entity"
        assert entity.rarity == "Rare"
        assert entity.get_crit_tier() == 2  # Rare = tier 2

    def test_entity_default_name(self):
        """Test Entity name defaults to id."""
        stats = EntityStats()
        entity = Entity(id="test_entity", base_stats=stats)

        assert entity.name == "test_entity"

    def test_entity_invalid_rarity(self):
        """Test Entity rejects invalid rarity."""
        stats = EntityStats()
        with pytest.raises(ValueError, match="Invalid rarity"):
            Entity(id="test", base_stats=stats, rarity="Invalid")

    def test_entity_crit_tier_mapping(self):
        """Test crit tier mapping for all rarities."""
        stats = EntityStats()
        test_cases = [
            ("Common", 1),
            ("Uncommon", 1),
            ("Rare", 2),
            ("Epic", 2),
            ("Legendary", 3),
            ("Mythic", 3)
        ]

        for rarity, expected_tier in test_cases:
            entity = Entity(id=f"test_{rarity}", base_stats=stats, rarity=rarity)
            assert entity.get_crit_tier() == expected_tier

    def test_entity_empty_id_validation(self):
        """Test Entity rejects empty id."""
        stats = EntityStats()
        with pytest.raises(ValueError, match="Entity id cannot be empty"):
            Entity(id="", base_stats=stats)


class TestItemSystem:
    """Test Item and RolledAffix functionality."""

    def test_rolled_affix_creation(self):
        """Test creating RolledAffix."""
        affix = RolledAffix(
            affix_id="test_affix",
            stat_affected="base_damage",
            mod_type="flat",
            description="+10 Damage",
            base_value=10.0,
            value=12.5
        )

        assert affix.affix_id == "test_affix"
        assert affix.stat_affected == "base_damage"
        assert affix.mod_type == "flat"
        assert affix.value == 12.5

    def test_item_creation(self):
        """Test creating Item."""
        affixes = [
            RolledAffix("affix1", "base_damage", "flat", "+10 Damage", 10.0, 10.0)
        ]

        item = Item(
            instance_id="item_001",
            base_id="sword_basic",
            name="Rusty Sword",
            slot="weapon",
            rarity="Common",
            quality_tier="Normal",
            quality_roll=1,
            affixes=affixes
        )

        assert item.instance_id == "item_001"
        assert item.name == "Rusty Sword"
        assert len(item.affixes) == 1


# Rarity mapping tests
class TestRarityMapping:
    """Test the global rarity to crit tier mapping."""

    def test_all_rarities_have_mappings(self):
        """Ensure all standard rarities are mapped."""
        expected_rarities = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic"}

        assert set(RARITY_TO_CRIT_TIER.keys()) == expected_rarities

    def test_crit_tier_values(self):
        """Ensure crit tier values are valid (1, 2, or 3)."""
        for tier in RARITY_TO_CRIT_TIER.values():
            assert tier in {1, 2, 3}



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_orchestrator.py
// Size:           7.23 KB
// Last Modified:  2025-11-14T15:40:32.310Z
// =================================================================

"""Tests for combat_orchestrator.py - orchestration of calculated actions."""

import pytest
from unittest.mock import MagicMock, patch
from src.models import SkillUseResult, ApplyDamageAction, DispatchEventAction, Entity, EntityStats
from src.events import OnHitEvent
from src.combat_orchestrator import CombatOrchestrator, execute_skill_use
from tests.fixtures import make_entity


class TestCombatOrchestrator:
    """Test the CombatOrchestrator class functionality."""

    def test_execute_skill_use_with_damage_action(self):
        """Test executing a SkillUseResult with damage actions."""
        # Setup mocks
        state_manager = MagicMock()
        event_bus = MagicMock()

        orchestrator = CombatOrchestrator(state_manager, event_bus)

        # Create a fake SkillUseResult with damage action
        attacker = make_entity("attacker")
        defender = make_entity("defender")

        hit_results = []  # Empty for this test
        actions = [
            ApplyDamageAction(target_id=defender.id, damage=100.0, source="test_skill")
        ]

        result = SkillUseResult(hit_results=hit_results, actions=actions)

        # Execute
        orchestrator.execute_skill_use(result)

        # Verify damage was applied
        state_manager.apply_damage.assert_called_once_with(defender.id, 100.0)

        # Verify no events were dispatched (no DispatchEventAction in actions)
        event_bus.dispatch.assert_not_called()

    def test_execute_skill_use_with_event_action(self):
        """Test executing a SkillUseResult with event actions."""
        # Setup mocks
        state_manager = MagicMock()
        event_bus = MagicMock()

        orchestrator = CombatOrchestrator(state_manager, event_bus)

        # Create a fake SkillUseResult with event action
        attacker = make_entity("attacker")
        defender = make_entity("defender")

        mock_event = OnHitEvent(
            attacker=attacker,
            defender=defender,
            damage_dealt=50.0,
            is_crit=False
        )

        actions = [
            DispatchEventAction(event=mock_event)
        ]

        result = SkillUseResult(hit_results=[], actions=actions)

        # Execute
        orchestrator.execute_skill_use(result)

        # Verify event was dispatched
        event_bus.dispatch.assert_called_once_with(mock_event)

        # Verify no damage was applied
        state_manager.apply_damage.assert_not_called()

    def test_execute_skill_use_with_multiple_actions(self):
        """Test executing multiple actions in sequence."""
        # Setup mocks
        state_manager = MagicMock()
        event_bus = MagicMock()

        orchestrator = CombatOrchestrator(state_manager, event_bus)

        # Create multiple actions
        attacker = make_entity("attacker")
        defender = make_entity("defender")

        damage_action = ApplyDamageAction(target_id=defender.id, damage=75.0, source="multi_action_skill")
        mock_event = OnHitEvent(attacker=attacker, defender=defender, damage_dealt=75.0, is_crit=False)
        event_action = DispatchEventAction(event=mock_event)

        actions = [damage_action, event_action]

        result = SkillUseResult(hit_results=[], actions=actions)

        # Execute
        orchestrator.execute_skill_use(result)

        # Verify both actions were executed in order
        assert state_manager.apply_damage.call_count == 1
        assert event_bus.dispatch.call_count == 1

        state_manager.apply_damage.assert_called_with(defender.id, 75.0)
        event_bus.dispatch.assert_called_with(mock_event)

    def test_execute_skill_use_unknown_action_type(self):
        """Test handling of unknown action types."""
        # Setup mocks
        state_manager = MagicMock()
        event_bus = MagicMock()

        orchestrator = CombatOrchestrator(state_manager, event_bus)

        # Create a custom unknown action
        class UnknownAction:
            pass

        actions = [UnknownAction()]

        result = SkillUseResult(hit_results=[], actions=actions)

        # Execute and expect ValueError
        with pytest.raises(ValueError, match="Unknown action type"):
            orchestrator.execute_skill_use(result)


    def test_execute_skill_use_with_rng_for_triggers(self):
        """Test that actions can be executed with RNG provided."""
        # Test basic execution with RNG for future trigger logic
        state_manager = MagicMock()
        event_bus = MagicMock()
        rng_mock = MagicMock()

        orchestrator = CombatOrchestrator(state_manager, event_bus, rng=rng_mock)

        # Create a known action type
        defender = make_entity("defender")
        actions = [ApplyDamageAction(target_id=defender.id, damage=25.0, source="test_skill")]

        result = SkillUseResult(hit_results=[], actions=actions)

        # Execute - should work with ApplyDamageAction
        orchestrator.execute_skill_use(result)

        # Verify damage was applied
        state_manager.apply_damage.assert_called_once_with(defender.id, 25.0)
        # For now, it just ensures the method runs without error

    def test_execute_skill_use_empty_result(self):
        """Test executing a SkillUseResult with no actions."""
        state_manager = MagicMock()
        event_bus = MagicMock()

        orchestrator = CombatOrchestrator(state_manager, event_bus)

        result = SkillUseResult(hit_results=[], actions=[])

        # Should execute without error
        orchestrator.execute_skill_use(result)

        # No methods should be called
        state_manager.apply_damage.assert_not_called()
        event_bus.dispatch.assert_not_called()


class TestExecuteSkillUseConvenienceFunction:
    """Test the convenience function execute_skill_use."""

    def test_execute_skill_use_convenience_function(self):
        """Test the standalone convenience function."""
        state_manager = MagicMock()
        event_bus = MagicMock()
        rng = MagicMock()

        attacker = make_entity("attacker")
        defender = make_entity("defender")

        # Create a simple result
        damage_action = ApplyDamageAction(target_id=defender.id, damage=25.0, source="convenience_test")
        result = SkillUseResult(hit_results=[], actions=[damage_action])

        # Execute using convenience function
        execute_skill_use(result, state_manager, event_bus, rng)

        # Verify it worked
        state_manager.apply_damage.assert_called_once_with(defender.id, 25.0)
        event_bus.dispatch.assert_not_called()

    def test_execute_skill_use_convenience_function_no_rng(self):
        """Test convenience function without explicit RNG."""
        state_manager = MagicMock()
        event_bus = MagicMock()

        defender = make_entity("defender")
        damage_action = ApplyDamageAction(target_id=defender.id, damage=10.0, source="no_rng_test")
        result = SkillUseResult(hit_results=[], actions=[damage_action])

        # Execute without rng parameter
        execute_skill_use(result, state_manager, event_bus)

        # Should still work (orchestrator will create its own RNG)
        state_manager.apply_damage.assert_called_once_with(defender.id, 10.0)



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_pr6_integration.py
// Size:           1.86 KB
// Last Modified:  2025-11-17T11:05:57.793Z
// =================================================================

"""Integration test for PR6 - Combat Math Centralization."""

from random import Random
from src.combat_engine import CombatEngine, HitContext
from src.models import Entity
from src.state import StateManager, EntityState


def test_pr6_resolve_hit_integration():
    """Test that PR6 functions integrate correctly with resolve_hit."""

    # Create test entities
    attacker = Entity(id="test_attacker", name="Test Attacker")
    attacker.final_stats.base_damage = 100
    attacker.final_stats.crit_chance = 0.5
    attacker.final_stats.crit_damage = 2.0
    attacker.final_stats.pierce_ratio = 0.0

    defender = Entity(id="test_defender", name="Test Defender")
    defender.final_stats.armor = 50
    defender.final_stats.evasion_chance = 0.0
    defender.final_stats.dodge_chance = 0.0
    defender.final_stats.block_chance = 0.0
    defender.final_stats.block_amount = 20

    # Create deterministic RNG
    rng = Random(42)
    engine = CombatEngine(rng=rng)

    # Create state manager
    state_manager = StateManager()
    state_manager.add_entity(attacker)
    state_manager.add_entity(defender)

    # Resolve hit
    ctx = engine.resolve_hit(attacker, defender, state_manager)

    # Verify it's a HitContext
    assert isinstance(ctx, HitContext)

    # Verify basic properties
    assert ctx.attacker == attacker
    assert ctx.defender == defender
    assert ctx.base_damage == 100
    assert ctx.final_damage >= 0

    # Verify with seeded RNG we get deterministic results
    rng2 = Random(42)
    engine2 = CombatEngine(rng=rng2)
    ctx2 = engine2.resolve_hit(attacker, defender, state_manager)

    assert ctx.final_damage == ctx2.final_damage
    assert ctx.is_crit == ctx2.is_crit

    print(f"âœ… PR6 Integration Test Passed - Damage: {ctx.final_damage}")


if __name__ == "__main__":
    test_pr6_resolve_hit_integration()



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_simulation.py
// Size:           10.34 KB
// Last Modified:  2025-11-16T14:55:48.811Z
// =================================================================

"""Unit tests for simulation and time-based systems (DoT ticks, etc.)."""

import pytest
from src.models import Entity, EntityStats
from src.events import EventBus
from src.state import StateManager
from tests.fixtures import make_defender


class TestDoTSystem:
    """Test damage-over-time effects and time-based simulation."""

    def test_dot_ticks_over_time(self):
        """Test that DoT effects tick correctly over time and accumulate damage."""
        # Create entity with DoT applied
        defender = make_defender(armor=0.0, max_health=1000.0)

        # Create event bus and state manager
        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(defender)

        # Apply Bleed debuff with 5 stacks
        state_manager.apply_debuff(
            entity_id=defender.id,
            debuff_name="Bleed",
            stacks_to_add=5,
            max_duration=10.0,  # 10 seconds
            tick_interval=1.0,
            damage_per_tick=5.0
        )

        # Verify initial state
        defender_state = state_manager.get_state(defender.id)
        assert defender_state is not None
        assert defender_state.current_health == 1000.0
        assert "Bleed" in defender_state.active_debuffs
        assert defender_state.active_debuffs["Bleed"].stacks == 5

        # Simulate 3 seconds of time (should trigger 3 ticks at 5 damage per stack = 25 damage per tick)
        state_manager.tick(delta=3.0, event_bus=event_bus)

        # Check damage accumulation: 3 ticks * 5 stacks * 5 damage = 75 damage
        defender_state = state_manager.get_state(defender.id)
        assert defender_state is not None
        assert defender_state.current_health == 1000.0 - 75.0  # 925.0

        # Check that duration decreased
        assert defender_state.active_debuffs["Bleed"].time_remaining == 7.0  # 10.0 - 3.0

    def test_dot_damage_accumulation_multiple_effects(self):
        """Test DoT damage accumulation with multiple different effects."""
        defender = make_defender(armor=0.0, max_health=1000.0)

        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(defender)

        # Apply Bleed (5 stacks) and Poison (3 stacks)
        state_manager.apply_debuff(
            entity_id=defender.id,
            debuff_name="Bleed",
            stacks_to_add=5,
            max_duration=10.0,
            tick_interval=1.0,
            damage_per_tick=5.0
        )
        state_manager.apply_debuff(
            entity_id=defender.id,
            debuff_name="Poison",
            stacks_to_add=3,
            max_duration=8.0,
            tick_interval=1.0,
            damage_per_tick=5.0
        )

        # Simulate 2 seconds (2 ticks)
        # Bleed: 2 * 5 * 5 = 50 damage
        # Poison: 2 * 3 * 5 = 30 damage (assuming same 5 damage per stack)
        # Total: 80 damage
        state_manager.tick(delta=2.0, event_bus=event_bus)

        defender_state = state_manager.get_state(defender.id)
        assert defender_state is not None
        assert defender_state.current_health == 1000.0 - 80.0  # 920.0

        # Check both effects are present with correct remaining durations
        assert "Bleed" in defender_state.active_debuffs
        assert "Poison" in defender_state.active_debuffs
        assert defender_state.active_debuffs["Bleed"].time_remaining == 8.0  # 10.0 - 2.0
        assert defender_state.active_debuffs["Poison"].time_remaining == 6.0  # 8.0 - 2.0

    def test_dot_effect_expiration(self):
        """Test that DoT effects expire correctly after their duration."""
        defender = make_defender(armor=0.0, max_health=1000.0)

        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(defender)

        # Apply short-duration Bleed (2 seconds)
        state_manager.add_or_refresh_debuff(
            entity_id=defender.id,
            debuff_name="Bleed",
            stacks_to_add=2,
            duration=2.0
        )

        # Verify initial state
        defender_state = state_manager.get_state(defender.id)
        assert "Bleed" in defender_state.active_debuffs
        assert defender_state.active_debuffs["Bleed"].time_remaining == 2.0

        # Simulate 1.5 seconds (1 tick, duration becomes 0.5)
        state_manager.update_dot_effects(delta_time=1.5, event_bus=event_bus)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0 - 10.0  # 1 tick * 2 stacks * 5 damage
        assert defender_state.active_debuffs["Bleed"].time_remaining == 0.5

        # Simulate another 1 second (should tick once more, then expire)
        state_manager.update_dot_effects(delta_time=1.0, event_bus=event_bus)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0 - 20.0  # 2 ticks * 2 stacks * 5 damage
        assert "Bleed" not in defender_state.active_debuffs  # Should be expired

    def test_dot_partial_ticks(self):
        """Test DoT ticking with partial time intervals."""
        defender = make_defender(armor=0.0, max_health=1000.0)

        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(defender)

        # Apply Bleed with 1 stack
        state_manager.add_or_refresh_debuff(
            entity_id=defender.id,
            debuff_name="Bleed",
            stacks_to_add=1,
            duration=5.0
        )

        # Simulate 0.5 seconds (no tick yet - tick_interval = 1.0)
        state_manager.update_dot_effects(delta_time=0.5, event_bus=event_bus)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0  # No damage yet
        assert defender_state.active_debuffs["Bleed"].time_remaining == 4.5

        # Simulate 1.1 seconds in one update (should trigger 1 tick)
        state_manager.update_dot_effects(delta_time=1.1, event_bus=event_bus)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0 - 5.0  # 1 tick * 1 stack * 5 damage
        assert defender_state.active_debuffs["Bleed"].time_remaining == 3.4  # 4.5 - 1.1

    def test_dot_stacking_behavior(self):
        """Test DoT stacking and refresh behavior over time."""
        defender = make_defender(armor=0.0, max_health=1000.0)

        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(defender)

        # Apply initial Bleed with 2 stacks
        state_manager.add_or_refresh_debuff(
            entity_id=defender.id,
            debuff_name="Bleed",
            stacks_to_add=2,
            duration=5.0
        )

        # Simulate 2 seconds (2 ticks)
        state_manager.update_dot_effects(delta_time=2.0, event_bus=event_bus)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0 - 20.0  # 2 ticks * 2 stacks * 5 damage
        assert defender_state.active_debuffs["Bleed"].stacks == 2
        assert defender_state.active_debuffs["Bleed"].time_remaining == 3.0

        # Refresh with 3 more stacks (total should be 5)
        state_manager.add_or_refresh_debuff(
            entity_id=defender.id,
            debuff_name="Bleed",
            stacks_to_add=3,
            duration=5.0  # Reset duration
        )

        defender_state = state_manager.get_state(defender.id)
        assert defender_state.active_debuffs["Bleed"].stacks == 5  # 2 + 3
        assert defender_state.active_debuffs["Bleed"].time_remaining == 5.0  # Refreshed

        # Simulate 1 more second (1 tick with 5 stacks)
        state_manager.update_dot_effects(delta_time=1.0, event_bus=event_bus)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0 - 45.0  # Previous 20 + 25 new damage
        assert defender_state.active_debuffs["Bleed"].stacks == 5
        assert defender_state.active_debuffs["Bleed"].time_remaining == 4.0

    def test_dot_no_damage_to_dead_entities(self):
        """Test that DoT effects don't damage already dead entities."""
        defender = make_defender(armor=0.0, max_health=1000.0)

        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(defender)

        # Apply Bleed
        state_manager.add_or_refresh_debuff(
            entity_id=defender.id,
            debuff_name="Bleed",
            stacks_to_add=1,
            duration=10.0
        )

        # Kill the entity directly
        state_manager.apply_damage(defender.id, 1000.0)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 0.0
        assert not defender_state.is_alive

        # Simulate time - should not apply more damage
        state_manager.update_dot_effects(delta_time=2.0, event_bus=event_bus)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 0.0  # Still 0, no additional damage

    def test_dot_event_dispatching(self):
        """Test that DoT ticks dispatch DamageTickEvent when event_bus is provided."""
        defender = make_defender(armor=0.0, max_health=1000.0)

        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(defender)

        # Track events
        received_events = []
        def event_handler(event):
            received_events.append(event)
        from src.events import DamageTickEvent
        event_bus.subscribe(DamageTickEvent, event_handler)

        # Apply Bleed
        state_manager.add_or_refresh_debuff(
            entity_id=defender.id,
            debuff_name="Bleed",
            stacks_to_add=2,
            duration=10.0
        )

        # Simulate 1 second (1 tick)
        state_manager.update_dot_effects(delta_time=1.0, event_bus=event_bus)

        # Should have received 1 DamageTickEvent
        assert len(received_events) == 1
        event = received_events[0]
        assert event.target.id == defender.id
        assert event.effect_name == "Bleed"
        assert event.damage_dealt == 10.0  # 2 stacks * 5 damage
        assert event.stacks == 2



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_skills.py
// Size:           7.96 KB
// Last Modified:  2025-11-11T13:10:26.039Z
// =================================================================

"""Unit tests for skill system - multi-hit skills and triggers."""

import pytest
from src.models import Entity, EntityStats
from src.skills import Skill, Trigger
from src.events import EventBus
from src.state import StateManager
from src.engine import CombatEngine
from src.effect_handlers import BleedHandler
from tests.fixtures import make_rng, make_attacker, make_defender


class TestSkillSystem:
    """Test skill system functionality."""

    def test_multi_hit_skill_basic(self):
        """Test that multi-hit skills execute the correct number of hits."""
        from tests.fixtures import make_rng

        # Create entities
        attacker = make_attacker(base_damage=50.0)
        defender = make_defender(armor=0.0, max_health=1000.0)

        # Create event bus and state manager
        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(attacker)
        state_manager.register_entity(defender)

        # Create engine with deterministic RNG (no crits)
        engine = CombatEngine(rng=make_rng(1))  # Seed that won't trigger crits

        # Create 3-hit skill with no triggers
        skill = Skill(
            id="test_skill",
            name="Test Multi-Hit",
            hits=3,
            triggers=[]
        )

        # Execute skill
        engine.process_skill_use(attacker, defender, skill, event_bus, state_manager)

        # Check that 3 hits were applied (50 damage * 3 = 150 total)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0 - 150.0  # 850.0

    def test_multi_hit_skill_with_triggers_deterministic(self):
        """Test multi-hit skill with triggers using deterministic RNG."""
        # Create entities
        attacker = make_attacker(base_damage=50.0)
        defender = make_defender(armor=0.0, max_health=1000.0)

        # Create event bus and state manager
        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(attacker)
        state_manager.register_entity(defender)

        # Create Bleed handler with deterministic RNG
        rng = make_rng(42)
        bleed_handler = BleedHandler(event_bus, state_manager, proc_rate=1.0, rng=rng)  # 100% proc for testing

        # Create engine with RNG that will trigger procs on specific hits
        # We need to control the RNG sequence for proc checks
        rng = make_rng(42)  # This will give us predictable proc outcomes
        engine = CombatEngine(rng=rng)

        # Create skill with trigger that has 50% proc rate
        skill = Skill(
            id="bleed_skill",
            name="Bleed Strike",
            hits=4,  # Test with 4 hits
            triggers=[
                Trigger(
                    event="OnHit",
                    check={"proc_rate": 0.5},  # 50% chance
                    result={"apply_debuff": "Bleed", "stacks": 1}
                )
            ]
        )

        # Execute skill
        engine.process_skill_use(attacker, defender, skill, event_bus, state_manager)

        # Check damage (4 hits * 50 damage = 200 total)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0 - 200.0  # 800.0

        # Check that some bleeds were applied (with deterministic RNG, we expect specific outcomes)
        # The exact number depends on the RNG sequence, but we should have at least some bleeds
        assert len(defender_state.active_debuffs) > 0
        assert "Bleed" in defender_state.active_debuffs

    def test_multi_hit_skill_per_hit_independence(self):
        """Test that each hit in a multi-hit skill is independent."""
        # Create entities
        attacker = make_attacker(base_damage=100.0, crit_chance=0.0)  # No crits
        defender = make_defender(armor=0.0, max_health=1000.0)

        # Create event bus and state manager
        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(attacker)
        state_manager.register_entity(defender)

        # Create engine
        engine = CombatEngine()

        # Create 2-hit skill
        skill = Skill(
            id="double_hit",
            name="Double Hit",
            hits=2,
            triggers=[]
        )

        # Execute skill
        engine.process_skill_use(attacker, defender, skill, event_bus, state_manager)

        # Check that exactly 2 hits were applied (100 * 2 = 200 damage)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0 - 200.0  # 800.0

    def test_skill_trigger_proc_rates_with_deterministic_rng(self):
        """Test skill trigger proc rates with deterministic RNG for predictable outcomes."""
        # Create entities
        attacker = make_attacker(base_damage=50.0)
        defender = make_defender(armor=0.0, max_health=1000.0)

        # Create event bus and state manager
        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(attacker)
        state_manager.register_entity(defender)

        # NOTE: Not creating BleedHandler to avoid double application

        # Create engine with RNG that gives predictable proc outcomes
        rng = make_rng(123)  # Specific seed for predictable results
        engine = CombatEngine(rng=rng)

        # Create skill with guaranteed proc trigger
        skill = Skill(
            id="guaranteed_bleed",
            name="Guaranteed Bleed",
            hits=1,
            triggers=[
                Trigger(
                    event="OnHit",
                    check={"proc_rate": 1.0},  # 100% proc
                    result={"apply_debuff": "Bleed", "stacks": 2}
                )
            ]
        )

        # Execute skill
        engine.process_skill_use(attacker, defender, skill, event_bus, state_manager)

        # Check damage (1 hit * 50 damage = 50 total)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0 - 50.0  # 950.0

        # Check that bleed was applied with correct stacks
        assert "Bleed" in defender_state.active_debuffs
        bleed_debuff = defender_state.active_debuffs["Bleed"]
        assert bleed_debuff.stacks == 2

    def test_multi_hit_skill_state_accumulation(self):
        """Test that multi-hit skills properly accumulate state changes."""
        # Create entities
        attacker = make_attacker(base_damage=25.0)
        defender = make_defender(armor=0.0, max_health=1000.0)

        # Create event bus and state manager
        event_bus = EventBus()
        state_manager = StateManager()
        state_manager.register_entity(attacker)
        state_manager.register_entity(defender)

        # NOTE: Not creating BleedHandler to avoid double application

        # Create engine
        engine = CombatEngine()

        # Create 4-hit skill where each hit applies 1 stack of bleed
        skill = Skill(
            id="stacking_bleed",
            name="Stacking Bleed",
            hits=4,
            triggers=[
                Trigger(
                    event="OnHit",
                    check={"proc_rate": 1.0},  # Guaranteed proc
                    result={"apply_debuff": "Bleed", "stacks": 1}
                )
            ]
        )

        # Execute skill
        engine.process_skill_use(attacker, defender, skill, event_bus, state_manager)

        # Check damage accumulation (4 hits * 25 damage = 100 total)
        defender_state = state_manager.get_state(defender.id)
        assert defender_state.current_health == 1000.0 - 100.0  # 900.0

        # Check stack accumulation (4 procs * 1 stack each = 4 total stacks)
        assert "Bleed" in defender_state.active_debuffs
        bleed_debuff = defender_state.active_debuffs["Bleed"]
        assert bleed_debuff.stacks == 4



// =================================================================
// METADATA
// =================================================================
// File Path:      tests\test_state.py
// Size:           10.51 KB
// Last Modified:  2025-11-17T13:39:23.015Z
// =================================================================

"""Unit tests for state management (EntityState and StateManager)."""

import pytest
from src.models import Entity, EntityStats
from src.state import EntityState, StateManager


class TestEntityState:
    """Test the EntityState dataclass."""

    def test_entity_state_creation_alive(self):
        """Test creating an EntityState for a living entity."""
        state = EntityState(current_health=100.0, is_alive=True)
        assert state.current_health == 100.0
        assert state.is_alive is True

    def test_entity_state_creation_dead(self):
        """Test creating an EntityState for a dead entity."""
        state = EntityState(current_health=0.0, is_alive=False)
        assert state.current_health == 0.0
        assert state.is_alive is False

    def test_entity_state_validation_negative_health(self):
        """Test that negative current_health raises ValueError."""
        with pytest.raises(ValueError, match="current_health cannot be negative"):
            EntityState(current_health=-10.0)

    def test_entity_state_auto_correct_dead(self):
        """Test that zero health automatically sets is_alive to False."""
        state = EntityState(current_health=0.0, is_alive=True)
        assert state.current_health == 0.0
        assert state.is_alive is False


class TestStateManager:
    """Test the StateManager class."""

    def test_state_manager_initialization(self):
        """Test that StateManager starts empty."""
        manager = StateManager()
        assert len(manager) == 0

    def test_add_entity_success(self):
        """Test successful entity addition."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)

        assert len(manager) == 1
        assert "test_entity" in manager
        assert manager.is_registered("test_entity")

        state = manager.get_state("test_entity")
        assert state is not None
        assert state.current_health == 100.0
        assert state.is_alive is True

    def test_add_entity_duplicate(self):
        """Test that adding the same entity twice raises ValueError."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)

        with pytest.raises(ValueError, match="Entity 'test_entity' is already registered"):
            manager.add_entity(entity)

    def test_remove_entity_success(self):
        """Test successful entity removal."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)
        assert len(manager) == 1

        manager.remove_entity("test_entity")
        assert len(manager) == 0
        assert "test_entity" not in manager
        assert not manager.is_registered("test_entity")

    def test_remove_entity_not_registered(self):
        """Test that removing a non-registered entity raises KeyError."""
        manager = StateManager()

        with pytest.raises(KeyError, match="Entity 'unknown' is not registered"):
            manager.remove_entity("unknown")

    def test_get_state_unregistered_entity(self):
        """Test that getting state of unregistered entity raises KeyError."""
        manager = StateManager()

        with pytest.raises(KeyError, match="Entity 'unknown' not registered - call add_entity\\(\\) first"):
            manager.get_state("unknown")

    def test_apply_damage_normal(self):
        """Test applying damage less than current health."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)
        damage_applied = manager.apply_damage("test_entity", 30.0)

        assert damage_applied == 30.0
        state = manager.get_state("test_entity")
        assert state is not None
        assert state.current_health == 70.0
        assert state.is_alive is True

    def test_apply_damage_exact_death(self):
        """Test applying damage exactly equal to current health."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)
        damage_applied = manager.apply_damage("test_entity", 100.0)

        assert damage_applied == 100.0
        state = manager.get_state("test_entity")
        assert state is not None
        assert state.current_health == 0.0
        assert state.is_alive is False

    def test_apply_damage_to_dead_entity(self):
        """Test that damage to dead entities does nothing."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)
        manager.apply_damage("test_entity", 100.0)  # Kill the entity

        damage_applied = manager.apply_damage("test_entity", 50.0)
        assert damage_applied == 0.0

        state = manager.get_state("test_entity")
        assert state is not None
        assert state.current_health == 0.0
        assert state.is_alive is False

    def test_apply_damage_unregistered_entity(self):
        """Test that damage to unregistered entities returns 0.0."""
        manager = StateManager()

        with pytest.raises(KeyError, match="Entity 'unknown' not registered"):
            manager.apply_damage("unknown", 50.0)

    def test_apply_damage_negative_damage(self):
        """Test that negative damage is ignored (returns 0.0)."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)
        original_health = 100.0

        damage_applied = manager.apply_damage("test_entity", -10.0)
        assert damage_applied == 0.0

        state = manager.get_state("test_entity")
        assert state is not None
        assert state.current_health == original_health  # Health unchanged

    def test_set_health(self):
        """Test setting entity health directly."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)

        # Set health to specific value
        manager.set_health("test_entity", 75.0)
        state = manager.get_state("test_entity")
        assert state.current_health == 75.0
        assert state.is_alive is True

        # Set health to 0 (should mark as dead)
        manager.set_health("test_entity", 0.0)
        state = manager.get_state("test_entity")
        assert state.current_health == 0.0
        assert state.is_alive is False

    def test_set_resource(self):
        """Test setting entity resource directly."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)

        # Set resource to specific value
        manager.set_resource("test_entity", 50.0)
        assert manager.get_current_resource("test_entity") == 50.0

        # Try to set above max (should clamp)
        manager.set_resource("test_entity", 150.0)
        assert manager.get_current_resource("test_entity") == 100.0

        # Try to set below 0 (should clamp)
        manager.set_resource("test_entity", -10.0)
        assert manager.get_current_resource("test_entity") == 0.0

    def test_set_cooldown(self):
        """Test setting skill cooldowns."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)

        # Set cooldown
        manager.set_cooldown("test_entity", "fireball", 3.5)
        assert manager.get_cooldown_remaining("test_entity", "fireball") == 3.5

        # Set another cooldown
        manager.set_cooldown("test_entity", "heal", 1.0)
        assert manager.get_cooldown_remaining("test_entity", "heal") == 1.0
        assert manager.get_cooldown_remaining("test_entity", "fireball") == 3.5

    def test_get_cooldown_remaining(self):
        """Test getting cooldown remaining for skills."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)

        # Test unset cooldown returns 0
        assert manager.get_cooldown_remaining("test_entity", "nonexistent") == 0.0

        # Set and get cooldown
        manager.set_cooldown("test_entity", "skill_1", 5.0)
        assert manager.get_cooldown_remaining("test_entity", "skill_1") == 5.0

    def test_iter_effects(self):
        """Test iterating over active effects."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)

        # Initially should be empty
        assert list(manager.iter_effects("test_entity")) == []

        # Note: Testing effects would require EffectInstance - out of scope for now

    def test_reset_system(self):
        """Test resetting the state manager."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        manager.add_entity(entity)
        manager.set_health("test_entity", 50.0)
        manager.set_resource("test_entity", 75.0)
        manager.set_cooldown("test_entity", "skill", 2.0)

        assert len(manager) == 1
        assert manager.get_current_health("test_entity") == 50.0

        manager.reset_system()
        assert len(manager) == 0

        # Should not be able to access entity now
        with pytest.raises(KeyError):
            manager.get_state("test_entity")

    def test_len_and_contains(self):
        """Test __len__ and __contains__ methods."""
        manager = StateManager()
        stats = EntityStats(max_health=100.0)
        entity = Entity(id="test_entity", base_stats=stats)

        assert len(manager) == 0
        assert "test_entity" not in manager

        manager.add_entity(entity)

        assert len(manager) == 1
        assert "test_entity" in manager
        assert "unknown" not in manager



// =================================================================
// METADATA
// =================================================================
// File Path:      test_data.py
// Size:           0.34 KB
// Last Modified:  2025-11-17T20:16:23.121Z
// =================================================================

#!/usr/bin/env python3
from src.data.data_parser import parse_all_csvs

try:
    data = parse_all_csvs()
    print(f"Data parsed successfully. Affixes: {len(data['affixes'])}")
    if 'swiftslayer' in data['affixes']:
        print("Swiftslayer affix:", data['affixes']['swiftslayer'])
except Exception as e:
    print(f"Error: {e}")



// =================================================================
// METADATA
// =================================================================
// File Path:      test_data_load.py
// Size:           2.22 KB
// Last Modified:  2025-11-17T10:35:17.307Z
// =================================================================

#!/usr/bin/env python3
"""Test script to verify PR5 implementation is complete."""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from game_data_provider import GameDataProvider

def main():
    print("ðŸ” Verifying PR5 Implementation - CSV Schema Validation")
    print("=" * 60)

    try:
        gdp = GameDataProvider()
        data = gdp.get_data()

        print("âœ… Data loaded successfully via schema validation")
        print(f"ðŸ“Š Load complete:")
        print(f"   - Items: {len(data['items'])}")
        print(f"   - Affixes: {len(data['affixes'])}")
        print(f"   - Effects: {len(data['effects'])}")
        print(f"   - Skills: {len(data['skills'])}")
        print(f"   - Quality Tiers: {len(data['quality_tiers'])}")

        # Verify schema keys exist
        required_keys = ['affixes', 'items', 'quality_tiers', 'effects', 'skills']
        for key in required_keys:
            if key not in data:
                print(f"âŒ Missing required data key: {key}")
                return False

        print("\nðŸ” Testing sample validation:")
        # Test sample data structure
        if data['items']:
            item = next(iter(data['items'].values()))
            required_item_fields = ['item_id', 'name', 'slot', 'rarity', 'num_random_affixes']
            for field in required_item_fields:
                if field not in item:
                    print(f"âŒ Item missing required field: {field}")
                    return False

        if data['affixes']:
            affix = next(iter(data['affixes'].values()))
            required_affix_fields = ['affix_id', 'stat_affected', 'mod_type', 'base_value', 'description']
            for field in required_affix_fields:
                if field not in affix:
                    print(f"âŒ Affix missing required field: {field}")
                    return False

        print("âœ… Sample data validation passed")
        print("\nðŸŽ¯ PR5 IMPLEMENTATION VERIFIED COMPLETE âœ…")
        return True

    except Exception as e:
        print(f"âŒ Data loading failed: {e}")
        return False

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)



// =================================================================
// METADATA
// =================================================================
// File Path:      test_phase2.py
// Size:           2.89 KB
// Last Modified:  2025-11-15T14:00:47.260Z
// =================================================================

from src.models import Entity, EntityStats, RolledAffix, Item
from src.state import StateManager
from src.engine import CombatEngine
from src.events import EventBus

print('=== TESTING PHASE 2: FULL PIPELINE & AFFIX HANDLING ===')

attacker_stats = EntityStats(base_damage=25.0, crit_chance=0.2)
attacker = Entity('attacker', attacker_stats)

bleed_affix = RolledAffix(
    affix_id='bleed_chance',
    stat_affected='base_damage',
    mod_type='flat',
    description='+0% chance to Bleed',
    base_value=0,
    value=0,
    trigger_event='OnHit',
    proc_rate=1.0,
    trigger_result='bleed',
    trigger_duration=10.0,
    stacks_max=5
)

weapon = Item(
    instance_id='sword1',
    base_id='iron_sword',
    name='Iron Sword',
    slot='weapon',
    rarity='Common',
    quality_tier='Normal',
    quality_roll=1,
    affixes=[bleed_affix]
)

attacker.equip_item(weapon)
print(f'Attacker equipped weapon with {len(attacker.active_triggers)} reactive trigger(s)')
if attacker.active_triggers:
    trigger = attacker.active_triggers[0]
    print(f'Trigger: {trigger.event} -> {trigger.result.get("apply_debuff", "none")}')

defender_stats = EntityStats(
    max_health=120.0,
    armor=15.0,
    evasion_chance=0.0,  # No evasion for testing
    dodge_chance=0.0,    # No dodge
    block_chance=0.0,    # No block
    block_amount=12.0
)
defender = Entity('defender', defender_stats, 'Defender')

print(f'Defender: {defender.final_stats.max_health} HP, {defender.final_stats.evasion_chance*100:.0f}% evade, {defender.final_stats.block_chance*100:.0f}% block')

manager = StateManager()
manager.register_entity(attacker)
manager.register_entity(defender)
engine = CombatEngine()
bus = EventBus()

class TestSkill:
    def __init__(self):
        self.name = 'Quick Strike'
        self.hits = 1
        self.resource_cost = 10.0
        self.cooldown = 2.0
        self.triggers = []

skill = TestSkill()

print(f'Skill: {skill.name} (Cost: {skill.resource_cost}, CD: {skill.cooldown}s)')
print(f'Attacker resource before: {manager.get_state("attacker").current_resource}')

success = engine.process_skill_use(attacker, defender, skill, bus, manager)
print(f'Skill use success: {success}')
print(f'Attacker resource after: {manager.get_state("attacker").current_resource}')

defender_state = manager.get_state('defender')
hit_context = engine.resolve_hit(attacker, defender, manager)  # Separate test hit
print(f'Hit Result: Dodged={hit_context.was_dodged}, Glancing={hit_context.is_glancing}, Blocked={hit_context.was_blocked}, Crit={hit_context.is_crit}, Damage={hit_context.final_damage}')
print(f'Defender HP after skill: {defender_state.current_health if defender_state else "N/A"}')
print(f'Defender has active debuffs: {len(defender_state.active_debuffs) if defender_state else 0}')

print('=== PHASE 2 COMPLETE: Full Pipeline, Events, & Reactive Affixes === âœ…')



// =================================================================
// METADATA
// =================================================================
// File Path:      test_phase3.py
// Size:           8.07 KB
// Last Modified:  2025-11-15T14:04:50.567Z
// =================================================================

from src.models import Entity, EntityStats, RolledAffix, Item
from src.state import StateManager
from src.engine import CombatEngine
from src.events import EventBus

print('=== TESTING PHASE 3: ADVANCED AFFIXES - DUAL-STAT & COMPLEX EFFECTS ===')

# Create high-power attacker with Berserker Rage (scaling dual-stat) and Focused Rage (skill use trigger)
attacker_stats = EntityStats(
    base_damage=50.0,  # High base damage for scaling effects
    max_health=200.0,
    armor=50.0,
    crit_chance=0.15,
    crit_damage=2.0,
    pierce_ratio=0.2,
    max_resource=120.0  # High resource for frequent skill use
)
attacker = Entity('berserker', attacker_stats)

# Create dual-stat scaling affix: berserker_rage (scales damage & crit with power)
berserker_affix = RolledAffix(
    affix_id='berserker_rage',
    stat_affected='base_damage;crit_chance',
    mod_type='scaling;scaling',
    description='+{value}% Damage & Crit (scales with power)',
    base_value='0.5;0.3',
    value=0.5,  # Primary scaling multiplier
    scaling_power=True,  # This will amplify based on character power
    dual_stat='crit_chance'
)

# Create complex skill-use trigger: focused_rage (applies crit bonus on special skills)
focused_rage_affix = RolledAffix(
    affix_id='focused_rage',
    stat_affected='',  # Purely trigger-based
    mod_type='',
    description='Special skills apply +25% crit chance for 5s',
    base_value='',
    value=0.0,
    trigger_event='OnSkillUsed',
    proc_rate=1.0,
    trigger_result='apply_crit_bonus:0.25',
    trigger_duration=5.0,
    complex_effect='special_skill'
)

# Equip both affixes on berserker weapon
weapon = Item(
    instance_id='berserker_axe',
    base_id='berserker_axe',
    name='Berserker Axe',
    slot='weapon',
    rarity='Epic',
    quality_tier='Perfect',
    quality_roll=9,
    affixes=[berserker_affix, focused_rage_affix]
)

attacker.equip_item(weapon)

print(f'=== ATTACKER POWER ANALYSIS ===')
print(f'Base Damage: {attacker.base_stats.base_damage}')
print(f'Calculated Power Level: ~{(attacker.base_stats.base_damage + attacker.base_stats.max_health * 0.1 + attacker.base_stats.armor * 2 + (attacker.base_stats.crit_chance * 100) + (attacker.base_stats.pierce_ratio * 1000)) / 100.0:.1f}')
print(f'Final Stats:')
print(f'  Damage: {attacker.final_stats.base_damage:.1f} (+{(attacker.final_stats.base_damage - attacker.base_stats.base_damage):.1f} from scaling)')
print(f'  Crit Chance: {attacker.final_stats.crit_chance:.2%} (+{attacker.final_stats.crit_chance - attacker.base_stats.crit_chance:.2%} from scaling)')
print(f'Active Triggers: {len(attacker.active_triggers)}')

# Create tanky defender with Thornmail (complex reactive effect)
defender_stats = EntityStats(
    max_health=400.0,  # High HP for tanking
    armor=100.0,
    evasion_chance=0.0,  # No evasion for testing damage
    dodge_chance=0.0,
    block_chance=0.4,    # 40% block chance
    block_amount=30.0    # High block amount
)
defender = Entity('tank', defender_stats)

# Thornmail reactive affix: reflects damage when blocking
thornmail_affix = RolledAffix(
    affix_id='thornmail',
    stat_affected='',  # Purely trigger-based
    mod_type='',
    description='Returns 30% of blocked damage',
    base_value='',
    value=0.0,
    trigger_event='OnBlock',
    proc_rate=0.5,  # 50% proc rate on blocks
    trigger_result='reflect_damage:0.3'
)

armor = Item(
    instance_id='thornmail_armor',
    base_id='thornmail',
    name='Thornmail',
    slot='armor',
    rarity='Rare',
    quality_tier='Good',
    quality_roll=5,
    affixes=[thornmail_affix]
)

defender.equip_item(armor)
print(f'\n=== DEFENDER TANK ANALYSIS ===')
print(f'Base Health: {defender.base_stats.max_health}')
print(f'Final Health: {defender.final_stats.max_health}')
print(f'Block Stats: {defender.final_stats.block_chance*100:.0f}% chance, {defender.final_stats.block_amount} amount')
print(f'Active Triggers: {len(defender.active_triggers)} (Thornmail effect)')
if defender.active_triggers:
    trigger = defender.active_triggers[0]
    print(f'  {trigger.event} -> Reflect {trigger.result.get("reflect_damage", 0)*100:.0f}% damage')

print(f'\n=== COMBAT TEST: PHASE 3 ADVANCED AFFIXES ===')

manager = StateManager()
manager.register_entity(attacker)
manager.register_entity(defender)
engine = CombatEngine()
bus = EventBus()

class SpecialSkill:
    def __init__(self):
        self.name = 'Berserker Fury'
        self.hits = 1
        self.resource_cost = 15.0
        self.cooldown = 3.0
        self.triggers = []

skill = SpecialSkill()

# Check initial state
attacker_state = manager.get_state('berserker')
defender_state = manager.get_state('tank')

print(f'Initial State:')
print(f'  Berserker Resource: {attacker_state.current_resource if attacker_state else 0}')
print(f'  Tank Health: {defender_state.current_health if defender_state else 0}')

# 1. Use special skill to trigger Focused Rage
print(f'\n=== TRIGGERING FOCUSED RAGE ===')
print(f'Using {skill.name} (cost: {skill.resource_cost})...')
success = engine.process_skill_use(attacker, defender, skill, bus, manager)
print(f'Skill use: {"Success" if success else "Failed"}')

if success:
    # Check if crit modifier was applied
    attacker_state = manager.get_state('berserker')
    crit_mods = attacker_state.roll_modifiers.get('crit_chance', []) if attacker_state else []
    print(f'Focused Rage Triggered: {len(crit_mods)} crit modifier(s) applied')
    if crit_mods:
        mod_desc = [f'+{mod.value:.1%} crit for {mod.duration}s' for mod in crit_mods]
        print(f'  Modifiers: {", ".join(mod_desc)}')

    # 2. Attack multiple times to trigger scaling damage and potential blocks/thornmail
    print(f'\n=== MULTI-HIT COMBAT TEST ===')
    hits_landed = 0
    hits_blocked = 0
    total_damage = 0
    reflected_damage = 0

    for i in range(5):
        # Create a basic attack
        basic_attack = type('BasicAttack', (), {'name': 'Slash', 'hits': 1, 'resource_cost': 5.0, 'cooldown': 1.0, 'triggers': []})()

        pre_health = defender_state.current_health if defender_state else 0
        success = engine.process_skill_use(attacker, defender, basic_attack, bus, manager)

        defender_state = manager.get_state('tank')
        post_health = defender_state.current_health if defender_state else 0

        if success and (pre_health - post_health) > 0:
            hits_landed += 1
            damage_done = pre_health - post_health
            total_damage += damage_done
            print(f'Hit {i+1}: {damage_done:.1f} damage ({pre_health:.0f} -> {post_health:.0f})')

            # Check for block/reflect indicators (simplified - would need event logging)
        elif not success:
            print(f'Hit {i+1}: Missed/blocked or insufficient resources')

    attacker_state = manager.get_state('berserker')
    defender_state = manager.get_state('tank')

    print(f'\n=== PHASE 3 RESULTS SUMMARY ===')
    print(f'Total Hits Landed: {hits_landed}/5')
    print(f'Total Damage Dealt: {total_damage:.1f}')
    print(f'Defender Health Remaining: {defender_state.current_health if defender_state else 0:.0f}/{defender.final_stats.max_health}')
    print(f'Berserker Resource Remaining: {attacker_state.current_resource if attacker_state else 0:.1f}/{attacker.final_stats.max_resource}')

    # Demonstrate scaling by comparing expected vs actual damage
    expected_avg_damage = attacker.final_stats.base_damage * 0.8  # Rough average with mitigation
    actual_avg_damage = total_damage / hits_landed if hits_landed > 0 else 0
    print(f'Efficiency: {actual_avg_damage:.1f} avg damage (expected ~{expected_avg_damage:.1f})')

    print(f'\n=== ADVANCED AFFIXES WORKING === âœ…')
    print(f'Dual-Stat Scaling: Berserker Rage increased damage & crit based on power level')
    print(f'Reactive Complex Effects: Focused Rage applied crit bonuses on special skill use')
    print(f'Defensive Reactive: Thornmail can reflect damage on successful blocks')
    print(f'Advanced Combat Pipeline: Full integration of modifiers, triggers, and complex effects')



// =================================================================
// METADATA
// =================================================================
// File Path:      test_phase4.py
// Size:           4.49 KB
// Last Modified:  2025-11-15T14:17:38.324Z
// =================================================================

from src.data_loader import get_data_loader, MasterRuleData
from src.models import Entity, EntityStats, RolledAffix, Item

print('=== TESTING PHASE 4: MASTER RULE DATA SYSTEM ===')
print()

# Test the Master Rule Data System
loader = get_data_loader()

print('=== CSV DATA LOADING ===')
stats = loader.get_data_stats()
print(f'Loaded {stats["skills"]} skills from skills.csv')
print(f'Loaded {stats["effects"]} effects from effects.csv')
print(f'Loaded {stats["affixes"]} affixes from affixes.csv')
print()

print('=== DATA VALIDATION ===')
issues = loader.validate_data_consistency()
if issues:
    print(f'Found {len(issues)} data consistency issues:')
    for issue in issues:
        print(f'  âŒ {issue}')
else:
    print('âœ… All data references are valid')
print()

print('=== EXAMPLE SKILLS ===')
basic_slash = loader.get_skill('basic_slash')
if basic_slash:
    print(f"Basic Slash: {basic_slash.description}")
    print(f"  Cost: {basic_slash.resource_cost}, Cooldown: {basic_slash.cooldown}s")

berserker_rage = loader.get_skill('berserker_rage')
if berserker_rage:
    print(f"Berserker Rage: {berserker_rage.description}")
    print(f"  Triggers: {len(berserker_rage.triggers)} active effects")
    if berserker_rage.triggers:
        trigger = berserker_rage.triggers[0]
        print(f"    On {trigger.event}: {list(trigger.result.keys())[0]} = {list(trigger.result.values())[0]}")
print()

print('=== EXAMPLE EFFECTS ===')
bleed_effect = loader.get_effect('bleed')
if bleed_effect:
    print(f"Bleed: {bleed_effect.description}")
    print(f"  Type: {bleed_effect.type}, Max Stacks: {bleed_effect.max_stacks}")
    print(f"  Damage: {bleed_effect.damage_per_tick}/tick every {bleed_effect.tick_rate}s")

divine_shield = loader.get_effect('divine_shield')
if divine_shield:
    print(f"Divine Shield: {divine_shield.description}")
    print(f"  Damage Reduction: {divine_shield.stat_multiplier * 100}%")
print()

print('=== EXAMPLE AFFIXES ===')
berserker_affix = loader.get_affix('berserker_rage')
if berserker_affix:
    print(f"Berserker Rage Affix: {berserker_affix.description}")
    print(f"  Scaling Power: {berserker_affix.scaling_power}")
    print(f"  Dual Stat: {berserker_affix.dual_stat}")

thornmail_affix = loader.get_affix('thornmail')
if thornmail_affix:
    print(f"Thornmail Affix: {thornmail_affix.description}")
    print(f"  Trigger Event: {thornmail_affix.trigger_event}")
    proc_rate = thornmail_affix.proc_rate * 100 if thornmail_affix.proc_rate else 0
    print(f"  Proc Rate: {proc_rate:.0f}%")
print()

print('=== QUERY FUNCTIONALITY ===')
magic_skills = loader.find_skills_by_type('Magic')
print(f"Magic Skills Found: {len(magic_skills)}")
for skill in magic_skills[:3]:  # Show first 3
    print(f"  {skill.name} ({skill.damage_type})")

weapon_affixes = loader.find_affixes_by_pool('weapon_pool')
print(f"Weapon Pool Affixes: {len(weapon_affixes)}")
for affix in weapon_affixes[:3]:  # Show first 3
    print(f"  {affix.affix_id}: {affix.description[:30]}...")
print()

print('=== RUNTIME INTEGRATION ===')

# Create an entity and equip it with a scaling affix from CSV
entity = Entity('hero', EntityStats(base_damage=25.0, max_health=150.0))
print(f"Base Stats: {entity.final_stats.base_damage} dmg, {entity.final_stats.max_health:.0f} hp")

# Equip the Berserker Rage affix (scaling dual-stat)
if berserker_affix:
    item = Item('sword1', 'berserker_sword', 'Berserker Sword', 'weapon', 'Epic', 'Perfect', 9, [berserker_affix])
    entity.equip_item(item)
    print(f"After Berserker Sword: {entity.final_stats.base_damage:.1f} dmg (+{entity.final_stats.base_damage - 25:.1f} scaling)")
    print(f"Crit Chance: {entity.final_stats.crit_chance:.1%}")
    print(f"Active Triggers: {len(entity.active_triggers)}")

print()
print('=== PHASE 4 COMPLETE: MASTER RULE DATA SYSTEM === âœ…')
print()
print('Phase 4 Summary:')
print('âœ… skills.csv - All combat skills with costs, cooldowns, triggers')
print('âœ… effects.csv - Buffs/debuffs/DoTs with full effect parameters')
print('âœ… affixes.csv - Extended with dual-stats, scaling, complex effects')
print('âœ… data_loader.py - Complete CSV loading system with validation')
print('âœ… Runtime Integration - CSV data drives combat mechanics')
print('âœ… Data Consistency - Validation ensures all references are valid')
print()
print('ðŸŽ‰ COMBAT ENGINE NOW FULLY CSV-DRIVEN! ðŸŽ‰')
print('No more hardcoded skills/effects/affixes!')
print('Add new mechanics by simply editing CSV files!')



// =================================================================
// METADATA
// =================================================================
// File Path:      test_pr_p1s3.py
// Size:           2.52 KB
// Last Modified:  2025-11-18T19:44:40.609Z
// =================================================================

#!/usr/bin/env python3
"""Test script for PR-P1S3: Data Pipeline Hardening with Strict Typing and Cross-Reference Validation"""

import sys
import os

# Add the src directory to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

def test_data_loading():
    """Test that the new typed GameDataProvider loads data correctly."""
    print("ðŸ”§ Testing PR-P1S3 Data Pipeline...")

    try:
        from src.game_data_provider import GameDataProvider

        # Clear singleton instance for testing
        GameDataProvider._instance = None

        # This should trigger data loading and validation
        provider = GameDataProvider()

        # Test accessing typed data
        affixes = provider.get_affixes()
        items = provider.get_items()
        effects = provider.get_effects()
        skills = provider.get_skills()
        quality_tiers = provider.get_quality_tiers()

        print("âœ… Data loading successful!")
        print(f"   - Loaded {len(affixes)} affixes")
        print(f"   - Loaded {len(items)} items")
        print(f"   - Loaded {len(effects)} effects")
        print(f"   - Loaded {len(skills)} skills")
        print(f"   - Loaded {len(quality_tiers)} quality tiers")

        # Test that the objects are correctly typed
        if affixes:
            first_affix = next(iter(affixes.values()))
            print("âœ… Affix type checking successful")
            print(f"   - First affix: {first_affix.affix_id} -> {first_affix.stat_affected}")

        if items:
            first_item = next(iter(items.values()))
            print("âœ… Item type checking successful")
            print(f"   - First item: {first_item.item_id} -> {first_item.name}")

        if effects:
            first_effect = next(iter(effects.values()))
            print("âœ… Effect type checking successful")
            print(f"   - First effect: {first_effect.effect_id} -> {first_effect.name}")

        if skills:
            first_skill = next(iter(skills.values()))
            print("âœ… Skill type checking successful")
            print(f"   - First skill: {first_skill.skill_id} -> {first_skill.name}")

        print("\nðŸŽ‰ PR-P1S3 implementation appears successful!")

    except Exception as e:
        print("âŒ Test failed with error:")
        print(f"   {e}")
        import traceback
        traceback.print_exc()
        return False

    return True

if __name__ == "__main__":
    success = test_data_loading()
    sys.exit(0 if success else 1)



// =================================================================
// METADATA
// =================================================================
// File Path:      test_strict_mode.py
// Size:           5.75 KB
// Last Modified:  2025-11-17T14:19:36.658Z
// =================================================================

#!/usr/bin/env python3
"""
Test strict mode enforcement and legacy compatibility for PR8c migration.
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from models import Entity, EntityStats
from state import StateManager


def test_strict_mode_keyerror_unregistered_access():
    """Test that strict mode raises KeyError for unregistered entities."""
    print("Testing strict mode KeyError behavior...")

    manager = StateManager(strict_mode=True)

    # Test apply_damage to unregistered entity
    try:
        manager.apply_damage("unknown", 50.0)
        assert False, "Should have raised KeyError for unregistered entity"
    except KeyError as e:
        assert "not registered" in str(e)

    # Test apply_effect to unregistered entity - this requires mocking to avoid imports
    # We'll test the core strict_mode check

    # Test get_state on unregistered entity
    try:
        manager.get_state("unknown")
        assert False, "Should have raised KeyError for unregistered entity"
    except KeyError as e:
        assert "not registered" in str(e)

    # Test set_health on unregistered entity
    try:
        manager.set_health("unknown", 50.0)
        assert False, "Should have raised KeyError for unregistered entity"
    except KeyError as e:
        assert "not registered" in str(e)

    print("âœ… Strict mode enforcement verified")


def test_strict_mode_disabled_behavior():
    """Test behavior when strict mode is disabled."""
    print("Testing non-strict mode behavior...")

    manager = StateManager(strict_mode=False)

    # In non-strict mode, get_state still requires registration
    # because all methods call get_state()
    try:
        manager.apply_damage("unknown", 50.0)
        assert False, "Should have raised KeyError even in non-strict mode"
    except KeyError as e:
        assert "not registered" in str(e)

    print("âœ… Non-strict mode behaves correctly (all modes require registration)")


def test_legacy_compatibility_methods():
    """Test that legacy compatibility methods work through new API."""
    print("Testing legacy compatibility methods...")

    manager = StateManager()

    # Create a test entity
    stats = EntityStats(max_health=100.0)
    entity = Entity(id="test_entity", base_stats=stats)

    # Test register_entity (legacy method)
    manager.register_entity(entity)
    assert manager.is_registered("test_entity")
    assert manager.get_current_health("test_entity") == 100.0

    # Test legacy tick method (delegates to update)
    initial_health = manager.get_current_health("test_entity")
    manager.tick(1.0)  # Should work without error
    assert manager.get_current_health("test_entity") == initial_health  # Health unchanged

    # Test unregister_entity (legacy method)
    manager.unregister_entity("test_entity")
    assert not manager.is_registered("test_entity")

    # Test get_all_states (legacy method)
    all_states = manager.get_all_states()
    assert isinstance(all_states, dict)
    assert len(all_states) == 0  # No entities

    print("âœ… Legacy compatibility methods working")


def test_legacy_methods_with_strict_mode():
    """Test legacy methods work correctly in strict mode."""
    print("Testing legacy methods with strict mode enabled...")

    manager = StateManager(strict_mode=True)

    stats = EntityStats(max_health=100.0)
    entity = Entity(id="test_entity", base_stats=stats)

    # Legacy register method should work
    manager.register_entity(entity)
    assert manager.is_registered("test_entity")

    # Legacy tick method should work
    manager.tick(0.5)

    # Legacy unregister should work
    manager.unregister_entity("test_entity")
    assert not manager.is_registered("test_entity")

    print("âœ… Legacy methods work with strict mode")


def test_state_management_edge_cases():
    """Test edge cases in state management."""
    print("Testing state management edge cases...")

    manager = StateManager()

    # Create entity
    stats = EntityStats(max_health=100.0)
    entity = Entity(id="test_entity", base_stats=stats)
    manager.add_entity(entity)

    # Test setting health to negative (should clamp to 0)
    manager.set_health("test_entity", -10.0)
    assert manager.get_current_health("test_entity") == 0.0
    assert not manager.get_is_alive("test_entity")

    # Recreate entity for next test
    manager.add_entity(entity)

    # Test resource clamping
    manager.set_resource("test_entity", 150.0)  # Above max
    assert manager.get_current_resource("test_entity") == 100.0

    manager.set_resource("test_entity", -10.0)  # Below 0
    assert manager.get_current_resource("test_entity") == 0.0

    print("âœ… Edge case handling verified")


def test_manager_creation_and_len():
    """Test basic StateManager creation and length tracking."""
    print("Testing StateManager creation and length...")

    manager = StateManager()
    assert len(manager) == 0
    assert "unknown" not in manager

    # Add entity and verify length
    stats = EntityStats(max_health=100.0)
    entity = Entity(id="test_entity", base_stats=stats)
    manager.add_entity(entity)

    assert len(manager) == 1
    assert "test_entity" in manager
    assert "unknown" not in manager

    print("âœ… StateManager basics verified")


if __name__ == "__main__":
    print("=== PR8c Strict Mode Verification Tests ===\n")

    test_strict_mode_keyerror_unregistered_access()
    test_strict_mode_disabled_behavior()
    test_legacy_compatibility_methods()
    test_legacy_methods_with_strict_mode()
    test_state_management_edge_cases()
    test_manager_creation_and_len()

    print("\nðŸŽ‰ All PR8c verification tests passed!")



// =================================================================
// METADATA
// =================================================================
// File Path:      test_trigger_parsing.py
// Size:           3.07 KB
// Last Modified:  2025-11-15T14:12:46.380Z
// =================================================================

from src.models import Entity, EntityStats, RolledAffix, Item
from src.state import StateManager

print('=== TRIGGER PARSING VERIFICATION TEST ===')
print()

# Test the parsing of different trigger_result formats
print('Testing trigger parsing logic...')
print()

# Create a test entity
base_stats = EntityStats(base_damage=10.0)
entity = Entity('test', base_stats)

# Test 1: Simple debuff trigger (like bleed_chance)
print('1. Simple Debuff Trigger ("bleed")')
simple_affix = RolledAffix(
    affix_id='bleed',
    stat_affected='base_damage',
    mod_type='flat',
    description='simple debuff',
    base_value=0,
    value=0,
    trigger_event='OnHit',
    proc_rate=1.0,
    trigger_result='bleed',  # Just simple name
    trigger_duration=10.0,
    stacks_max=5
)

test_item = Item('test_item', 'test', 'Test Item', 'weapon', 'Common', 'Normal', 1, [simple_affix])
entity.equip_item(test_item)

print(f'   Input: trigger_result="bleed"')
print(f'   Parsed: {entity.active_triggers[0].result}')
print()

# Test 2: Complex trigger with colon (like reflect_damage)
print('2. Complex Trigger ("reflect_damage:0.3")')
entity = Entity('test2', base_stats)  # Fresh entity

complex_affix = RolledAffix(
    affix_id='thornmail',
    stat_affected='',  # Pure trigger
    mod_type='',
    description='reflect damage',
    base_value='',
    value=0.0,
    trigger_event='OnBlock',
    proc_rate=1.0,
    trigger_result='reflect_damage:0.3',  # Effect:value format
    trigger_duration=0,
    stacks_max=1
)

test_item2 = Item('test_item2', 'test', 'Thornmail', 'armor', 'Rare', 'Good', 3, [complex_affix])
entity.equip_item(test_item2)

print(f'   Input: trigger_result="reflect_damage:0.3"')
print(f'   Parsed: {entity.active_triggers[0].result}')
print(f'   Reflect Ratio: {entity.active_triggers[0].result.get("reflect_damage", "NOT FOUND")}')
print()

# Test 3: Crit bonus trigger
print('3. Crit Bonus Trigger ("apply_crit_bonus:0.25")')
entity = Entity('test3', base_stats)

crit_affix = RolledAffix(
    affix_id='focused_rage',
    stat_affected='',
    mod_type='',
    description='crit bonus',
    base_value='',
    value=0.0,
    trigger_event='OnSkillUsed',
    proc_rate=1.0,
    trigger_result='apply_crit_bonus:0.25',
    trigger_duration=5.0,
    stacks_max=1
)

test_item3 = Item('test_item3', 'test', 'Rage Buff', 'jewelry', 'Epic', 'Perfect', 5, [crit_affix])
entity.equip_item(test_item3)

print(f'   Input: trigger_result="apply_crit_bonus:0.25"')
print(f'   Parsed: {entity.active_triggers[0].result}')
print(f'   Crit Bonus: {entity.active_triggers[0].result.get("apply_crit_bonus", "NOT FOUND")}')
print()

print('=== VERIFICATION COMPLETE ===')
print()
print('âœ… Simple triggers: parsed as {"apply_debuff": "effect_name"}')
print('âœ… Complex triggers: parsed as {"effect_key": numeric_value}')
print('âœ… All trigger metadata preserved (duration, stacks_max)')
print()
print('BEFORE FIX: All triggers incorrectly parsed as apply_debuff')
print('AFTER FIX: Proper type detection and parsing based on colon separator')



// =================================================================
// METADATA
// =================================================================
// File Path:      version.txt
// Size:           0.01 KB
// Last Modified:  2025-11-19T10:49:08.337Z
// =================================================================

2.2.1


