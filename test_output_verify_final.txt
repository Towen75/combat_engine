.........................................F.....FFF...................... [ 25%]
........................................................................ [ 51%]
.................................F...................F........ [ 74%]
........................................................................ [100%]
================================== FAILURES ===================================
__________ TestCrossReferenceValidation.test_valid_cross_references ___________

self = <test_cross_reference_validation.TestCrossReferenceValidation object at 0x000001EE8089DA60>

    def test_valid_cross_references(self):
        """Test that valid cross-references pass validation."""
        data_dir = self.create_test_csv_files()
    
>       with patch('src.game_data_provider.os.path.dirname', return_value=data_dir), \
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             patch('src.game_data_provider.os.path.join', side_effect=os.path.join):

tests\test_cross_reference_validation.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.12_3.12.2800.0_x64__qbz5n2kfra8p0\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.game_data_provider.os.path'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src' has no attribute 'game_data_provider'

C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.12_3.12.2800.0_x64__qbz5n2kfra8p0\Lib\pkgutil.py:528: AttributeError
__________ TestCrossReferenceValidation.test_valid_dual_stat_affixes __________

self = <test_cross_reference_validation.TestCrossReferenceValidation object at 0x000001EE8089E1E0>

    def test_valid_dual_stat_affixes(self):
        """Test that dual stat affixes are supported."""
        # Integration test - this validates that real data loading handles dual stats
>       provider = GameDataProvider()
                   ^^^^^^^^^^^^^^^^^^

tests\test_cross_reference_validation.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\data\game_data_provider.py:57: in __init__
    self._load_and_validate_data()
src\data\game_data_provider.py:72: in _load_and_validate_data
    self._validate_cross_references()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.data.game_data_provider.GameDataProvider object at 0x000001EE80588C20>

    def _validate_cross_references(self) -> None:
        """
        Validates all data cross-references for logical integrity.
        Raises DataValidationError if any dangling reference is found.
        """
        logger.info("GameDataProvider: Starting cross-reference validation")
    
        # 1. Validate skills -> effects: skill trigger_result must point to valid effect_id
        # But skip validation for complex effect syntax (containing : or _target)
        for skill_id, skill in self.skills.items():
            if skill.trigger_result:
                # Skip validation for complex effect syntax
                if ":" in skill.trigger_result or "_target" in skill.trigger_result:
                    continue
                # Skip validation for heal/bless effects (special handling)
                if any(keyword in skill.trigger_result for keyword in ["heal_", "bless_", "drain_"]):
                    continue
    
                if skill.trigger_result not in self.effects:
                    raise DataValidationError(
                        f"Skill '{skill_id}' references non-existent effect ID '{skill.trigger_result}'",
                        data_type="SkillDefinition",
                        field_name="trigger_result",
                        invalid_id=skill.trigger_result,
                        suggestions=list(self.effects.keys())
                    )
    
        # 2. Validate items -> implicit_affixes: item implicit affixes must point to valid affix_ids
        for item_id, item in self.items.items():
            if item.implicit_affixes:
                for affix_id in item.implicit_affixes:
                    if affix_id not in self.affixes:
                        raise DataValidationError(
                            f"Item '{item_id}' references non-existent implicit affix ID '{affix_id}'",
                            data_type="ItemTemplate",
                            field_name="implicit_affixes",
                            invalid_id=affix_id,
                            suggestions=list(self.affixes.keys())
                        )
    
        # 3. Validate affixes -> EntityStats: affix stat_affected must be valid EntityStats attribute
        all_stat_names = []
        for affix in self.affixes.values():
            # Handle dual-stats (separated by semicolon)
            stat_names = [s.strip() for s in affix.stat_affected.split(';')]
            all_stat_names.extend(stat_names)
    
        validate_entity_stats_are_valid(all_stat_names)
    
        # 4. Validate quality tiers -> Rarity: rarity columns should match Rarity enum
>       from .data.typed_models import Rarity
E       ModuleNotFoundError: No module named 'src.data.data'

src\data\game_data_provider.py:169: ModuleNotFoundError
------------------------------ Captured log call ------------------------------
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\affixes.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\items.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\quality_tiers.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\effects.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\skills.csv, skipping
ERROR    src.data.game_data_provider:game_data_provider.py:78 GameDataProvider: Failed to load and validate data: No module named 'src.data.data'
___ TestCrossReferenceValidation.test_skill_without_trigger_result_is_valid ___

self = <test_cross_reference_validation.TestCrossReferenceValidation object at 0x000001EE8089DCA0>

    def test_skill_without_trigger_result_is_valid(self):
        """Test that skills without trigger_result are handled correctly."""
>       provider = GameDataProvider()
                   ^^^^^^^^^^^^^^^^^^

tests\test_cross_reference_validation.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\data\game_data_provider.py:57: in __init__
    self._load_and_validate_data()
src\data\game_data_provider.py:72: in _load_and_validate_data
    self._validate_cross_references()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.data.game_data_provider.GameDataProvider object at 0x000001EE80657290>

    def _validate_cross_references(self) -> None:
        """
        Validates all data cross-references for logical integrity.
        Raises DataValidationError if any dangling reference is found.
        """
        logger.info("GameDataProvider: Starting cross-reference validation")
    
        # 1. Validate skills -> effects: skill trigger_result must point to valid effect_id
        # But skip validation for complex effect syntax (containing : or _target)
        for skill_id, skill in self.skills.items():
            if skill.trigger_result:
                # Skip validation for complex effect syntax
                if ":" in skill.trigger_result or "_target" in skill.trigger_result:
                    continue
                # Skip validation for heal/bless effects (special handling)
                if any(keyword in skill.trigger_result for keyword in ["heal_", "bless_", "drain_"]):
                    continue
    
                if skill.trigger_result not in self.effects:
                    raise DataValidationError(
                        f"Skill '{skill_id}' references non-existent effect ID '{skill.trigger_result}'",
                        data_type="SkillDefinition",
                        field_name="trigger_result",
                        invalid_id=skill.trigger_result,
                        suggestions=list(self.effects.keys())
                    )
    
        # 2. Validate items -> implicit_affixes: item implicit affixes must point to valid affix_ids
        for item_id, item in self.items.items():
            if item.implicit_affixes:
                for affix_id in item.implicit_affixes:
                    if affix_id not in self.affixes:
                        raise DataValidationError(
                            f"Item '{item_id}' references non-existent implicit affix ID '{affix_id}'",
                            data_type="ItemTemplate",
                            field_name="implicit_affixes",
                            invalid_id=affix_id,
                            suggestions=list(self.affixes.keys())
                        )
    
        # 3. Validate affixes -> EntityStats: affix stat_affected must be valid EntityStats attribute
        all_stat_names = []
        for affix in self.affixes.values():
            # Handle dual-stats (separated by semicolon)
            stat_names = [s.strip() for s in affix.stat_affected.split(';')]
            all_stat_names.extend(stat_names)
    
        validate_entity_stats_are_valid(all_stat_names)
    
        # 4. Validate quality tiers -> Rarity: rarity columns should match Rarity enum
>       from .data.typed_models import Rarity
E       ModuleNotFoundError: No module named 'src.data.data'

src\data\game_data_provider.py:169: ModuleNotFoundError
------------------------------ Captured log call ------------------------------
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\affixes.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\items.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\quality_tiers.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\effects.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\skills.csv, skipping
ERROR    src.data.game_data_provider:game_data_provider.py:78 GameDataProvider: Failed to load and validate data: No module named 'src.data.data'
__ TestCrossReferenceValidation.test_item_without_implicit_affixes_is_valid ___

self = <test_cross_reference_validation.TestCrossReferenceValidation object at 0x000001EE8089D850>

    def test_item_without_implicit_affixes_is_valid(self):
        """Test that items without implicit affixes are handled correctly."""
>       provider = GameDataProvider()
                   ^^^^^^^^^^^^^^^^^^

tests\test_cross_reference_validation.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\data\game_data_provider.py:57: in __init__
    self._load_and_validate_data()
src\data\game_data_provider.py:72: in _load_and_validate_data
    self._validate_cross_references()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.data.game_data_provider.GameDataProvider object at 0x000001EE809AFD10>

    def _validate_cross_references(self) -> None:
        """
        Validates all data cross-references for logical integrity.
        Raises DataValidationError if any dangling reference is found.
        """
        logger.info("GameDataProvider: Starting cross-reference validation")
    
        # 1. Validate skills -> effects: skill trigger_result must point to valid effect_id
        # But skip validation for complex effect syntax (containing : or _target)
        for skill_id, skill in self.skills.items():
            if skill.trigger_result:
                # Skip validation for complex effect syntax
                if ":" in skill.trigger_result or "_target" in skill.trigger_result:
                    continue
                # Skip validation for heal/bless effects (special handling)
                if any(keyword in skill.trigger_result for keyword in ["heal_", "bless_", "drain_"]):
                    continue
    
                if skill.trigger_result not in self.effects:
                    raise DataValidationError(
                        f"Skill '{skill_id}' references non-existent effect ID '{skill.trigger_result}'",
                        data_type="SkillDefinition",
                        field_name="trigger_result",
                        invalid_id=skill.trigger_result,
                        suggestions=list(self.effects.keys())
                    )
    
        # 2. Validate items -> implicit_affixes: item implicit affixes must point to valid affix_ids
        for item_id, item in self.items.items():
            if item.implicit_affixes:
                for affix_id in item.implicit_affixes:
                    if affix_id not in self.affixes:
                        raise DataValidationError(
                            f"Item '{item_id}' references non-existent implicit affix ID '{affix_id}'",
                            data_type="ItemTemplate",
                            field_name="implicit_affixes",
                            invalid_id=affix_id,
                            suggestions=list(self.affixes.keys())
                        )
    
        # 3. Validate affixes -> EntityStats: affix stat_affected must be valid EntityStats attribute
        all_stat_names = []
        for affix in self.affixes.values():
            # Handle dual-stats (separated by semicolon)
            stat_names = [s.strip() for s in affix.stat_affected.split(';')]
            all_stat_names.extend(stat_names)
    
        validate_entity_stats_are_valid(all_stat_names)
    
        # 4. Validate quality tiers -> Rarity: rarity columns should match Rarity enum
>       from .data.typed_models import Rarity
E       ModuleNotFoundError: No module named 'src.data.data'

src\data\game_data_provider.py:169: ModuleNotFoundError
------------------------------ Captured log call ------------------------------
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\affixes.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\items.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\quality_tiers.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\effects.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\skills.csv, skipping
ERROR    src.data.game_data_provider:game_data_provider.py:78 GameDataProvider: Failed to load and validate data: No module named 'src.data.data'
__________________ TestHitContextBasics.test_to_serializable __________________

self = <test_hitcontext.TestHitContextBasics object at 0x000001EE8095AFF0>
attacker = Entity(id='att_001', name='Test Attacker')
defender = Entity(id='def_002', name='Test Defender')

    def test_to_serializable(self, attacker, defender):
        """Test JSON-safe representation works correctly."""
        attacker.id = "att_001"
        defender.id = "def_002"
    
        ctx = HitContext(
            attacker=attacker,
            defender=defender,
            base_raw=100,
            base_resolved=100,
            final_damage=75,
            was_crit=True,
            was_blocked=True,
            damage_blocked=25.0
        )
    
        serializable = ctx.to_serializable()
    
        # Should be a dict with only primitive/string values
>       assert serializable == {
            "attacker_id": "att_001",
            "defender_id": "def_002",
            "base_resolved": 100,
            "final_damage": 75,
            "was_crit": True,
            "was_dodged": False,
            "was_blocked": True,
            "was_glancing": False,
            "damage_pre_mitigation": 0.0,
            "damage_post_armor": 0.0,
            "damage_blocked": 25.0,
        }
E       AssertionError: assert {'attacker_id...d': 25.0, ...} == {'attacker_id...or': 0.0, ...}
E         
E         Omitting 11 identical items, use -vv to show
E         Left contains 2 more items:
E         {'batch_id': None, 'simulation_id': None}
E         Use -v to get more diff

tests\test_hitcontext.py:92: AssertionError
______________ TestItemGeneratorStrict.test_roll_dual_stat_affix ______________

self = <test_item_generator_strict.TestItemGeneratorStrict object at 0x000001EE8095ADE0>

    def test_roll_dual_stat_affix(self):
        """Test rolling an affix with two values."""
        # 1. Setup Mock Data using Typed Objects
>       gen = ItemGenerator(game_data=None) # Empty init
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_item_generator_strict.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\utils\item_generator.py:38: in __init__
    provider = GameDataProvider()
               ^^^^^^^^^^^^^^^^^^
src\data\game_data_provider.py:57: in __init__
    self._load_and_validate_data()
src\data\game_data_provider.py:72: in _load_and_validate_data
    self._validate_cross_references()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <src.data.game_data_provider.GameDataProvider object at 0x000001EE80AE75F0>

    def _validate_cross_references(self) -> None:
        """
        Validates all data cross-references for logical integrity.
        Raises DataValidationError if any dangling reference is found.
        """
        logger.info("GameDataProvider: Starting cross-reference validation")
    
        # 1. Validate skills -> effects: skill trigger_result must point to valid effect_id
        # But skip validation for complex effect syntax (containing : or _target)
        for skill_id, skill in self.skills.items():
            if skill.trigger_result:
                # Skip validation for complex effect syntax
                if ":" in skill.trigger_result or "_target" in skill.trigger_result:
                    continue
                # Skip validation for heal/bless effects (special handling)
                if any(keyword in skill.trigger_result for keyword in ["heal_", "bless_", "drain_"]):
                    continue
    
                if skill.trigger_result not in self.effects:
                    raise DataValidationError(
                        f"Skill '{skill_id}' references non-existent effect ID '{skill.trigger_result}'",
                        data_type="SkillDefinition",
                        field_name="trigger_result",
                        invalid_id=skill.trigger_result,
                        suggestions=list(self.effects.keys())
                    )
    
        # 2. Validate items -> implicit_affixes: item implicit affixes must point to valid affix_ids
        for item_id, item in self.items.items():
            if item.implicit_affixes:
                for affix_id in item.implicit_affixes:
                    if affix_id not in self.affixes:
                        raise DataValidationError(
                            f"Item '{item_id}' references non-existent implicit affix ID '{affix_id}'",
                            data_type="ItemTemplate",
                            field_name="implicit_affixes",
                            invalid_id=affix_id,
                            suggestions=list(self.affixes.keys())
                        )
    
        # 3. Validate affixes -> EntityStats: affix stat_affected must be valid EntityStats attribute
        all_stat_names = []
        for affix in self.affixes.values():
            # Handle dual-stats (separated by semicolon)
            stat_names = [s.strip() for s in affix.stat_affected.split(';')]
            all_stat_names.extend(stat_names)
    
        validate_entity_stats_are_valid(all_stat_names)
    
        # 4. Validate quality tiers -> Rarity: rarity columns should match Rarity enum
>       from .data.typed_models import Rarity
E       ModuleNotFoundError: No module named 'src.data.data'

src\data\game_data_provider.py:169: ModuleNotFoundError
------------------------------ Captured log call ------------------------------
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\affixes.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\items.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\quality_tiers.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\effects.csv, skipping
WARNING  src.data.data_parser:data_parser.py:83 CSV file not found: G:\Godot Projects\combat_engine\src\data\..\data\skills.csv, skipping
ERROR    src.data.game_data_provider:game_data_provider.py:78 GameDataProvider: Failed to load and validate data: No module named 'src.data.data'
=========================== short test summary info ===========================
FAILED tests/test_cross_reference_validation.py::TestCrossReferenceValidation::test_valid_cross_references
FAILED tests/test_cross_reference_validation.py::TestCrossReferenceValidation::test_valid_dual_stat_affixes
FAILED tests/test_cross_reference_validation.py::TestCrossReferenceValidation::test_skill_without_trigger_result_is_valid
FAILED tests/test_cross_reference_validation.py::TestCrossReferenceValidation::test_item_without_implicit_affixes_is_valid
FAILED tests/test_hitcontext.py::TestHitContextBasics::test_to_serializable
FAILED tests/test_item_generator_strict.py::TestItemGeneratorStrict::test_roll_dual_stat_affix
6 failed, 272 passed, 10 subtests passed in 0.85s
